{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Util } from './Util';\r\nimport { Factory } from './Factory';\r\nimport { Container } from './Container';\r\nimport { Konva } from './Global';\r\nimport { SceneCanvas, HitCanvas } from './Canvas';\r\nimport { DD } from './DragAndDrop';\r\nimport { _registerNode } from './Global';\r\nimport * as PointerEvents from './PointerEvents';\r\n// CONSTANTS\r\nvar STAGE = 'Stage', STRING = 'string', PX = 'px', MOUSEOUT = 'mouseout', MOUSELEAVE = 'mouseleave', MOUSEOVER = 'mouseover', MOUSEENTER = 'mouseenter', MOUSEMOVE = 'mousemove', MOUSEDOWN = 'mousedown', MOUSEUP = 'mouseup', \r\n// TODO: add them into \"on\" method docs and into site docs\r\nPOINTERMOVE = 'pointermove', POINTERDOWN = 'pointerdown', POINTERUP = 'pointerup', POINTERCANCEL = 'pointercancel', LOSTPOINTERCAPTURE = 'lostpointercapture', CONTEXTMENU = 'contextmenu', CLICK = 'click', DBL_CLICK = 'dblclick', TOUCHSTART = 'touchstart', TOUCHEND = 'touchend', TAP = 'tap', DBL_TAP = 'dbltap', TOUCHMOVE = 'touchmove', WHEEL = 'wheel', CONTENT_MOUSEOUT = 'contentMouseout', CONTENT_MOUSEOVER = 'contentMouseover', CONTENT_MOUSEMOVE = 'contentMousemove', CONTENT_MOUSEDOWN = 'contentMousedown', CONTENT_MOUSEUP = 'contentMouseup', CONTENT_CONTEXTMENU = 'contentContextmenu', CONTENT_CLICK = 'contentClick', CONTENT_DBL_CLICK = 'contentDblclick', CONTENT_TOUCHSTART = 'contentTouchstart', CONTENT_TOUCHEND = 'contentTouchend', CONTENT_DBL_TAP = 'contentDbltap', CONTENT_TAP = 'contentTap', CONTENT_TOUCHMOVE = 'contentTouchmove', CONTENT_POINTERMOVE = 'contentPointermove', CONTENT_POINTERDOWN = 'contentPointerdown', CONTENT_POINTERUP = 'contentPointerup', CONTENT_WHEEL = 'contentWheel', RELATIVE = 'relative', KONVA_CONTENT = 'konvajs-content', SPACE = ' ', UNDERSCORE = '_', CONTAINER = 'container', MAX_LAYERS_NUMBER = 5, EMPTY_STRING = '', EVENTS = [\r\n    MOUSEENTER,\r\n    MOUSEDOWN,\r\n    MOUSEMOVE,\r\n    MOUSEUP,\r\n    MOUSEOUT,\r\n    TOUCHSTART,\r\n    TOUCHMOVE,\r\n    TOUCHEND,\r\n    MOUSEOVER,\r\n    WHEEL,\r\n    CONTEXTMENU,\r\n    POINTERDOWN,\r\n    POINTERMOVE,\r\n    POINTERUP,\r\n    POINTERCANCEL,\r\n    LOSTPOINTERCAPTURE\r\n], \r\n// cached variables\r\neventsLength = EVENTS.length;\r\nfunction addEvent(ctx, eventName) {\r\n    ctx.content.addEventListener(eventName, function (evt) {\r\n        ctx[UNDERSCORE + eventName](evt);\r\n    }, false);\r\n}\r\nvar NO_POINTERS_MESSAGE = \"Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);\";\r\nexport var stages = [];\r\nfunction checkNoClip(attrs) {\r\n    if (attrs === void 0) { attrs = {}; }\r\n    if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {\r\n        Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');\r\n    }\r\n    return attrs;\r\n}\r\n/**\r\n * Stage constructor.  A stage is used to contain multiple layers\r\n * @constructor\r\n * @memberof Konva\r\n * @augments Konva.Container\r\n * @param {Object} config\r\n * @param {String|Element} config.container Container selector or DOM element\r\n * @@nodeParams\r\n * @example\r\n * var stage = new Konva.Stage({\r\n *   width: 500,\r\n *   height: 800,\r\n *   container: 'containerId' // or \"#containerId\" or \".containerClass\"\r\n * });\r\n */\r\nvar Stage = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Stage, _super);\r\n    function Stage(config) {\r\n        var _this = _super.call(this, checkNoClip(config)) || this;\r\n        _this._buildDOM();\r\n        _this._bindContentEvents();\r\n        stages.push(_this);\r\n        _this.on('widthChange.konva heightChange.konva', _this._resizeDOM);\r\n        _this.on('visibleChange.konva', _this._checkVisibility);\r\n        _this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', function () {\r\n            checkNoClip(_this.attrs);\r\n        });\r\n        _this._checkVisibility();\r\n        return _this;\r\n    }\r\n    Stage.prototype._validateAdd = function (child) {\r\n        var isLayer = child.getType() === 'Layer';\r\n        var isFastLayer = child.getType() === 'FastLayer';\r\n        var valid = isLayer || isFastLayer;\r\n        if (!valid) {\r\n            Util.throw('You may only add layers to the stage.');\r\n        }\r\n    };\r\n    Stage.prototype._checkVisibility = function () {\r\n        var style = this.visible() ? '' : 'none';\r\n        this.content.style.display = style;\r\n    };\r\n    /**\r\n     * set container dom element which contains the stage wrapper div element\r\n     * @method\r\n     * @name Konva.Stage#setContainer\r\n     * @param {DomElement} container can pass in a dom element or id string\r\n     */\r\n    Stage.prototype.setContainer = function (container) {\r\n        if (typeof container === STRING) {\r\n            if (container.charAt(0) === '.') {\r\n                var className = container.slice(1);\r\n                container = document.getElementsByClassName(className)[0];\r\n            }\r\n            else {\r\n                var id;\r\n                if (container.charAt(0) !== '#') {\r\n                    id = container;\r\n                }\r\n                else {\r\n                    id = container.slice(1);\r\n                }\r\n                container = document.getElementById(id);\r\n            }\r\n            if (!container) {\r\n                throw 'Can not find container in document with id ' + id;\r\n            }\r\n        }\r\n        this._setAttr(CONTAINER, container);\r\n        if (this.content) {\r\n            if (this.content.parentElement) {\r\n                this.content.parentElement.removeChild(this.content);\r\n            }\r\n            container.appendChild(this.content);\r\n        }\r\n        return this;\r\n    };\r\n    Stage.prototype.shouldDrawHit = function () {\r\n        return true;\r\n    };\r\n    /**\r\n     * clear all layers\r\n     * @method\r\n     * @name Konva.Stage#clear\r\n     */\r\n    Stage.prototype.clear = function () {\r\n        var layers = this.children, len = layers.length, n;\r\n        for (n = 0; n < len; n++) {\r\n            layers[n].clear();\r\n        }\r\n        return this;\r\n    };\r\n    Stage.prototype.clone = function (obj) {\r\n        if (!obj) {\r\n            obj = {};\r\n        }\r\n        obj.container = document.createElement('div');\r\n        return Container.prototype.clone.call(this, obj);\r\n    };\r\n    Stage.prototype.destroy = function () {\r\n        _super.prototype.destroy.call(this);\r\n        var content = this.content;\r\n        if (content && Util._isInDocument(content)) {\r\n            this.container().removeChild(content);\r\n        }\r\n        var index = stages.indexOf(this);\r\n        if (index > -1) {\r\n            stages.splice(index, 1);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * get pointer position which can be a touch position or mouse position\r\n     * @method\r\n     * @name Konva.Stage#getPointerPosition\r\n     * @returns {Object}\r\n     */\r\n    Stage.prototype.getPointerPosition = function () {\r\n        if (!this.pointerPos) {\r\n            Util.warn(NO_POINTERS_MESSAGE);\r\n        }\r\n        return this.pointerPos;\r\n    };\r\n    Stage.prototype.getStage = function () {\r\n        return this;\r\n    };\r\n    Stage.prototype.getContent = function () {\r\n        return this.content;\r\n    };\r\n    Stage.prototype._toKonvaCanvas = function (config) {\r\n        config = config || {};\r\n        var x = config.x || 0, y = config.y || 0, canvas = new SceneCanvas({\r\n            width: config.width || this.width(),\r\n            height: config.height || this.height(),\r\n            pixelRatio: config.pixelRatio || 1\r\n        }), _context = canvas.getContext()._context, layers = this.children;\r\n        if (x || y) {\r\n            _context.translate(-1 * x, -1 * y);\r\n        }\r\n        layers.each(function (layer) {\r\n            if (!layer.isVisible()) {\r\n                return;\r\n            }\r\n            var layerCanvas = layer._toKonvaCanvas(config);\r\n            _context.drawImage(layerCanvas._canvas, x, y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());\r\n        });\r\n        return canvas;\r\n    };\r\n    /**\r\n     * get visible intersection shape. This is the preferred\r\n     *  method for determining if a point intersects a shape or not\r\n     * @method\r\n     * @name Konva.Stage#getIntersection\r\n     * @param {Object} pos\r\n     * @param {Number} pos.x\r\n     * @param {Number} pos.y\r\n     * @param {String} [selector]\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * var shape = stage.getIntersection({x: 50, y: 50});\r\n     * // or if you interested in shape parent:\r\n     * var group = stage.getIntersection({x: 50, y: 50}, 'Group');\r\n     */\r\n    Stage.prototype.getIntersection = function (pos, selector) {\r\n        var layers = this.children, len = layers.length, end = len - 1, n, shape;\r\n        for (n = end; n >= 0; n--) {\r\n            shape = layers[n].getIntersection(pos, selector);\r\n            if (shape) {\r\n                return shape;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    Stage.prototype._resizeDOM = function () {\r\n        if (this.content) {\r\n            var width = this.width(), height = this.height(), layers = this.getChildren(), len = layers.length, n, layer;\r\n            // set content dimensions\r\n            this.content.style.width = width + PX;\r\n            this.content.style.height = height + PX;\r\n            this.bufferCanvas.setSize(width, height);\r\n            this.bufferHitCanvas.setSize(width, height);\r\n            // set layer dimensions\r\n            for (n = 0; n < len; n++) {\r\n                layer = layers[n];\r\n                layer.setSize({ width: width, height: height });\r\n                layer.draw();\r\n            }\r\n        }\r\n    };\r\n    Stage.prototype.add = function (layer) {\r\n        if (arguments.length > 1) {\r\n            for (var i = 0; i < arguments.length; i++) {\r\n                this.add(arguments[i]);\r\n            }\r\n            return this;\r\n        }\r\n        _super.prototype.add.call(this, layer);\r\n        var length = this.children.length;\r\n        if (length > MAX_LAYERS_NUMBER) {\r\n            Util.warn('The stage has ' +\r\n                length +\r\n                ' layers. Recommended maximin number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');\r\n        }\r\n        layer._setCanvasSize(this.width(), this.height());\r\n        // draw layer and append canvas to container\r\n        layer.draw();\r\n        if (Konva.isBrowser) {\r\n            this.content.appendChild(layer.canvas._canvas);\r\n        }\r\n        // chainable\r\n        return this;\r\n    };\r\n    Stage.prototype.getParent = function () {\r\n        return null;\r\n    };\r\n    Stage.prototype.getLayer = function () {\r\n        return null;\r\n    };\r\n    Stage.prototype.hasPointerCapture = function (pointerId) {\r\n        return PointerEvents.hasPointerCapture(pointerId, this);\r\n    };\r\n    Stage.prototype.setPointerCapture = function (pointerId) {\r\n        PointerEvents.setPointerCapture(pointerId, this);\r\n    };\r\n    Stage.prototype.releaseCapture = function (pointerId) {\r\n        PointerEvents.releaseCapture(pointerId, this);\r\n    };\r\n    /**\r\n     * returns a {@link Konva.Collection} of layers\r\n     * @method\r\n     * @name Konva.Stage#getLayers\r\n     */\r\n    Stage.prototype.getLayers = function () {\r\n        return this.getChildren();\r\n    };\r\n    Stage.prototype._bindContentEvents = function () {\r\n        if (!Konva.isBrowser) {\r\n            return;\r\n        }\r\n        for (var n = 0; n < eventsLength; n++) {\r\n            addEvent(this, EVENTS[n]);\r\n        }\r\n    };\r\n    Stage.prototype._mouseenter = function (evt) {\r\n        this.setPointersPositions(evt);\r\n        this._fire(MOUSEENTER, { evt: evt, target: this, currentTarget: this });\r\n    };\r\n    Stage.prototype._mouseover = function (evt) {\r\n        this.setPointersPositions(evt);\r\n        this._fire(CONTENT_MOUSEOVER, { evt: evt });\r\n        this._fire(MOUSEOVER, { evt: evt, target: this, currentTarget: this });\r\n    };\r\n    Stage.prototype._mouseout = function (evt) {\r\n        this.setPointersPositions(evt);\r\n        var targetShape = this.targetShape;\r\n        if (targetShape && !DD.isDragging) {\r\n            targetShape._fireAndBubble(MOUSEOUT, { evt: evt });\r\n            targetShape._fireAndBubble(MOUSELEAVE, { evt: evt });\r\n            this.targetShape = null;\r\n        }\r\n        else if (!DD.isDragging) {\r\n            this._fire(MOUSELEAVE, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this\r\n            });\r\n            this._fire(MOUSEOUT, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this\r\n            });\r\n        }\r\n        this.pointerPos = undefined;\r\n        this._fire(CONTENT_MOUSEOUT, { evt: evt });\r\n    };\r\n    Stage.prototype._mousemove = function (evt) {\r\n        // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event\r\n        if (Konva.UA.ieMobile) {\r\n            return this._touchmove(evt);\r\n        }\r\n        this.setPointersPositions(evt);\r\n        var shape;\r\n        if (!DD.isDragging) {\r\n            shape = this.getIntersection(this.getPointerPosition());\r\n            if (shape && shape.isListening()) {\r\n                var differentTarget = !this.targetShape || this.targetShape !== shape;\r\n                if (!DD.isDragging && differentTarget) {\r\n                    if (this.targetShape) {\r\n                        this.targetShape._fireAndBubble(MOUSEOUT, { evt: evt }, shape);\r\n                        this.targetShape._fireAndBubble(MOUSELEAVE, { evt: evt }, shape);\r\n                    }\r\n                    shape._fireAndBubble(MOUSEOVER, { evt: evt }, this.targetShape);\r\n                    shape._fireAndBubble(MOUSEENTER, { evt: evt }, this.targetShape);\r\n                    this.targetShape = shape;\r\n                }\r\n                else {\r\n                    shape._fireAndBubble(MOUSEMOVE, { evt: evt });\r\n                }\r\n            }\r\n            else {\r\n                /*\r\n                 * if no shape was detected, clear target shape and try\r\n                 * to run mouseout from previous target shape\r\n                 */\r\n                if (this.targetShape && !DD.isDragging) {\r\n                    this.targetShape._fireAndBubble(MOUSEOUT, { evt: evt });\r\n                    this.targetShape._fireAndBubble(MOUSELEAVE, { evt: evt });\r\n                    this._fire(MOUSEOVER, {\r\n                        evt: evt,\r\n                        target: this,\r\n                        currentTarget: this\r\n                    });\r\n                    this.targetShape = null;\r\n                }\r\n                this._fire(MOUSEMOVE, {\r\n                    evt: evt,\r\n                    target: this,\r\n                    currentTarget: this\r\n                });\r\n            }\r\n            // content event\r\n            this._fire(CONTENT_MOUSEMOVE, { evt: evt });\r\n        }\r\n        // always call preventDefault for desktop events because some browsers\r\n        // try to drag and drop the canvas element\r\n        if (evt.cancelable) {\r\n            evt.preventDefault();\r\n        }\r\n    };\r\n    Stage.prototype._mousedown = function (evt) {\r\n        // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event\r\n        if (Konva.UA.ieMobile) {\r\n            return this._touchstart(evt);\r\n        }\r\n        this.setPointersPositions(evt);\r\n        var shape = this.getIntersection(this.getPointerPosition());\r\n        Konva.listenClickTap = true;\r\n        if (shape && shape.isListening()) {\r\n            this.clickStartShape = shape;\r\n            shape._fireAndBubble(MOUSEDOWN, { evt: evt });\r\n        }\r\n        else {\r\n            this._fire(MOUSEDOWN, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this\r\n            });\r\n        }\r\n        // content event\r\n        this._fire(CONTENT_MOUSEDOWN, { evt: evt });\r\n        // Do not prevent default behavior, because it will prevent listening events outside of window iframe\r\n        // we used preventDefault for disabling native drag&drop\r\n        // but userSelect = none style will do the trick\r\n        // if (evt.cancelable) {\r\n        //   evt.preventDefault();\r\n        // }\r\n    };\r\n    Stage.prototype._mouseup = function (evt) {\r\n        // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event\r\n        if (Konva.UA.ieMobile) {\r\n            return this._touchend(evt);\r\n        }\r\n        this.setPointersPositions(evt);\r\n        var shape = this.getIntersection(this.getPointerPosition()), clickStartShape = this.clickStartShape, clickEndShape = this.clickEndShape, fireDblClick = false;\r\n        if (Konva.inDblClickWindow) {\r\n            fireDblClick = true;\r\n            clearTimeout(this.dblTimeout);\r\n            // Konva.inDblClickWindow = false;\r\n        }\r\n        else if (!DD.justDragged) {\r\n            // don't set inDblClickWindow after dragging\r\n            Konva.inDblClickWindow = true;\r\n            clearTimeout(this.dblTimeout);\r\n        }\r\n        else if (DD) {\r\n            DD.justDragged = false;\r\n        }\r\n        this.dblTimeout = setTimeout(function () {\r\n            Konva.inDblClickWindow = false;\r\n        }, Konva.dblClickWindow);\r\n        if (shape && shape.isListening()) {\r\n            this.clickEndShape = shape;\r\n            shape._fireAndBubble(MOUSEUP, { evt: evt });\r\n            // detect if click or double click occurred\r\n            if (Konva.listenClickTap &&\r\n                clickStartShape &&\r\n                clickStartShape._id === shape._id) {\r\n                shape._fireAndBubble(CLICK, { evt: evt });\r\n                if (fireDblClick && clickEndShape && clickEndShape._id === shape._id) {\r\n                    shape._fireAndBubble(DBL_CLICK, { evt: evt });\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this._fire(MOUSEUP, { evt: evt, target: this, currentTarget: this });\r\n            if (Konva.listenClickTap) {\r\n                this._fire(CLICK, { evt: evt, target: this, currentTarget: this });\r\n            }\r\n            if (fireDblClick) {\r\n                this._fire(DBL_CLICK, {\r\n                    evt: evt,\r\n                    target: this,\r\n                    currentTarget: this\r\n                });\r\n            }\r\n        }\r\n        // content events\r\n        this._fire(CONTENT_MOUSEUP, { evt: evt });\r\n        if (Konva.listenClickTap) {\r\n            this._fire(CONTENT_CLICK, { evt: evt });\r\n            if (fireDblClick) {\r\n                this._fire(CONTENT_DBL_CLICK, { evt: evt });\r\n            }\r\n        }\r\n        Konva.listenClickTap = false;\r\n        // always call preventDefault for desktop events because some browsers\r\n        // try to drag and drop the canvas element\r\n        if (evt.cancelable) {\r\n            evt.preventDefault();\r\n        }\r\n    };\r\n    Stage.prototype._contextmenu = function (evt) {\r\n        this.setPointersPositions(evt);\r\n        var shape = this.getIntersection(this.getPointerPosition());\r\n        if (shape && shape.isListening()) {\r\n            shape._fireAndBubble(CONTEXTMENU, { evt: evt });\r\n        }\r\n        else {\r\n            this._fire(CONTEXTMENU, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this\r\n            });\r\n        }\r\n        this._fire(CONTENT_CONTEXTMENU, { evt: evt });\r\n    };\r\n    Stage.prototype._touchstart = function (evt) {\r\n        this.setPointersPositions(evt);\r\n        var shape = this.getIntersection(this.getPointerPosition());\r\n        Konva.listenClickTap = true;\r\n        if (shape && shape.isListening()) {\r\n            this.tapStartShape = shape;\r\n            shape._fireAndBubble(TOUCHSTART, { evt: evt });\r\n            // only call preventDefault if the shape is listening for events\r\n            if (shape.isListening() && shape.preventDefault() && evt.cancelable) {\r\n                evt.preventDefault();\r\n            }\r\n        }\r\n        else {\r\n            this._fire(TOUCHSTART, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this\r\n            });\r\n        }\r\n        // content event\r\n        this._fire(CONTENT_TOUCHSTART, { evt: evt });\r\n    };\r\n    Stage.prototype._touchend = function (evt) {\r\n        this.setPointersPositions(evt);\r\n        var shape = this.getIntersection(this.getPointerPosition()), fireDblClick = false;\r\n        if (Konva.inDblClickWindow) {\r\n            fireDblClick = true;\r\n            clearTimeout(this.dblTimeout);\r\n            // Konva.inDblClickWindow = false;\r\n        }\r\n        else {\r\n            Konva.inDblClickWindow = true;\r\n            clearTimeout(this.dblTimeout);\r\n        }\r\n        this.dblTimeout = setTimeout(function () {\r\n            Konva.inDblClickWindow = false;\r\n        }, Konva.dblClickWindow);\r\n        if (shape && shape.isListening()) {\r\n            shape._fireAndBubble(TOUCHEND, { evt: evt });\r\n            // detect if tap or double tap occurred\r\n            if (Konva.listenClickTap &&\r\n                this.tapStartShape &&\r\n                shape._id === this.tapStartShape._id) {\r\n                shape._fireAndBubble(TAP, { evt: evt });\r\n                if (fireDblClick) {\r\n                    shape._fireAndBubble(DBL_TAP, { evt: evt });\r\n                }\r\n            }\r\n            // only call preventDefault if the shape is listening for events\r\n            if (shape.isListening() && shape.preventDefault() && evt.cancelable) {\r\n                evt.preventDefault();\r\n            }\r\n        }\r\n        else {\r\n            this._fire(TOUCHEND, { evt: evt, target: this, currentTarget: this });\r\n            if (Konva.listenClickTap) {\r\n                this._fire(TAP, { evt: evt, target: this, currentTarget: this });\r\n            }\r\n            if (fireDblClick) {\r\n                this._fire(DBL_TAP, {\r\n                    evt: evt,\r\n                    target: this,\r\n                    currentTarget: this\r\n                });\r\n            }\r\n        }\r\n        // content events\r\n        this._fire(CONTENT_TOUCHEND, { evt: evt });\r\n        if (Konva.listenClickTap) {\r\n            this._fire(CONTENT_TAP, { evt: evt });\r\n            if (fireDblClick) {\r\n                this._fire(CONTENT_DBL_TAP, { evt: evt });\r\n            }\r\n        }\r\n        Konva.listenClickTap = false;\r\n    };\r\n    Stage.prototype._touchmove = function (evt) {\r\n        this.setPointersPositions(evt);\r\n        var shape;\r\n        if (!DD.isDragging) {\r\n            shape = this.getIntersection(this.getPointerPosition());\r\n            if (shape && shape.isListening()) {\r\n                shape._fireAndBubble(TOUCHMOVE, { evt: evt });\r\n                // only call preventDefault if the shape is listening for events\r\n                if (shape.isListening() && shape.preventDefault() && evt.cancelable) {\r\n                    evt.preventDefault();\r\n                }\r\n            }\r\n            else {\r\n                this._fire(TOUCHMOVE, {\r\n                    evt: evt,\r\n                    target: this,\r\n                    currentTarget: this\r\n                });\r\n            }\r\n            this._fire(CONTENT_TOUCHMOVE, { evt: evt });\r\n        }\r\n        if (DD.isDragging && DD.node.preventDefault() && evt.cancelable) {\r\n            evt.preventDefault();\r\n        }\r\n    };\r\n    Stage.prototype._wheel = function (evt) {\r\n        this.setPointersPositions(evt);\r\n        var shape = this.getIntersection(this.getPointerPosition());\r\n        if (shape && shape.isListening()) {\r\n            shape._fireAndBubble(WHEEL, { evt: evt });\r\n        }\r\n        else {\r\n            this._fire(WHEEL, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this\r\n            });\r\n        }\r\n        this._fire(CONTENT_WHEEL, { evt: evt });\r\n    };\r\n    Stage.prototype._pointerdown = function (evt) {\r\n        if (!Konva._pointerEventsEnabled) {\r\n            return;\r\n        }\r\n        this.setPointersPositions(evt);\r\n        var shape = PointerEvents.getCapturedShape(evt.pointerId) ||\r\n            this.getIntersection(this.getPointerPosition());\r\n        if (shape) {\r\n            shape._fireAndBubble(POINTERDOWN, PointerEvents.createEvent(evt));\r\n        }\r\n    };\r\n    Stage.prototype._pointermove = function (evt) {\r\n        if (!Konva._pointerEventsEnabled) {\r\n            return;\r\n        }\r\n        this.setPointersPositions(evt);\r\n        var shape = PointerEvents.getCapturedShape(evt.pointerId) ||\r\n            this.getIntersection(this.getPointerPosition());\r\n        if (shape) {\r\n            shape._fireAndBubble(POINTERMOVE, PointerEvents.createEvent(evt));\r\n        }\r\n    };\r\n    Stage.prototype._pointerup = function (evt) {\r\n        if (!Konva._pointerEventsEnabled) {\r\n            return;\r\n        }\r\n        this.setPointersPositions(evt);\r\n        var shape = PointerEvents.getCapturedShape(evt.pointerId) ||\r\n            this.getIntersection(this.getPointerPosition());\r\n        if (shape) {\r\n            shape._fireAndBubble(POINTERUP, PointerEvents.createEvent(evt));\r\n        }\r\n        PointerEvents.releaseCapture(evt.pointerId);\r\n    };\r\n    Stage.prototype._pointercancel = function (evt) {\r\n        if (!Konva._pointerEventsEnabled) {\r\n            return;\r\n        }\r\n        this.setPointersPositions(evt);\r\n        var shape = PointerEvents.getCapturedShape(evt.pointerId) ||\r\n            this.getIntersection(this.getPointerPosition());\r\n        if (shape) {\r\n            shape._fireAndBubble(POINTERUP, PointerEvents.createEvent(evt));\r\n        }\r\n        PointerEvents.releaseCapture(evt.pointerId);\r\n    };\r\n    Stage.prototype._lostpointercapture = function (evt) {\r\n        PointerEvents.releaseCapture(evt.pointerId);\r\n    };\r\n    /**\r\n     * manually register pointers positions (mouse/touch) in the stage.\r\n     * So you can use stage.getPointerPosition(). Usually you don't need to use that method\r\n     * because all internal events are automatically registered. It may be useful if event\r\n     * is triggered outside of the stage, but you still want to use Konva methods to get pointers position.\r\n     * @method\r\n     * @name Konva.Stage#setPointersPositions\r\n     * @param {Object} event Event object\r\n     * @example\r\n     *\r\n     * window.addEventListener('mousemove', (e) => {\r\n     *   stage.setPointersPositions(e);\r\n     * });\r\n     */\r\n    Stage.prototype.setPointersPositions = function (evt) {\r\n        var contentPosition = this._getContentPosition(), x = null, y = null;\r\n        evt = evt ? evt : window.event;\r\n        // touch events\r\n        if (evt.touches !== undefined) {\r\n            // currently, only handle one finger\r\n            if (evt.touches.length > 0) {\r\n                var touch = evt.touches[0];\r\n                // get the information for finger #1\r\n                x = touch.clientX - contentPosition.left;\r\n                y = touch.clientY - contentPosition.top;\r\n            }\r\n        }\r\n        else {\r\n            // mouse events\r\n            x = evt.clientX - contentPosition.left;\r\n            y = evt.clientY - contentPosition.top;\r\n        }\r\n        if (x !== null && y !== null) {\r\n            this.pointerPos = {\r\n                x: x,\r\n                y: y\r\n            };\r\n        }\r\n    };\r\n    Stage.prototype._setPointerPosition = function (evt) {\r\n        Util.warn('Method _setPointerPosition is deprecated. Use \"stage.setPointersPositions(event)\" instead.');\r\n        this.setPointersPositions(evt);\r\n    };\r\n    Stage.prototype._getContentPosition = function () {\r\n        var rect = this.content.getBoundingClientRect\r\n            ? this.content.getBoundingClientRect()\r\n            : { top: 0, left: 0 };\r\n        return {\r\n            top: rect.top,\r\n            left: rect.left\r\n        };\r\n    };\r\n    Stage.prototype._buildDOM = function () {\r\n        // the buffer canvas pixel ratio must be 1 because it is used as an\r\n        // intermediate canvas before copying the result onto a scene canvas.\r\n        // not setting it to 1 will result in an over compensation\r\n        this.bufferCanvas = new SceneCanvas();\r\n        this.bufferHitCanvas = new HitCanvas({ pixelRatio: 1 });\r\n        if (!Konva.isBrowser) {\r\n            return;\r\n        }\r\n        var container = this.container();\r\n        if (!container) {\r\n            throw 'Stage has no container. A container is required.';\r\n        }\r\n        // clear content inside container\r\n        container.innerHTML = EMPTY_STRING;\r\n        // content\r\n        this.content = document.createElement('div');\r\n        this.content.style.position = RELATIVE;\r\n        this.content.style.userSelect = 'none';\r\n        this.content.className = KONVA_CONTENT;\r\n        this.content.setAttribute('role', 'presentation');\r\n        container.appendChild(this.content);\r\n        this._resizeDOM();\r\n    };\r\n    // currently cache function is now working for stage, because stage has no its own canvas element\r\n    Stage.prototype.cache = function () {\r\n        Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');\r\n        return this;\r\n    };\r\n    Stage.prototype.clearCache = function () {\r\n        return this;\r\n    };\r\n    /**\r\n     * batch draw\r\n     * @method\r\n     * @name Konva.BaseLayer#batchDraw\r\n     * @return {Konva.Stage} this\r\n     */\r\n    Stage.prototype.batchDraw = function () {\r\n        this.children.each(function (layer) {\r\n            layer.batchDraw();\r\n        });\r\n        return this;\r\n    };\r\n    return Stage;\r\n}(Container));\r\nexport { Stage };\r\nStage.prototype.nodeType = STAGE;\r\n_registerNode(Stage);\r\n/**\r\n * get/set container DOM element\r\n * @method\r\n * @name Konva.Stage#container\r\n * @returns {DomElement} container\r\n * @example\r\n * // get container\r\n * var container = stage.container();\r\n * // set container\r\n * var container = document.createElement('div');\r\n * body.appendChild(container);\r\n * stage.container(container);\r\n */\r\nFactory.addGetterSetter(Stage, 'container');\r\n"}
