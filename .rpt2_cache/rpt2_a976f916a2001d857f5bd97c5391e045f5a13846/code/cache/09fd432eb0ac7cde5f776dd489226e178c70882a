{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Container } from './Container';\r\nimport { Util, Collection } from './Util';\r\nimport { _registerNode } from './Global';\r\nimport { Factory } from './Factory';\r\n/**\r\n * AbstractGroup constructor.  AbstractGroup are used to contain shapes or other groups and doesn't draw them.\r\n * @constructor\r\n * @memberof Konva\r\n * @augments Konva.Container\r\n * @param {Object} config\r\n * @@nodeParams\r\n * @@containerParams\r\n * @example\r\n * var group = new Konva.AbstractGroup();\r\n */\r\nvar AbstractGroup = /** @class */ (function (_super) {\r\n    tslib_1.__extends(AbstractGroup, _super);\r\n    function AbstractGroup(config) {\r\n        var _this = _super.call(this, config) || this;\r\n        _this.linksChildren = new Collection();\r\n        _this.visible(false);\r\n        return _this;\r\n    }\r\n    AbstractGroup.prototype._validateAdd = function (child) {\r\n        var type = child.getType();\r\n        if (type !== 'Group' && type !== 'Shape') {\r\n            Util.throw('You may only add groups and shapes to groups.');\r\n        }\r\n    };\r\n    /**\r\n     * add a child and children into AbstractGroup\r\n     * @name Konva.AbstractGroup#add\r\n     * @method\r\n     * @param {...Konva.Node} child\r\n     * @returns {AbstractGroup}\r\n     * @example\r\n     * layer.add(rect);\r\n     * layer.add(shape1, shape2, shape3);\r\n     * // remember to redraw layer if you changed something\r\n     * layer.draw();\r\n     */\r\n    AbstractGroup.prototype.add = function (child) {\r\n        if (arguments.length > 1) {\r\n            for (var i = 0; i < arguments.length; i++) {\r\n                this.add(arguments[i]);\r\n            }\r\n            return this;\r\n        }\r\n        var ch = child.clone();\r\n        if (ch.getParent()) {\r\n            ch.moveTo(this);\r\n            return this;\r\n        }\r\n        var children = this.children;\r\n        this._validateAdd(ch);\r\n        ch.index = children.length;\r\n        ch.parent = this;\r\n        child.abstractParent = this;\r\n        children.push(ch);\r\n        this.linksChildren.push(child);\r\n        this._fire('add', {\r\n            child: ch\r\n        });\r\n        // chainable\r\n        return this;\r\n    };\r\n    /**\r\n     * remove all children and links\r\n     * @method\r\n     * @name Konva.AbstractGroup#removeChildren\r\n     */\r\n    AbstractGroup.prototype.removeChildren = function () {\r\n        _super.prototype.removeChildren.call(this);\r\n        var child;\r\n        for (var i = 0; i < this.linksChildren.length; i++) {\r\n            child = this.linksChildren[i];\r\n            // reset parent to prevent many _setChildrenIndices calls\r\n            child.abstractParent = null;\r\n        }\r\n        this.linksChildren = new Collection();\r\n        return this;\r\n    };\r\n    AbstractGroup.prototype.drawScene = function () {\r\n        var self = this;\r\n        this.children.each(function (item, i) {\r\n            var at = item.getAbsoluteTransform().copy();\r\n            var dec = Util._decompose2dMatrix(at.m);\r\n            var r = dec.rotation * 180 / Math.PI;\r\n            var c = self.linksChildren[i];\r\n            c.x(dec.translation[0]);\r\n            c.y(dec.translation[1]);\r\n            c.width(item.width() * dec.scale[0]);\r\n            c.height(item.height() * dec.scale[1]);\r\n            c.rotation(r);\r\n        });\r\n        return this;\r\n    };\r\n    AbstractGroup.prototype.drawHit = function () {\r\n        return this;\r\n    };\r\n    return AbstractGroup;\r\n}(Container));\r\nexport { AbstractGroup };\r\nAbstractGroup.prototype.nodeType = 'AbstractGroup';\r\n_registerNode(AbstractGroup);\r\nFactory.addGetterSetter(AbstractGroup, 'visible', false);\r\nCollection.mapMethods(AbstractGroup);\r\n"}
