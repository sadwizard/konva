{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Collection } from '../Util';\r\nimport { Factory } from '../Factory';\r\nimport { Line } from './Line';\r\nimport { getNumberValidator } from '../Validators';\r\nimport { _registerNode } from '../Global';\r\n/**\r\n * Arrow constructor\r\n * @constructor\r\n * @memberof Konva\r\n * @augments Konva.Shape\r\n * @param {Object} config\r\n * @param {Array} config.points Flat array of points coordinates. You should define them as [x1, y1, x2, y2, x3, y3].\r\n * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.\r\n *   The default is 0\r\n * @param {Number} config.pointerLength Arrow pointer length. Default value is 10.\r\n * @param {Number} config.pointerWidth Arrow pointer width. Default value is 10.\r\n * @param {Boolean} config.pointerAtBeginning Do we need to draw pointer on both sides?. Default false.\r\n * @@shapeParams\r\n * @@nodeParams\r\n * @example\r\n * var line = new Konva.Line({\r\n *   points: [73, 70, 340, 23, 450, 60, 500, 20],\r\n *   stroke: 'red',\r\n *   tension: 1,\r\n *   pointerLength : 10,\r\n *   pointerWidth : 12\r\n * });\r\n */\r\nvar Arrow = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Arrow, _super);\r\n    function Arrow() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Arrow.prototype._sceneFunc = function (ctx) {\r\n        _super.prototype._sceneFunc.call(this, ctx);\r\n        var PI2 = Math.PI * 2;\r\n        var points = this.points();\r\n        var tp = points;\r\n        var fromTension = this.tension() !== 0 && points.length > 4;\r\n        if (fromTension) {\r\n            tp = this.getTensionPoints();\r\n        }\r\n        var n = points.length;\r\n        var dx, dy;\r\n        if (fromTension) {\r\n            dx = points[n - 2] - tp[n - 2];\r\n            dy = points[n - 1] - tp[n - 1];\r\n        }\r\n        else {\r\n            dx = points[n - 2] - points[n - 4];\r\n            dy = points[n - 1] - points[n - 3];\r\n        }\r\n        var radians = (Math.atan2(dy, dx) + PI2) % PI2;\r\n        var length = this.pointerLength();\r\n        var width = this.pointerWidth();\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.translate(points[n - 2], points[n - 1]);\r\n        ctx.rotate(radians);\r\n        ctx.moveTo(0, 0);\r\n        ctx.lineTo(-length, width / 2);\r\n        ctx.lineTo(-length, -width / 2);\r\n        ctx.closePath();\r\n        ctx.restore();\r\n        if (this.pointerAtBeginning()) {\r\n            ctx.save();\r\n            ctx.translate(points[0], points[1]);\r\n            if (fromTension) {\r\n                dx = tp[0] - points[0];\r\n                dy = tp[1] - points[1];\r\n            }\r\n            else {\r\n                dx = points[2] - points[0];\r\n                dy = points[3] - points[1];\r\n            }\r\n            ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);\r\n            ctx.moveTo(0, 0);\r\n            ctx.lineTo(-length, width / 2);\r\n            ctx.lineTo(-length, -width / 2);\r\n            ctx.closePath();\r\n            ctx.restore();\r\n        }\r\n        // here is a tricky part\r\n        // we need to disable dash for arrow pointers\r\n        var isDashEnabled = this.dashEnabled();\r\n        if (isDashEnabled) {\r\n            // manually disable dash for head\r\n            // it is better not to use setter here,\r\n            // because it will trigger attr change event\r\n            this.attrs.dashEnabled = false;\r\n            ctx.setLineDash([]);\r\n        }\r\n        ctx.fillStrokeShape(this);\r\n        // restore old value\r\n        if (isDashEnabled) {\r\n            this.attrs.dashEnabled = true;\r\n        }\r\n    };\r\n    return Arrow;\r\n}(Line));\r\nexport { Arrow };\r\nArrow.prototype.className = 'Arrow';\r\n_registerNode(Arrow);\r\n/**\r\n * get/set pointerLength\r\n * @name Konva.Arrow#pointerLength\r\n * @method\r\n * @param {Number} Length of pointer of arrow. The default is 10.\r\n * @returns {Number}\r\n * @example\r\n * // get length\r\n * var pointerLength = line.pointerLength();\r\n *\r\n * // set length\r\n * line.pointerLength(15);\r\n */\r\nFactory.addGetterSetter(Arrow, 'pointerLength', 10, getNumberValidator());\r\n/**\r\n * get/set pointerWidth\r\n * @name Konva.Arrow#pointerWidth\r\n * @method\r\n * @param {Number} Width of pointer of arrow.\r\n *   The default is 10.\r\n * @returns {Number}\r\n * @example\r\n * // get width\r\n * var pointerWidth = line.pointerWidth();\r\n *\r\n * // set width\r\n * line.pointerWidth(15);\r\n */\r\nFactory.addGetterSetter(Arrow, 'pointerWidth', 10, getNumberValidator());\r\n/**\r\n * get/set pointerAtBeginning\r\n * @name Konva.Arrow#pointerAtBeginning\r\n * @method\r\n * @param {Number} Should pointer displayed at beginning of arrow. The default is false.\r\n * @returns {Boolean}\r\n * @example\r\n * // get value\r\n * var pointerAtBeginning = line.pointerAtBeginning();\r\n *\r\n * // set value\r\n * line.pointerAtBeginning(true);\r\n */\r\nFactory.addGetterSetter(Arrow, 'pointerAtBeginning', false);\r\nCollection.mapMethods(Arrow);\r\n"}
