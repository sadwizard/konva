{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Collection } from '../Util';\r\nimport { Factory } from '../Factory';\r\nimport { Shape } from '../Shape';\r\nimport { _registerNode } from '../Global';\r\n/**\r\n * Path constructor.\r\n * @author Jason Follas\r\n * @constructor\r\n * @memberof Konva\r\n * @augments Konva.Shape\r\n * @param {Object} config\r\n * @param {String} config.data SVG data string\r\n * @@shapeParams\r\n * @@nodeParams\r\n * @example\r\n * var path = new Konva.Path({\r\n *   x: 240,\r\n *   y: 40,\r\n *   data: 'M12.582,9.551C3.251,16.237,0.921,29.021,7.08,38.564l-2.36,1.689l4.893,2.262l4.893,2.262l-0.568-5.36l-0.567-5.359l-2.365,1.694c-4.657-7.375-2.83-17.185,4.352-22.33c7.451-5.338,17.817-3.625,23.156,3.824c5.337,7.449,3.625,17.813-3.821,23.152l2.857,3.988c9.617-6.893,11.827-20.277,4.935-29.896C35.591,4.87,22.204,2.658,12.582,9.551z',\r\n *   fill: 'green',\r\n *   scaleX: 2,\r\n *   scaleY: 2\r\n * });\r\n */\r\nvar Path = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Path, _super);\r\n    function Path(config) {\r\n        var _this = _super.call(this, config) || this;\r\n        _this.dataArray = [];\r\n        _this.pathLength = 0;\r\n        _this.dataArray = Path.parsePathData(_this.data());\r\n        _this.pathLength = 0;\r\n        for (var i = 0; i < _this.dataArray.length; ++i) {\r\n            _this.pathLength += _this.dataArray[i].pathLength;\r\n        }\r\n        _this.on('dataChange.konva', function () {\r\n            this.dataArray = Path.parsePathData(this.data());\r\n            this.pathLength = 0;\r\n            for (var i = 0; i < this.dataArray.length; ++i) {\r\n                this.pathLength += this.dataArray[i].pathLength;\r\n            }\r\n        });\r\n        return _this;\r\n    }\r\n    Path.prototype._sceneFunc = function (context) {\r\n        var ca = this.dataArray;\r\n        // context position\r\n        context.beginPath();\r\n        for (var n = 0; n < ca.length; n++) {\r\n            var c = ca[n].command;\r\n            var p = ca[n].points;\r\n            switch (c) {\r\n                case 'L':\r\n                    context.lineTo(p[0], p[1]);\r\n                    break;\r\n                case 'M':\r\n                    context.moveTo(p[0], p[1]);\r\n                    break;\r\n                case 'C':\r\n                    context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);\r\n                    break;\r\n                case 'Q':\r\n                    context.quadraticCurveTo(p[0], p[1], p[2], p[3]);\r\n                    break;\r\n                case 'A':\r\n                    var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6], fs = p[7];\r\n                    var r = rx > ry ? rx : ry;\r\n                    var scaleX = rx > ry ? 1 : rx / ry;\r\n                    var scaleY = rx > ry ? ry / rx : 1;\r\n                    context.translate(cx, cy);\r\n                    context.rotate(psi);\r\n                    context.scale(scaleX, scaleY);\r\n                    context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);\r\n                    context.scale(1 / scaleX, 1 / scaleY);\r\n                    context.rotate(-psi);\r\n                    context.translate(-cx, -cy);\r\n                    break;\r\n                case 'z':\r\n                    context.closePath();\r\n                    break;\r\n            }\r\n        }\r\n        context.fillStrokeShape(this);\r\n    };\r\n    Path.prototype.getSelfRect = function () {\r\n        var points = [];\r\n        this.dataArray.forEach(function (data) {\r\n            points = points.concat(data.points);\r\n        });\r\n        var minX = points[0];\r\n        var maxX = points[0];\r\n        var minY = points[1];\r\n        var maxY = points[1];\r\n        var x, y;\r\n        for (var i = 0; i < points.length / 2; i++) {\r\n            x = points[i * 2];\r\n            y = points[i * 2 + 1];\r\n            // skip bad values\r\n            if (!isNaN(x)) {\r\n                minX = Math.min(minX, x);\r\n                maxX = Math.max(maxX, x);\r\n            }\r\n            if (!isNaN(y)) {\r\n                minY = Math.min(minY, y);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        return {\r\n            x: Math.round(minX),\r\n            y: Math.round(minY),\r\n            width: Math.round(maxX - minX),\r\n            height: Math.round(maxY - minY)\r\n        };\r\n    };\r\n    /**\r\n     * Return length of the path.\r\n     * @method\r\n     * @name Konva.Path#getLength\r\n     * @returns {Number} length\r\n     * @example\r\n     * var length = path.getLength();\r\n     */\r\n    Path.prototype.getLength = function () {\r\n        return this.pathLength;\r\n    };\r\n    /**\r\n     * Get point on path at specific length of the path\r\n     * @method\r\n     * @name Konva.Path#getPointAtLength\r\n     * @param {Number} length length\r\n     * @returns {Object} point {x,y} point\r\n     * @example\r\n     * var point = path.getPointAtLength(10);\r\n     */\r\n    Path.prototype.getPointAtLength = function (length) {\r\n        var point, i = 0, ii = this.dataArray.length;\r\n        if (!ii) {\r\n            return null;\r\n        }\r\n        while (i < ii && length > this.dataArray[i].pathLength) {\r\n            length -= this.dataArray[i].pathLength;\r\n            ++i;\r\n        }\r\n        if (i === ii) {\r\n            point = this.dataArray[i - 1].points.slice(-2);\r\n            return {\r\n                x: point[0],\r\n                y: point[1]\r\n            };\r\n        }\r\n        if (length < 0.01) {\r\n            point = this.dataArray[i].points.slice(0, 2);\r\n            return {\r\n                x: point[0],\r\n                y: point[1]\r\n            };\r\n        }\r\n        var cp = this.dataArray[i];\r\n        var p = cp.points;\r\n        switch (cp.command) {\r\n            case 'L':\r\n                return Path.getPointOnLine(length, cp.start.x, cp.start.y, p[0], p[1]);\r\n            case 'C':\r\n                return Path.getPointOnCubicBezier(length / cp.pathLength, cp.start.x, cp.start.y, p[0], p[1], p[2], p[3], p[4], p[5]);\r\n            case 'Q':\r\n                return Path.getPointOnQuadraticBezier(length / cp.pathLength, cp.start.x, cp.start.y, p[0], p[1], p[2], p[3]);\r\n            case 'A':\r\n                var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6];\r\n                theta += (dTheta * length) / cp.pathLength;\r\n                return Path.getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi);\r\n        }\r\n        return null;\r\n    };\r\n    Path.getLineLength = function (x1, y1, x2, y2) {\r\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\r\n    };\r\n    Path.getPointOnLine = function (dist, P1x, P1y, P2x, P2y, fromX, fromY) {\r\n        if (fromX === undefined) {\r\n            fromX = P1x;\r\n        }\r\n        if (fromY === undefined) {\r\n            fromY = P1y;\r\n        }\r\n        var m = (P2y - P1y) / (P2x - P1x + 0.00000001);\r\n        var run = Math.sqrt((dist * dist) / (1 + m * m));\r\n        if (P2x < P1x) {\r\n            run *= -1;\r\n        }\r\n        var rise = m * run;\r\n        var pt;\r\n        if (P2x === P1x) {\r\n            // vertical line\r\n            pt = {\r\n                x: fromX,\r\n                y: fromY + rise\r\n            };\r\n        }\r\n        else if ((fromY - P1y) / (fromX - P1x + 0.00000001) === m) {\r\n            pt = {\r\n                x: fromX + run,\r\n                y: fromY + rise\r\n            };\r\n        }\r\n        else {\r\n            var ix, iy;\r\n            var len = this.getLineLength(P1x, P1y, P2x, P2y);\r\n            if (len < 0.00000001) {\r\n                return undefined;\r\n            }\r\n            var u = (fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y);\r\n            u = u / (len * len);\r\n            ix = P1x + u * (P2x - P1x);\r\n            iy = P1y + u * (P2y - P1y);\r\n            var pRise = this.getLineLength(fromX, fromY, ix, iy);\r\n            var pRun = Math.sqrt(dist * dist - pRise * pRise);\r\n            run = Math.sqrt((pRun * pRun) / (1 + m * m));\r\n            if (P2x < P1x) {\r\n                run *= -1;\r\n            }\r\n            rise = m * run;\r\n            pt = {\r\n                x: ix + run,\r\n                y: iy + rise\r\n            };\r\n        }\r\n        return pt;\r\n    };\r\n    Path.getPointOnCubicBezier = function (pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {\r\n        function CB1(t) {\r\n            return t * t * t;\r\n        }\r\n        function CB2(t) {\r\n            return 3 * t * t * (1 - t);\r\n        }\r\n        function CB3(t) {\r\n            return 3 * t * (1 - t) * (1 - t);\r\n        }\r\n        function CB4(t) {\r\n            return (1 - t) * (1 - t) * (1 - t);\r\n        }\r\n        var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);\r\n        var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);\r\n        return {\r\n            x: x,\r\n            y: y\r\n        };\r\n    };\r\n    Path.getPointOnQuadraticBezier = function (pct, P1x, P1y, P2x, P2y, P3x, P3y) {\r\n        function QB1(t) {\r\n            return t * t;\r\n        }\r\n        function QB2(t) {\r\n            return 2 * t * (1 - t);\r\n        }\r\n        function QB3(t) {\r\n            return (1 - t) * (1 - t);\r\n        }\r\n        var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);\r\n        var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);\r\n        return {\r\n            x: x,\r\n            y: y\r\n        };\r\n    };\r\n    Path.getPointOnEllipticalArc = function (cx, cy, rx, ry, theta, psi) {\r\n        var cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);\r\n        var pt = {\r\n            x: rx * Math.cos(theta),\r\n            y: ry * Math.sin(theta)\r\n        };\r\n        return {\r\n            x: cx + (pt.x * cosPsi - pt.y * sinPsi),\r\n            y: cy + (pt.x * sinPsi + pt.y * cosPsi)\r\n        };\r\n    };\r\n    /*\r\n     * get parsed data array from the data\r\n     *  string.  V, v, H, h, and l data are converted to\r\n     *  L data for the purpose of high performance Path\r\n     *  rendering\r\n     */\r\n    Path.parsePathData = function (data) {\r\n        // Path Data Segment must begin with a moveTo\r\n        //m (x y)+  Relative moveTo (subsequent points are treated as lineTo)\r\n        //M (x y)+  Absolute moveTo (subsequent points are treated as lineTo)\r\n        //l (x y)+  Relative lineTo\r\n        //L (x y)+  Absolute LineTo\r\n        //h (x)+    Relative horizontal lineTo\r\n        //H (x)+    Absolute horizontal lineTo\r\n        //v (y)+    Relative vertical lineTo\r\n        //V (y)+    Absolute vertical lineTo\r\n        //z (closepath)\r\n        //Z (closepath)\r\n        //c (x1 y1 x2 y2 x y)+ Relative Bezier curve\r\n        //C (x1 y1 x2 y2 x y)+ Absolute Bezier curve\r\n        //q (x1 y1 x y)+       Relative Quadratic Bezier\r\n        //Q (x1 y1 x y)+       Absolute Quadratic Bezier\r\n        //t (x y)+    Shorthand/Smooth Relative Quadratic Bezier\r\n        //T (x y)+    Shorthand/Smooth Absolute Quadratic Bezier\r\n        //s (x2 y2 x y)+       Shorthand/Smooth Relative Bezier curve\r\n        //S (x2 y2 x y)+       Shorthand/Smooth Absolute Bezier curve\r\n        //a (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+     Relative Elliptical Arc\r\n        //A (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+  Absolute Elliptical Arc\r\n        // return early if data is not defined\r\n        if (!data) {\r\n            return [];\r\n        }\r\n        // command string\r\n        var cs = data;\r\n        // command chars\r\n        var cc = [\r\n            'm',\r\n            'M',\r\n            'l',\r\n            'L',\r\n            'v',\r\n            'V',\r\n            'h',\r\n            'H',\r\n            'z',\r\n            'Z',\r\n            'c',\r\n            'C',\r\n            'q',\r\n            'Q',\r\n            't',\r\n            'T',\r\n            's',\r\n            'S',\r\n            'a',\r\n            'A'\r\n        ];\r\n        // convert white spaces to commas\r\n        cs = cs.replace(new RegExp(' ', 'g'), ',');\r\n        // create pipes so that we can split the data\r\n        for (var n = 0; n < cc.length; n++) {\r\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\r\n        }\r\n        // create array\r\n        var arr = cs.split('|');\r\n        var ca = [];\r\n        var coords = [];\r\n        // init context point\r\n        var cpx = 0;\r\n        var cpy = 0;\r\n        var re = /([-+]?((\\d+\\.\\d+)|((\\d+)|(\\.\\d+)))(?:e[-+]?\\d+)?)/gi;\r\n        var match;\r\n        for (n = 1; n < arr.length; n++) {\r\n            var str = arr[n];\r\n            var c = str.charAt(0);\r\n            str = str.slice(1);\r\n            coords.length = 0;\r\n            while ((match = re.exec(str))) {\r\n                coords.push(match[0]);\r\n            }\r\n            // while ((match = re.exec(str))) {\r\n            //   coords.push(match[0]);\r\n            // }\r\n            var p = [];\r\n            for (var j = 0, jlen = coords.length; j < jlen; j++) {\r\n                var parsed = parseFloat(coords[j]);\r\n                if (!isNaN(parsed)) {\r\n                    p.push(parsed);\r\n                }\r\n                else {\r\n                    p.push(0);\r\n                }\r\n            }\r\n            while (p.length > 0) {\r\n                if (isNaN(p[0])) {\r\n                    // case for a trailing comma before next command\r\n                    break;\r\n                }\r\n                var cmd = null;\r\n                var points = [];\r\n                var startX = cpx, startY = cpy;\r\n                // Move var from within the switch to up here (jshint)\r\n                var prevCmd, ctlPtx, ctlPty; // Ss, Tt\r\n                var rx, ry, psi, fa, fs, x1, y1; // Aa\r\n                // convert l, H, h, V, and v to L\r\n                switch (c) {\r\n                    // Note: Keep the lineTo's above the moveTo's in this switch\r\n                    case 'l':\r\n                        cpx += p.shift();\r\n                        cpy += p.shift();\r\n                        cmd = 'L';\r\n                        points.push(cpx, cpy);\r\n                        break;\r\n                    case 'L':\r\n                        cpx = p.shift();\r\n                        cpy = p.shift();\r\n                        points.push(cpx, cpy);\r\n                        break;\r\n                    // Note: lineTo handlers need to be above this point\r\n                    case 'm':\r\n                        var dx = p.shift();\r\n                        var dy = p.shift();\r\n                        cpx += dx;\r\n                        cpy += dy;\r\n                        cmd = 'M';\r\n                        // After closing the path move the current position\r\n                        // to the the first point of the path (if any).\r\n                        if (ca.length > 2 && ca[ca.length - 1].command === 'z') {\r\n                            for (var idx = ca.length - 2; idx >= 0; idx--) {\r\n                                if (ca[idx].command === 'M') {\r\n                                    cpx = ca[idx].points[0] + dx;\r\n                                    cpy = ca[idx].points[1] + dy;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        points.push(cpx, cpy);\r\n                        c = 'l';\r\n                        // subsequent points are treated as relative lineTo\r\n                        break;\r\n                    case 'M':\r\n                        cpx = p.shift();\r\n                        cpy = p.shift();\r\n                        cmd = 'M';\r\n                        points.push(cpx, cpy);\r\n                        c = 'L';\r\n                        // subsequent points are treated as absolute lineTo\r\n                        break;\r\n                    case 'h':\r\n                        cpx += p.shift();\r\n                        cmd = 'L';\r\n                        points.push(cpx, cpy);\r\n                        break;\r\n                    case 'H':\r\n                        cpx = p.shift();\r\n                        cmd = 'L';\r\n                        points.push(cpx, cpy);\r\n                        break;\r\n                    case 'v':\r\n                        cpy += p.shift();\r\n                        cmd = 'L';\r\n                        points.push(cpx, cpy);\r\n                        break;\r\n                    case 'V':\r\n                        cpy = p.shift();\r\n                        cmd = 'L';\r\n                        points.push(cpx, cpy);\r\n                        break;\r\n                    case 'C':\r\n                        points.push(p.shift(), p.shift(), p.shift(), p.shift());\r\n                        cpx = p.shift();\r\n                        cpy = p.shift();\r\n                        points.push(cpx, cpy);\r\n                        break;\r\n                    case 'c':\r\n                        points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());\r\n                        cpx += p.shift();\r\n                        cpy += p.shift();\r\n                        cmd = 'C';\r\n                        points.push(cpx, cpy);\r\n                        break;\r\n                    case 'S':\r\n                        ctlPtx = cpx;\r\n                        ctlPty = cpy;\r\n                        prevCmd = ca[ca.length - 1];\r\n                        if (prevCmd.command === 'C') {\r\n                            ctlPtx = cpx + (cpx - prevCmd.points[2]);\r\n                            ctlPty = cpy + (cpy - prevCmd.points[3]);\r\n                        }\r\n                        points.push(ctlPtx, ctlPty, p.shift(), p.shift());\r\n                        cpx = p.shift();\r\n                        cpy = p.shift();\r\n                        cmd = 'C';\r\n                        points.push(cpx, cpy);\r\n                        break;\r\n                    case 's':\r\n                        ctlPtx = cpx;\r\n                        ctlPty = cpy;\r\n                        prevCmd = ca[ca.length - 1];\r\n                        if (prevCmd.command === 'C') {\r\n                            ctlPtx = cpx + (cpx - prevCmd.points[2]);\r\n                            ctlPty = cpy + (cpy - prevCmd.points[3]);\r\n                        }\r\n                        points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());\r\n                        cpx += p.shift();\r\n                        cpy += p.shift();\r\n                        cmd = 'C';\r\n                        points.push(cpx, cpy);\r\n                        break;\r\n                    case 'Q':\r\n                        points.push(p.shift(), p.shift());\r\n                        cpx = p.shift();\r\n                        cpy = p.shift();\r\n                        points.push(cpx, cpy);\r\n                        break;\r\n                    case 'q':\r\n                        points.push(cpx + p.shift(), cpy + p.shift());\r\n                        cpx += p.shift();\r\n                        cpy += p.shift();\r\n                        cmd = 'Q';\r\n                        points.push(cpx, cpy);\r\n                        break;\r\n                    case 'T':\r\n                        ctlPtx = cpx;\r\n                        ctlPty = cpy;\r\n                        prevCmd = ca[ca.length - 1];\r\n                        if (prevCmd.command === 'Q') {\r\n                            ctlPtx = cpx + (cpx - prevCmd.points[0]);\r\n                            ctlPty = cpy + (cpy - prevCmd.points[1]);\r\n                        }\r\n                        cpx = p.shift();\r\n                        cpy = p.shift();\r\n                        cmd = 'Q';\r\n                        points.push(ctlPtx, ctlPty, cpx, cpy);\r\n                        break;\r\n                    case 't':\r\n                        ctlPtx = cpx;\r\n                        ctlPty = cpy;\r\n                        prevCmd = ca[ca.length - 1];\r\n                        if (prevCmd.command === 'Q') {\r\n                            ctlPtx = cpx + (cpx - prevCmd.points[0]);\r\n                            ctlPty = cpy + (cpy - prevCmd.points[1]);\r\n                        }\r\n                        cpx += p.shift();\r\n                        cpy += p.shift();\r\n                        cmd = 'Q';\r\n                        points.push(ctlPtx, ctlPty, cpx, cpy);\r\n                        break;\r\n                    case 'A':\r\n                        rx = p.shift();\r\n                        ry = p.shift();\r\n                        psi = p.shift();\r\n                        fa = p.shift();\r\n                        fs = p.shift();\r\n                        x1 = cpx;\r\n                        y1 = cpy;\r\n                        cpx = p.shift();\r\n                        cpy = p.shift();\r\n                        cmd = 'A';\r\n                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);\r\n                        break;\r\n                    case 'a':\r\n                        rx = p.shift();\r\n                        ry = p.shift();\r\n                        psi = p.shift();\r\n                        fa = p.shift();\r\n                        fs = p.shift();\r\n                        x1 = cpx;\r\n                        y1 = cpy;\r\n                        cpx += p.shift();\r\n                        cpy += p.shift();\r\n                        cmd = 'A';\r\n                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);\r\n                        break;\r\n                }\r\n                ca.push({\r\n                    command: cmd || c,\r\n                    points: points,\r\n                    start: {\r\n                        x: startX,\r\n                        y: startY\r\n                    },\r\n                    pathLength: this.calcLength(startX, startY, cmd || c, points)\r\n                });\r\n            }\r\n            if (c === 'z' || c === 'Z') {\r\n                ca.push({\r\n                    command: 'z',\r\n                    points: [],\r\n                    start: undefined,\r\n                    pathLength: 0\r\n                });\r\n            }\r\n        }\r\n        return ca;\r\n    };\r\n    Path.calcLength = function (x, y, cmd, points) {\r\n        var len, p1, p2, t;\r\n        var path = Path;\r\n        switch (cmd) {\r\n            case 'L':\r\n                return path.getLineLength(x, y, points[0], points[1]);\r\n            case 'C':\r\n                // Approximates by breaking curve into 100 line segments\r\n                len = 0.0;\r\n                p1 = path.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\r\n                for (t = 0.01; t <= 1; t += 0.01) {\r\n                    p2 = path.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\r\n                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);\r\n                    p1 = p2;\r\n                }\r\n                return len;\r\n            case 'Q':\r\n                // Approximates by breaking curve into 100 line segments\r\n                len = 0.0;\r\n                p1 = path.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);\r\n                for (t = 0.01; t <= 1; t += 0.01) {\r\n                    p2 = path.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);\r\n                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);\r\n                    p1 = p2;\r\n                }\r\n                return len;\r\n            case 'A':\r\n                // Approximates by breaking curve into line segments\r\n                len = 0.0;\r\n                var start = points[4];\r\n                // 4 = theta\r\n                var dTheta = points[5];\r\n                // 5 = dTheta\r\n                var end = points[4] + dTheta;\r\n                var inc = Math.PI / 180.0;\r\n                // 1 degree resolution\r\n                if (Math.abs(start - end) < inc) {\r\n                    inc = Math.abs(start - end);\r\n                }\r\n                // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi\r\n                p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);\r\n                if (dTheta < 0) {\r\n                    // clockwise\r\n                    for (t = start - inc; t > end; t -= inc) {\r\n                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\r\n                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);\r\n                        p1 = p2;\r\n                    }\r\n                }\r\n                else {\r\n                    // counter-clockwise\r\n                    for (t = start + inc; t < end; t += inc) {\r\n                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\r\n                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);\r\n                        p1 = p2;\r\n                    }\r\n                }\r\n                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);\r\n                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);\r\n                return len;\r\n        }\r\n        return 0;\r\n    };\r\n    Path.convertEndpointToCenterParameterization = function (x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {\r\n        // Derived from: http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\r\n        var psi = psiDeg * (Math.PI / 180.0);\r\n        var xp = (Math.cos(psi) * (x1 - x2)) / 2.0 + (Math.sin(psi) * (y1 - y2)) / 2.0;\r\n        var yp = (-1 * Math.sin(psi) * (x1 - x2)) / 2.0 +\r\n            (Math.cos(psi) * (y1 - y2)) / 2.0;\r\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\r\n        if (lambda > 1) {\r\n            rx *= Math.sqrt(lambda);\r\n            ry *= Math.sqrt(lambda);\r\n        }\r\n        var f = Math.sqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) /\r\n            (rx * rx * (yp * yp) + ry * ry * (xp * xp)));\r\n        if (fa === fs) {\r\n            f *= -1;\r\n        }\r\n        if (isNaN(f)) {\r\n            f = 0;\r\n        }\r\n        var cxp = (f * rx * yp) / ry;\r\n        var cyp = (f * -ry * xp) / rx;\r\n        var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;\r\n        var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;\r\n        var vMag = function (v) {\r\n            return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\r\n        };\r\n        var vRatio = function (u, v) {\r\n            return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\r\n        };\r\n        var vAngle = function (u, v) {\r\n            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\r\n        };\r\n        var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\r\n        var u = [(xp - cxp) / rx, (yp - cyp) / ry];\r\n        var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\r\n        var dTheta = vAngle(u, v);\r\n        if (vRatio(u, v) <= -1) {\r\n            dTheta = Math.PI;\r\n        }\r\n        if (vRatio(u, v) >= 1) {\r\n            dTheta = 0;\r\n        }\r\n        if (fs === 0 && dTheta > 0) {\r\n            dTheta = dTheta - 2 * Math.PI;\r\n        }\r\n        if (fs === 1 && dTheta < 0) {\r\n            dTheta = dTheta + 2 * Math.PI;\r\n        }\r\n        return [cx, cy, rx, ry, theta, dTheta, psi, fs];\r\n    };\r\n    return Path;\r\n}(Shape));\r\nexport { Path };\r\nPath.prototype.className = 'Path';\r\nPath.prototype._attrsAffectingSize = ['data'];\r\n_registerNode(Path);\r\n/**\r\n * get/set SVG path data string.  This method\r\n *  also automatically parses the data string\r\n *  into a data array.  Currently supported SVG data:\r\n *  M, m, L, l, H, h, V, v, Q, q, T, t, C, c, S, s, A, a, Z, z\r\n * @name Konva.Path#data\r\n * @method\r\n * @param {String} data svg path string\r\n * @returns {String}\r\n * @example\r\n * // get data\r\n * var data = path.data();\r\n *\r\n * // set data\r\n * path.data('M200,100h100v50z');\r\n */\r\nFactory.addGetterSetter(Path, 'data');\r\nCollection.mapMethods(Path);\r\n"}
