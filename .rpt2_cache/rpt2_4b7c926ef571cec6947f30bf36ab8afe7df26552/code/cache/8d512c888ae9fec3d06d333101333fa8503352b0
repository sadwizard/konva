{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Util, Collection } from './Util';\r\nimport { Container } from './Container';\r\nimport { Factory } from './Factory';\r\nimport { BaseLayer } from './BaseLayer';\r\nimport { HitCanvas } from './Canvas';\r\nimport { shapes } from './Shape';\r\nimport { getBooleanValidator } from './Validators';\r\nimport { _registerNode } from './Global';\r\n// constants\r\nvar HASH = '#', BEFORE_DRAW = 'beforeDraw', DRAW = 'draw', \r\n/*\r\n * 2 - 3 - 4\r\n * |       |\r\n * 1 - 0   5\r\n *         |\r\n * 8 - 7 - 6\r\n */\r\nINTERSECTION_OFFSETS = [\r\n    { x: 0, y: 0 },\r\n    { x: -1, y: -1 },\r\n    { x: 1, y: -1 },\r\n    { x: 1, y: 1 },\r\n    { x: -1, y: 1 } // 8\r\n], INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;\r\n/**\r\n * Layer constructor.  Layers are tied to their own canvas element and are used\r\n * to contain groups or shapes.\r\n * @constructor\r\n * @memberof Konva\r\n * @augments Konva.BaseLayer\r\n * @param {Object} config\r\n * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want\r\n * to clear the canvas before each layer draw.  The default value is true.\r\n * @@nodeParams\r\n * @@containerParams\r\n * @example\r\n * var layer = new Konva.Layer();\r\n * stage.add(layer);\r\n * // now you can add shapes, groups into the layer\r\n */\r\nvar Layer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Layer, _super);\r\n    function Layer() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.hitCanvas = new HitCanvas({\r\n            pixelRatio: 1\r\n        });\r\n        return _this;\r\n    }\r\n    Layer.prototype._setCanvasSize = function (width, height) {\r\n        this.canvas.setSize(width, height);\r\n        this.hitCanvas.setSize(width, height);\r\n        this._checkSmooth();\r\n    };\r\n    Layer.prototype._validateAdd = function (child) {\r\n        var type = child.getType();\r\n        if (type !== 'Group' && type !== 'Shape' && type !== 'AbstractGroup') {\r\n            Util.throw('You may only add groups and shapes to a layer.');\r\n        }\r\n    };\r\n    /**\r\n     * get visible intersection shape. This is the preferred\r\n     * method for determining if a point intersects a shape or not\r\n     * also you may pass optional selector parameter to return ancestor of intersected shape\r\n     * @method\r\n     * @name Konva.Layer#getIntersection\r\n     * @param {Object} pos\r\n     * @param {Number} pos.x\r\n     * @param {Number} pos.y\r\n     * @param {String} [selector]\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * var shape = layer.getIntersection({x: 50, y: 50});\r\n     * // or if you interested in shape parent:\r\n     * var group = layer.getIntersection({x: 50, y: 50}, 'Group');\r\n     */\r\n    Layer.prototype.getIntersection = function (pos, selector) {\r\n        var obj, i, intersectionOffset, shape;\r\n        if (!this.hitGraphEnabled() || !this.isVisible()) {\r\n            return null;\r\n        }\r\n        // in some cases antialiased area may be bigger than 1px\r\n        // it is possible if we will cache node, then scale it a lot\r\n        var spiralSearchDistance = 1;\r\n        var continueSearch = false;\r\n        while (true) {\r\n            for (i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {\r\n                intersectionOffset = INTERSECTION_OFFSETS[i];\r\n                obj = this._getIntersection({\r\n                    x: pos.x + intersectionOffset.x * spiralSearchDistance,\r\n                    y: pos.y + intersectionOffset.y * spiralSearchDistance\r\n                });\r\n                shape = obj.shape;\r\n                if (shape && selector) {\r\n                    return shape.findAncestor(selector, true);\r\n                }\r\n                else if (shape) {\r\n                    return shape;\r\n                }\r\n                // we should continue search if we found antialiased pixel\r\n                // that means our node somewhere very close\r\n                continueSearch = !!obj.antialiased;\r\n                // stop search if found empty pixel\r\n                if (!obj.antialiased) {\r\n                    break;\r\n                }\r\n            }\r\n            // if no shape, and no antialiased pixel, we should end searching\r\n            if (continueSearch) {\r\n                spiralSearchDistance += 1;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    };\r\n    Layer.prototype._getIntersection = function (pos) {\r\n        var ratio = this.hitCanvas.pixelRatio;\r\n        var p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data, p3 = p[3], colorKey, shape;\r\n        // fully opaque pixel\r\n        if (p3 === 255) {\r\n            colorKey = Util._rgbToHex(p[0], p[1], p[2]);\r\n            shape = shapes[HASH + colorKey];\r\n            if (shape) {\r\n                return {\r\n                    shape: shape\r\n                };\r\n            }\r\n            return {\r\n                antialiased: true\r\n            };\r\n        }\r\n        else if (p3 > 0) {\r\n            // antialiased pixel\r\n            return {\r\n                antialiased: true\r\n            };\r\n        }\r\n        // empty pixel\r\n        return {};\r\n    };\r\n    Layer.prototype.drawScene = function (can, top) {\r\n        var layer = this.getLayer(), canvas = can || (layer && layer.getCanvas());\r\n        this._fire(BEFORE_DRAW, {\r\n            node: this\r\n        });\r\n        if (this.clearBeforeDraw()) {\r\n            canvas.getContext().clear();\r\n        }\r\n        Container.prototype.drawScene.call(this, canvas, top);\r\n        this._fire(DRAW, {\r\n            node: this\r\n        });\r\n        return this;\r\n    };\r\n    Layer.prototype.drawHit = function (can, top) {\r\n        var layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas);\r\n        if (layer && layer.clearBeforeDraw()) {\r\n            layer\r\n                .getHitCanvas()\r\n                .getContext()\r\n                .clear();\r\n        }\r\n        Container.prototype.drawHit.call(this, canvas, top);\r\n        return this;\r\n    };\r\n    Layer.prototype.clear = function (bounds) {\r\n        BaseLayer.prototype.clear.call(this, bounds);\r\n        this.getHitCanvas()\r\n            .getContext()\r\n            .clear(bounds);\r\n        return this;\r\n    };\r\n    /**\r\n     * enable hit graph\r\n     * @name Konva.Layer#enableHitGraph\r\n     * @method\r\n     * @returns {Layer}\r\n     */\r\n    Layer.prototype.enableHitGraph = function () {\r\n        this.hitGraphEnabled(true);\r\n        return this;\r\n    };\r\n    /**\r\n     * disable hit graph\r\n     * @name Konva.Layer#disableHitGraph\r\n     * @method\r\n     * @returns {Layer}\r\n     */\r\n    Layer.prototype.disableHitGraph = function () {\r\n        this.hitGraphEnabled(false);\r\n        return this;\r\n    };\r\n    /**\r\n     * Show or hide hit canvas over the stage. May be useful for debugging custom hitFunc\r\n     * @name Konva.Layer#toggleHitCanvas\r\n     * @method\r\n     */\r\n    Layer.prototype.toggleHitCanvas = function () {\r\n        if (!this.parent) {\r\n            return;\r\n        }\r\n        var parent = this.parent;\r\n        var added = !!this.hitCanvas._canvas.parentNode;\r\n        if (added) {\r\n            parent.content.removeChild(this.hitCanvas._canvas);\r\n        }\r\n        else {\r\n            parent.content.appendChild(this.hitCanvas._canvas);\r\n        }\r\n    };\r\n    Layer.prototype.setSize = function (_a) {\r\n        var width = _a.width, height = _a.height;\r\n        _super.prototype.setSize.call(this, { width: width, height: height });\r\n        this.hitCanvas.setSize(width, height);\r\n        return this;\r\n    };\r\n    return Layer;\r\n}(BaseLayer));\r\nexport { Layer };\r\nLayer.prototype.nodeType = 'Layer';\r\n_registerNode(Layer);\r\nFactory.addGetterSetter(Layer, 'hitGraphEnabled', true, getBooleanValidator());\r\n/**\r\n * get/set hitGraphEnabled flag.  Disabling the hit graph will greatly increase\r\n *  draw performance because the hit graph will not be redrawn each time the layer is\r\n *  drawn.  This, however, also disables mouse/touch event detection\r\n * @name Konva.Layer#hitGraphEnabled\r\n * @method\r\n * @param {Boolean} enabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get hitGraphEnabled flag\r\n * var hitGraphEnabled = layer.hitGraphEnabled();\r\n *\r\n * // disable hit graph\r\n * layer.hitGraphEnabled(false);\r\n *\r\n * // enable hit graph\r\n * layer.hitGraphEnabled(true);\r\n */\r\nCollection.mapMethods(Layer);\r\n"}
