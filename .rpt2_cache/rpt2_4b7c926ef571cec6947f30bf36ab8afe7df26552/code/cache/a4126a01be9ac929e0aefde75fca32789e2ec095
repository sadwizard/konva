{"code":"import { glob } from './Global';\r\nvar now = (function () {\r\n    if (glob.performance && glob.performance.now) {\r\n        return function () {\r\n            return glob.performance.now();\r\n        };\r\n    }\r\n    return function () {\r\n        return new Date().getTime();\r\n    };\r\n})();\r\n/**\r\n * Animation constructor.\r\n * @constructor\r\n * @memberof Konva\r\n * @param {Function} func function executed on each animation frame.  The function is passed a frame object, which contains\r\n *  timeDiff, lastTime, time, and frameRate properties.  The timeDiff property is the number of milliseconds that have passed\r\n *  since the last animation frame.  The lastTime property is time in milliseconds that elapsed from the moment the animation started\r\n *  to the last animation frame.  The time property is the time in milliseconds that ellapsed from the moment the animation started\r\n *  to the current animation frame.  The frameRate property is the current frame rate in frames / second. Return false from function,\r\n *  if you don't need to redraw layer/layers on some frames.\r\n * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn on each animation frame. Can be a layer, an array of layers, or null.\r\n *  Not specifying a node will result in no redraw.\r\n * @example\r\n * // move a node to the right at 50 pixels / second\r\n * var velocity = 50;\r\n *\r\n * var anim = new Konva.Animation(function(frame) {\r\n *   var dist = velocity * (frame.timeDiff / 1000);\r\n *   node.move({x: dist, y: 0});\r\n * }, layer);\r\n *\r\n * anim.start();\r\n */\r\nvar Animation = /** @class */ (function () {\r\n    function Animation(func, layers) {\r\n        this.id = Animation.animIdCounter++;\r\n        this.frame = {\r\n            time: 0,\r\n            timeDiff: 0,\r\n            lastTime: now(),\r\n            frameRate: 0\r\n        };\r\n        this.func = func;\r\n        this.setLayers(layers);\r\n    }\r\n    /**\r\n     * set layers to be redrawn on each animation frame\r\n     * @method\r\n     * @name Konva.Animation#setLayers\r\n     * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn. Can be a layer, an array of layers, or null.  Not specifying a node will result in no redraw.\r\n     * @return {Konva.Animation} this\r\n     */\r\n    Animation.prototype.setLayers = function (layers) {\r\n        var lays = [];\r\n        // if passing in no layers\r\n        if (!layers) {\r\n            lays = [];\r\n        }\r\n        else if (layers.length > 0) {\r\n            // if passing in an array of Layers\r\n            // NOTE: layers could be an array or Konva.Collection.  for simplicity, I'm just inspecting\r\n            // the length property to check for both cases\r\n            lays = layers;\r\n        }\r\n        else {\r\n            // if passing in a Layer\r\n            lays = [layers];\r\n        }\r\n        this.layers = lays;\r\n        return this;\r\n    };\r\n    /**\r\n     * get layers\r\n     * @method\r\n     * @name Konva.Animation#getLayers\r\n     * @return {Array} Array of Konva.Layer\r\n     */\r\n    Animation.prototype.getLayers = function () {\r\n        return this.layers;\r\n    };\r\n    /**\r\n     * add layer.  Returns true if the layer was added, and false if it was not\r\n     * @method\r\n     * @name Konva.Animation#addLayer\r\n     * @param {Konva.Layer} layer to add\r\n     * @return {Bool} true if layer is added to animation, otherwise false\r\n     */\r\n    Animation.prototype.addLayer = function (layer) {\r\n        var layers = this.layers, len = layers.length, n;\r\n        // don't add the layer if it already exists\r\n        for (n = 0; n < len; n++) {\r\n            if (layers[n]._id === layer._id) {\r\n                return false;\r\n            }\r\n        }\r\n        this.layers.push(layer);\r\n        return true;\r\n    };\r\n    /**\r\n     * determine if animation is running or not.  returns true or false\r\n     * @method\r\n     * @name Konva.Animation#isRunning\r\n     * @return {Bool} is animation running?\r\n     */\r\n    Animation.prototype.isRunning = function () {\r\n        var a = Animation, animations = a.animations, len = animations.length, n;\r\n        for (n = 0; n < len; n++) {\r\n            if (animations[n].id === this.id) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * start animation\r\n     * @method\r\n     * @name Konva.Animation#start\r\n     * @return {Konva.Animation} this\r\n     */\r\n    Animation.prototype.start = function () {\r\n        this.stop();\r\n        this.frame.timeDiff = 0;\r\n        this.frame.lastTime = now();\r\n        Animation._addAnimation(this);\r\n        return this;\r\n    };\r\n    /**\r\n     * stop animation\r\n     * @method\r\n     * @name Konva.Animation#stop\r\n     * @return {Konva.Animation} this\r\n     */\r\n    Animation.prototype.stop = function () {\r\n        Animation._removeAnimation(this);\r\n        return this;\r\n    };\r\n    Animation.prototype._updateFrameObject = function (time) {\r\n        this.frame.timeDiff = time - this.frame.lastTime;\r\n        this.frame.lastTime = time;\r\n        this.frame.time += this.frame.timeDiff;\r\n        this.frame.frameRate = 1000 / this.frame.timeDiff;\r\n    };\r\n    Animation._addAnimation = function (anim) {\r\n        this.animations.push(anim);\r\n        this._handleAnimation();\r\n    };\r\n    Animation._removeAnimation = function (anim) {\r\n        var id = anim.id, animations = this.animations, len = animations.length, n;\r\n        for (n = 0; n < len; n++) {\r\n            if (animations[n].id === id) {\r\n                this.animations.splice(n, 1);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    Animation._runFrames = function () {\r\n        var layerHash = {}, animations = this.animations, anim, layers, func, n, i, layersLen, layer, key, needRedraw;\r\n        /*\r\n         * loop through all animations and execute animation\r\n         *  function.  if the animation object has specified node,\r\n         *  we can add the node to the nodes hash to eliminate\r\n         *  drawing the same node multiple times.  The node property\r\n         *  can be the stage itself or a layer\r\n         */\r\n        /*\r\n         * WARNING: don't cache animations.length because it could change while\r\n         * the for loop is running, causing a JS error\r\n         */\r\n        for (n = 0; n < animations.length; n++) {\r\n            anim = animations[n];\r\n            layers = anim.layers;\r\n            func = anim.func;\r\n            anim._updateFrameObject(now());\r\n            layersLen = layers.length;\r\n            // if animation object has a function, execute it\r\n            if (func) {\r\n                // allow anim bypassing drawing\r\n                needRedraw = func.call(anim, anim.frame) !== false;\r\n            }\r\n            else {\r\n                needRedraw = true;\r\n            }\r\n            if (!needRedraw) {\r\n                continue;\r\n            }\r\n            for (i = 0; i < layersLen; i++) {\r\n                layer = layers[i];\r\n                if (layer._id !== undefined) {\r\n                    layerHash[layer._id] = layer;\r\n                }\r\n            }\r\n        }\r\n        for (key in layerHash) {\r\n            if (!layerHash.hasOwnProperty(key)) {\r\n                continue;\r\n            }\r\n            layerHash[key].draw();\r\n        }\r\n    };\r\n    Animation._animationLoop = function () {\r\n        var Anim = Animation;\r\n        if (Anim.animations.length) {\r\n            Anim._runFrames();\r\n            requestAnimationFrame(Anim._animationLoop);\r\n        }\r\n        else {\r\n            Anim.animRunning = false;\r\n        }\r\n    };\r\n    Animation._handleAnimation = function () {\r\n        if (!this.animRunning) {\r\n            this.animRunning = true;\r\n            requestAnimationFrame(this._animationLoop);\r\n        }\r\n    };\r\n    Animation.animations = [];\r\n    Animation.animIdCounter = 0;\r\n    Animation.animRunning = false;\r\n    return Animation;\r\n}());\r\nexport { Animation };\r\n"}
