{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Util, Collection } from '../Util';\r\nimport { Factory } from '../Factory';\r\nimport { Shape } from '../Shape';\r\nimport { getNumberValidator, getNumberArrayValidator } from '../Validators';\r\nimport { _registerNode } from '../Global';\r\n/**\r\n * Line constructor.&nbsp; Lines are defined by an array of points and\r\n *  a tension\r\n * @constructor\r\n * @memberof Konva\r\n * @augments Konva.Shape\r\n * @param {Object} config\r\n * @param {Array} config.points Flat array of points coordinates. You should define them as [x1, y1, x2, y2, x3, y3].\r\n * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.\r\n *   The default is 0\r\n * @param {Boolean} [config.closed] defines whether or not the line shape is closed, creating a polygon or blob\r\n * @param {Boolean} [config.bezier] if no tension is provided but bezier=true, we draw the line as a bezier using the passed points\r\n * @@shapeParams\r\n * @@nodeParams\r\n * @example\r\n * var line = new Konva.Line({\r\n *   x: 100,\r\n *   y: 50,\r\n *   points: [73, 70, 340, 23, 450, 60, 500, 20],\r\n *   stroke: 'red',\r\n *   tension: 1\r\n * });\r\n */\r\nvar Line = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Line, _super);\r\n    function Line(config) {\r\n        var _this = _super.call(this, config) || this;\r\n        _this.on('pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva', function () {\r\n            this._clearCache('tensionPoints');\r\n        });\r\n        return _this;\r\n    }\r\n    Line.prototype._sceneFunc = function (context) {\r\n        var points = this.points(), length = points.length, tension = this.tension(), closed = this.closed(), bezier = this.bezier(), tp, len, n;\r\n        if (!length) {\r\n            return;\r\n        }\r\n        context.beginPath();\r\n        context.moveTo(points[0], points[1]);\r\n        // tension\r\n        if (tension !== 0 && length > 4) {\r\n            tp = this.getTensionPoints();\r\n            len = tp.length;\r\n            n = closed ? 0 : 4;\r\n            if (!closed) {\r\n                context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);\r\n            }\r\n            while (n < len - 2) {\r\n                context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);\r\n            }\r\n            if (!closed) {\r\n                context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);\r\n            }\r\n        }\r\n        else if (bezier) {\r\n            // no tension but bezier\r\n            n = 2;\r\n            while (n < length) {\r\n                context.bezierCurveTo(points[n++], points[n++], points[n++], points[n++], points[n++], points[n++]);\r\n            }\r\n        }\r\n        else {\r\n            // no tension\r\n            for (n = 2; n < length; n += 2) {\r\n                context.lineTo(points[n], points[n + 1]);\r\n            }\r\n        }\r\n        // closed e.g. polygons and blobs\r\n        if (closed) {\r\n            context.closePath();\r\n            context.fillStrokeShape(this);\r\n        }\r\n        else {\r\n            // open e.g. lines and splines\r\n            context.strokeShape(this);\r\n        }\r\n    };\r\n    Line.prototype.getTensionPoints = function () {\r\n        return this._getCache('tensionPoints', this._getTensionPoints);\r\n    };\r\n    Line.prototype._getTensionPoints = function () {\r\n        if (this.closed()) {\r\n            return this._getTensionPointsClosed();\r\n        }\r\n        else {\r\n            return Util._expandPoints(this.points(), this.tension());\r\n        }\r\n    };\r\n    Line.prototype._getTensionPointsClosed = function () {\r\n        var p = this.points(), len = p.length, tension = this.tension(), firstControlPoints = Util._getControlPoints(p[len - 2], p[len - 1], p[0], p[1], p[2], p[3], tension), lastControlPoints = Util._getControlPoints(p[len - 4], p[len - 3], p[len - 2], p[len - 1], p[0], p[1], tension), middle = Util._expandPoints(p, tension), tp = [firstControlPoints[2], firstControlPoints[3]]\r\n            .concat(middle)\r\n            .concat([\r\n            lastControlPoints[0],\r\n            lastControlPoints[1],\r\n            p[len - 2],\r\n            p[len - 1],\r\n            lastControlPoints[2],\r\n            lastControlPoints[3],\r\n            firstControlPoints[0],\r\n            firstControlPoints[1],\r\n            p[0],\r\n            p[1]\r\n        ]);\r\n        return tp;\r\n    };\r\n    Line.prototype.getWidth = function () {\r\n        return this.getSelfRect().width;\r\n    };\r\n    Line.prototype.getHeight = function () {\r\n        return this.getSelfRect().height;\r\n    };\r\n    // overload size detection\r\n    Line.prototype.getSelfRect = function () {\r\n        var points;\r\n        if (this.tension() !== 0) {\r\n            points = this._getTensionPoints();\r\n        }\r\n        else {\r\n            points = this.points();\r\n        }\r\n        var minX = points[0];\r\n        var maxX = points[0];\r\n        var minY = points[1];\r\n        var maxY = points[1];\r\n        var x, y;\r\n        for (var i = 0; i < points.length / 2; i++) {\r\n            x = points[i * 2];\r\n            y = points[i * 2 + 1];\r\n            minX = Math.min(minX, x);\r\n            maxX = Math.max(maxX, x);\r\n            minY = Math.min(minY, y);\r\n            maxY = Math.max(maxY, y);\r\n        }\r\n        return {\r\n            x: Math.round(minX),\r\n            y: Math.round(minY),\r\n            width: Math.round(maxX - minX),\r\n            height: Math.round(maxY - minY)\r\n        };\r\n    };\r\n    return Line;\r\n}(Shape));\r\nexport { Line };\r\nLine.prototype.className = 'Line';\r\nLine.prototype._attrsAffectingSize = ['points', 'bezier', 'tension'];\r\n_registerNode(Line);\r\n// add getters setters\r\nFactory.addGetterSetter(Line, 'closed', false);\r\n/**\r\n * get/set closed flag.  The default is false\r\n * @name Konva.Line#closed\r\n * @method\r\n * @param {Boolean} closed\r\n * @returns {Boolean}\r\n * @example\r\n * // get closed flag\r\n * var closed = line.closed();\r\n *\r\n * // close the shape\r\n * line.closed(true);\r\n *\r\n * // open the shape\r\n * line.closed(false);\r\n */\r\nFactory.addGetterSetter(Line, 'bezier', false);\r\n/**\r\n * get/set bezier flag.  The default is false\r\n * @name Konva.Line#bezier\r\n * @method\r\n * @param {Boolean} bezier\r\n * @returns {Boolean}\r\n * @example\r\n * // get whether the line is a bezier\r\n * var isBezier = line.bezier();\r\n *\r\n * // set whether the line is a bezier\r\n * line.bezier(true);\r\n */\r\nFactory.addGetterSetter(Line, 'tension', 0, getNumberValidator());\r\n/**\r\n * get/set tension\r\n * @name Konva.Line#tension\r\n * @method\r\n * @param {Number} tension Higher values will result in a more curvy line.  A value of 0 will result in no interpolation. The default is 0\r\n * @returns {Number}\r\n * @example\r\n * // get tension\r\n * var tension = line.tension();\r\n *\r\n * // set tension\r\n * line.tension(3);\r\n */\r\nFactory.addGetterSetter(Line, 'points', [], getNumberArrayValidator());\r\n/**\r\n * get/set points array. Points is a flat array [x1, y1, x2, y2]. It is flat for performance reasons.\r\n * @name Konva.Line#points\r\n * @method\r\n * @param {Array} points\r\n * @returns {Array}\r\n * @example\r\n * // get points\r\n * var points = line.points();\r\n *\r\n * // set points\r\n * line.points([10, 20, 30, 40, 50, 60]);\r\n *\r\n * // push a new point\r\n * line.points(line.points().concat([70, 80]));\r\n */\r\nCollection.mapMethods(Line);\r\n"}
