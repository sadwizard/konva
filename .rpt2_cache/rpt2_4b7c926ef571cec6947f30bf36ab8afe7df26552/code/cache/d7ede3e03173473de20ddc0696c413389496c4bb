{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Util, Collection } from './Util';\r\nimport { Container } from './Container';\r\nimport { Node } from './Node';\r\nimport { Factory } from './Factory';\r\nimport { SceneCanvas } from './Canvas';\r\n/**\r\n * BaseLayer constructor.\r\n * @constructor\r\n * @memberof Konva\r\n * @augments Konva.Container\r\n * @param {Object} config\r\n * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want\r\n * to clear the canvas before each layer draw.  The default value is true.\r\n * @@nodeParams\r\n * @@containerParams\r\n */\r\nvar BaseLayer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(BaseLayer, _super);\r\n    function BaseLayer(config) {\r\n        var _this = _super.call(this, config) || this;\r\n        _this.canvas = new SceneCanvas();\r\n        _this._waitingForDraw = false;\r\n        _this.on('visibleChange', _this._checkVisibility);\r\n        _this._checkVisibility();\r\n        _this.on('imageSmoothingEnabledChange', _this._checkSmooth);\r\n        _this._checkSmooth();\r\n        _this.on('mousedown touchstart', function (e) {\r\n            var target = e.target;\r\n            if (target.abstractParent && target.abstractParent.attrs.draggable) {\r\n                target.abstractParent.startDrag();\r\n            }\r\n        });\r\n        _this.on('mouseup touchend', function (e) {\r\n            var target = e.target;\r\n            if (target.abstractParent) {\r\n                target.abstractParent.stopDrag();\r\n            }\r\n        });\r\n        return _this;\r\n    }\r\n    // for nodejs?\r\n    BaseLayer.prototype.createPNGStream = function () {\r\n        var c = this.canvas._canvas;\r\n        return c.createPNGStream();\r\n    };\r\n    /**\r\n     * get layer canvas wrapper\r\n     * @method\r\n     * @name Konva.BaseLayer#getCanvas\r\n     */\r\n    BaseLayer.prototype.getCanvas = function () {\r\n        return this.canvas;\r\n    };\r\n    /**\r\n     * get layer hit canvas\r\n     * @method\r\n     * @name Konva.BaseLayer#getHitCanvas\r\n     */\r\n    BaseLayer.prototype.getHitCanvas = function () {\r\n        return this.hitCanvas;\r\n    };\r\n    /**\r\n     * get layer canvas context\r\n     * @method\r\n     * @name Konva.BaseLayer#getContext\r\n     */\r\n    BaseLayer.prototype.getContext = function () {\r\n        return this.getCanvas().getContext();\r\n    };\r\n    /**\r\n     * clear scene and hit canvas contexts tied to the layer.\r\n     * This function doesn't remove any nodes. It just clear canvas element.\r\n     * @method\r\n     * @name Konva.BaseLayer#clear\r\n     * @param {Object} [bounds]\r\n     * @param {Number} [bounds.x]\r\n     * @param {Number} [bounds.y]\r\n     * @param {Number} [bounds.width]\r\n     * @param {Number} [bounds.height]\r\n     * @example\r\n     * layer.clear();\r\n     * layer.clear({\r\n     *   x : 0,\r\n     *   y : 0,\r\n     *   width : 100,\r\n     *   height : 100\r\n     * });\r\n     */\r\n    BaseLayer.prototype.clear = function (bounds) {\r\n        this.getContext().clear(bounds);\r\n        return this;\r\n    };\r\n    // extend Node.prototype.setZIndex\r\n    BaseLayer.prototype.setZIndex = function (index) {\r\n        _super.prototype.setZIndex.call(this, index);\r\n        var stage = this.getStage();\r\n        if (stage) {\r\n            stage.content.removeChild(this.getCanvas()._canvas);\r\n            if (index < stage.getChildren().length - 1) {\r\n                stage.content.insertBefore(this.getCanvas()._canvas, stage.getChildren()[index + 1].getCanvas()._canvas);\r\n            }\r\n            else {\r\n                stage.content.appendChild(this.getCanvas()._canvas);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    BaseLayer.prototype.moveToTop = function () {\r\n        Node.prototype.moveToTop.call(this);\r\n        var stage = this.getStage();\r\n        if (stage) {\r\n            stage.content.removeChild(this.getCanvas()._canvas);\r\n            stage.content.appendChild(this.getCanvas()._canvas);\r\n        }\r\n        return true;\r\n    };\r\n    BaseLayer.prototype.moveUp = function () {\r\n        var moved = Node.prototype.moveUp.call(this);\r\n        if (!moved) {\r\n            return false;\r\n        }\r\n        var stage = this.getStage();\r\n        if (!stage) {\r\n            return false;\r\n        }\r\n        stage.content.removeChild(this.getCanvas()._canvas);\r\n        if (this.index < stage.getChildren().length - 1) {\r\n            stage.content.insertBefore(this.getCanvas()._canvas, stage.getChildren()[this.index + 1].getCanvas()._canvas);\r\n        }\r\n        else {\r\n            stage.content.appendChild(this.getCanvas()._canvas);\r\n        }\r\n        return true;\r\n    };\r\n    // extend Node.prototype.moveDown\r\n    BaseLayer.prototype.moveDown = function () {\r\n        if (Node.prototype.moveDown.call(this)) {\r\n            var stage = this.getStage();\r\n            if (stage) {\r\n                var children = stage.getChildren();\r\n                stage.content.removeChild(this.getCanvas()._canvas);\r\n                stage.content.insertBefore(this.getCanvas()._canvas, children[this.index + 1].getCanvas()._canvas);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    // extend Node.prototype.moveToBottom\r\n    BaseLayer.prototype.moveToBottom = function () {\r\n        if (Node.prototype.moveToBottom.call(this)) {\r\n            var stage = this.getStage();\r\n            if (stage) {\r\n                var children = stage.getChildren();\r\n                stage.content.removeChild(this.getCanvas()._canvas);\r\n                stage.content.insertBefore(this.getCanvas()._canvas, children[1].getCanvas()._canvas);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    BaseLayer.prototype.getLayer = function () {\r\n        return this;\r\n    };\r\n    BaseLayer.prototype.remove = function () {\r\n        var _canvas = this.getCanvas()._canvas;\r\n        Node.prototype.remove.call(this);\r\n        if (_canvas && _canvas.parentNode && Util._isInDocument(_canvas)) {\r\n            _canvas.parentNode.removeChild(_canvas);\r\n        }\r\n        return this;\r\n    };\r\n    BaseLayer.prototype.getStage = function () {\r\n        return this.parent;\r\n    };\r\n    BaseLayer.prototype.setSize = function (_a) {\r\n        var width = _a.width, height = _a.height;\r\n        this.canvas.setSize(width, height);\r\n        return this;\r\n    };\r\n    BaseLayer.prototype._toKonvaCanvas = function (config) {\r\n        config = config || {};\r\n        config.width = config.width || this.getWidth();\r\n        config.height = config.height || this.getHeight();\r\n        config.x = config.x !== undefined ? config.x : this.x();\r\n        config.y = config.y !== undefined ? config.y : this.y();\r\n        return Node.prototype._toKonvaCanvas.call(this, config);\r\n    };\r\n    BaseLayer.prototype._checkVisibility = function () {\r\n        var visible = this.visible();\r\n        if (visible) {\r\n            this.canvas._canvas.style.display = 'block';\r\n        }\r\n        else {\r\n            this.canvas._canvas.style.display = 'none';\r\n        }\r\n    };\r\n    BaseLayer.prototype._checkSmooth = function () {\r\n        this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();\r\n    };\r\n    /**\r\n     * get/set width of layer.getter return width of stage. setter doing nothing.\r\n     * if you want change width use `stage.width(value);`\r\n     * @name Konva.BaseLayer#width\r\n     * @method\r\n     * @returns {Number}\r\n     * @example\r\n     * var width = layer.width();\r\n     */\r\n    BaseLayer.prototype.getWidth = function () {\r\n        if (this.parent) {\r\n            return this.parent.width();\r\n        }\r\n    };\r\n    BaseLayer.prototype.setWidth = function () {\r\n        Util.warn('Can not change width of layer. Use \"stage.width(value)\" function instead.');\r\n    };\r\n    /**\r\n     * get/set height of layer.getter return height of stage. setter doing nothing.\r\n     * if you want change height use `stage.height(value);`\r\n     * @name Konva.BaseLayer#height\r\n     * @method\r\n     * @returns {Number}\r\n     * @example\r\n     * var height = layer.height();\r\n     */\r\n    BaseLayer.prototype.getHeight = function () {\r\n        if (this.parent) {\r\n            return this.parent.height();\r\n        }\r\n    };\r\n    BaseLayer.prototype.setHeight = function () {\r\n        Util.warn('Can not change height of layer. Use \"stage.height(value)\" function instead.');\r\n    };\r\n    BaseLayer.prototype.getIntersection = function (pos, selector) {\r\n        return null;\r\n    };\r\n    /**\r\n     * batch draw. this function will not do immediate draw\r\n     * but it will schedule drawing to next tick (requestAnimFrame)\r\n     * @method\r\n     * @name Konva.BaseLayer#batchDraw\r\n     * @return {Konva.Layer} this\r\n     */\r\n    BaseLayer.prototype.batchDraw = function () {\r\n        var _this = this;\r\n        if (!this._waitingForDraw) {\r\n            this._waitingForDraw = true;\r\n            Util.requestAnimFrame(function () {\r\n                _this.draw();\r\n                _this._waitingForDraw = false;\r\n            });\r\n        }\r\n        return this;\r\n    };\r\n    // the apply transform method is handled by the Layer and FastLayer class\r\n    // because it is up to the layer to decide if an absolute or relative transform\r\n    // should be used\r\n    BaseLayer.prototype._applyTransform = function (shape, context, top) {\r\n        var m = shape.getAbsoluteTransform(top).getMatrix();\r\n        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\r\n    };\r\n    return BaseLayer;\r\n}(Container));\r\nexport { BaseLayer };\r\nBaseLayer.prototype.nodeType = 'BaseLayer';\r\n/**\r\n * get/set imageSmoothingEnabled flag\r\n * For more info see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled\r\n * @name Konva.BaseLayer#imageSmoothingEnabled\r\n * @method\r\n * @param {Boolean} imageSmoothingEnabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get imageSmoothingEnabled flag\r\n * var imageSmoothingEnabled = layer.imageSmoothingEnabled();\r\n *\r\n * // disable clear before draw\r\n * layer.imageSmoothingEnabled(false);\r\n *\r\n * // enable clear before draw\r\n * layer.imageSmoothingEnabled(true);\r\n */\r\nFactory.addGetterSetter(BaseLayer, 'imageSmoothingEnabled', true);\r\n/**\r\n * get/set clearBeforeDraw flag which determines if the layer is cleared or not\r\n *  before drawing\r\n * @name Konva.BaseLayer#clearBeforeDraw\r\n * @method\r\n * @param {Boolean} clearBeforeDraw\r\n * @returns {Boolean}\r\n * @example\r\n * // get clearBeforeDraw flag\r\n * var clearBeforeDraw = layer.clearBeforeDraw();\r\n *\r\n * // disable clear before draw\r\n * layer.clearBeforeDraw(false);\r\n *\r\n * // enable clear before draw\r\n * layer.clearBeforeDraw(true);\r\n */\r\nFactory.addGetterSetter(BaseLayer, 'clearBeforeDraw', true);\r\nCollection.mapMethods(BaseLayer);\r\n"}
