{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Util, Collection } from './Util';\r\nimport { Factory } from './Factory';\r\nimport { Node } from './Node';\r\nimport { getNumberValidator, getNumberOrAutoValidator, getStringValidator, getBooleanValidator } from './Validators';\r\nimport { _registerNode } from './Global';\r\nimport * as PointerEvents from './PointerEvents';\r\nvar HAS_SHADOW = 'hasShadow';\r\nvar SHADOW_RGBA = 'shadowRGBA';\r\nvar patternImage = 'patternImage';\r\nvar linearGradient = 'linearGradient';\r\nvar radialGradient = 'radialGradient';\r\nvar dummyContext;\r\nfunction getDummyContext() {\r\n    if (dummyContext) {\r\n        return dummyContext;\r\n    }\r\n    dummyContext = Util.createCanvasElement().getContext('2d');\r\n    return dummyContext;\r\n}\r\nexport var shapes = {};\r\n// TODO: idea - use only \"remove\" (or destroy method)\r\n// how? on add, check that every inner shape has reference in konva store with color\r\n// on remove - clear that reference\r\n// the approach is good. But what if we want to cache the shape before we add it into the stage\r\n// what color to use for hit test?\r\nfunction _fillFunc(context) {\r\n    context.fill();\r\n}\r\nfunction _strokeFunc(context) {\r\n    context.stroke();\r\n}\r\nfunction _fillFuncHit(context) {\r\n    context.fill();\r\n}\r\nfunction _strokeFuncHit(context) {\r\n    context.stroke();\r\n}\r\nfunction _clearHasShadowCache() {\r\n    this._clearCache(HAS_SHADOW);\r\n}\r\nfunction _clearGetShadowRGBACache() {\r\n    this._clearCache(SHADOW_RGBA);\r\n}\r\nfunction _clearFillPatternCache() {\r\n    this._clearCache(patternImage);\r\n}\r\nfunction _clearLinearGradientCache() {\r\n    this._clearCache(linearGradient);\r\n}\r\nfunction _clearRadialGradientCache() {\r\n    this._clearCache(radialGradient);\r\n}\r\n/**\r\n * Shape constructor.  Shapes are primitive objects such as rectangles,\r\n *  circles, text, lines, etc.\r\n * @constructor\r\n * @memberof Konva\r\n * @augments Konva.Node\r\n * @param {Object} config\r\n * @@shapeParams\r\n * @@nodeParams\r\n * @example\r\n * var customShape = new Konva.Shape({\r\n *   x: 5,\r\n *   y: 10,\r\n *   fill: 'red',\r\n *   // a Konva.Canvas renderer is passed into the sceneFunc function\r\n *   sceneFunc (context, shape) {\r\n *     context.beginPath();\r\n *     context.moveTo(200, 50);\r\n *     context.lineTo(420, 80);\r\n *     context.quadraticCurveTo(300, 100, 260, 170);\r\n *     context.closePath();\r\n *     // Konva specific method\r\n *     context.fillStrokeShape(shape);\r\n *   }\r\n *});\r\n */\r\nvar Shape = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Shape, _super);\r\n    function Shape(config) {\r\n        var _this = _super.call(this, config) || this;\r\n        // set colorKey\r\n        var key;\r\n        while (true) {\r\n            key = Util.getRandomColor();\r\n            if (key && !(key in shapes)) {\r\n                break;\r\n            }\r\n        }\r\n        _this.colorKey = key;\r\n        shapes[key] = _this;\r\n        _this.on('shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);\r\n        _this.on('shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);\r\n        _this.on('fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva', _clearFillPatternCache);\r\n        _this.on('fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva', _clearLinearGradientCache);\r\n        _this.on('fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva', _clearRadialGradientCache);\r\n        return _this;\r\n    }\r\n    /**\r\n     * get canvas context tied to the layer\r\n     * @method\r\n     * @name Konva.Shape#getContext\r\n     * @returns {Konva.Context}\r\n     */\r\n    Shape.prototype.getContext = function () {\r\n        return this.getLayer().getContext();\r\n    };\r\n    /**\r\n     * get canvas renderer tied to the layer.  Note that this returns a canvas renderer, not a canvas element\r\n     * @method\r\n     * @name Konva.Shape#getCanvas\r\n     * @returns {Konva.Canvas}\r\n     */\r\n    Shape.prototype.getCanvas = function () {\r\n        return this.getLayer().getCanvas();\r\n    };\r\n    Shape.prototype.getSceneFunc = function () {\r\n        return this.attrs.sceneFunc || this['_sceneFunc'];\r\n    };\r\n    Shape.prototype.getHitFunc = function () {\r\n        return this.attrs.hitFunc || this['_hitFunc'];\r\n    };\r\n    /**\r\n     * returns whether or not a shadow will be rendered\r\n     * @method\r\n     * @name Konva.Shape#hasShadow\r\n     * @returns {Boolean}\r\n     */\r\n    Shape.prototype.hasShadow = function () {\r\n        return this._getCache(HAS_SHADOW, this._hasShadow);\r\n    };\r\n    Shape.prototype._hasShadow = function () {\r\n        return (this.shadowEnabled() &&\r\n            (this.shadowOpacity() !== 0 &&\r\n                !!(this.shadowColor() ||\r\n                    this.shadowBlur() ||\r\n                    this.shadowOffsetX() ||\r\n                    this.shadowOffsetY())));\r\n    };\r\n    Shape.prototype._getFillPattern = function () {\r\n        return this._getCache(patternImage, this.__getFillPattern);\r\n    };\r\n    Shape.prototype.__getFillPattern = function () {\r\n        if (this.fillPatternImage()) {\r\n            var ctx = getDummyContext();\r\n            return ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || 'repeat');\r\n        }\r\n    };\r\n    Shape.prototype._getLinearGradient = function () {\r\n        return this._getCache(linearGradient, this.__getLinearGradient);\r\n    };\r\n    Shape.prototype.__getLinearGradient = function () {\r\n        var colorStops = this.fillLinearGradientColorStops();\r\n        if (colorStops) {\r\n            var ctx = getDummyContext();\r\n            var start = this.fillLinearGradientStartPoint();\r\n            var end = this.fillLinearGradientEndPoint();\r\n            var grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\r\n            // build color stops\r\n            for (var n = 0; n < colorStops.length; n += 2) {\r\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\r\n            }\r\n            return grd;\r\n        }\r\n    };\r\n    Shape.prototype._getRadialGradient = function () {\r\n        return this._getCache(radialGradient, this.__getRadialGradient);\r\n    };\r\n    Shape.prototype.__getRadialGradient = function () {\r\n        var colorStops = this.fillRadialGradientColorStops();\r\n        if (colorStops) {\r\n            var ctx = getDummyContext();\r\n            var start = this.fillRadialGradientStartPoint();\r\n            var end = this.fillRadialGradientEndPoint();\r\n            var grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());\r\n            // build color stops\r\n            for (var n = 0; n < colorStops.length; n += 2) {\r\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\r\n            }\r\n            return grd;\r\n        }\r\n    };\r\n    Shape.prototype.getShadowRGBA = function () {\r\n        return this._getCache(SHADOW_RGBA, this._getShadowRGBA);\r\n    };\r\n    Shape.prototype._getShadowRGBA = function () {\r\n        if (this.hasShadow()) {\r\n            var rgba = Util.colorToRGBA(this.shadowColor());\r\n            return ('rgba(' +\r\n                rgba.r +\r\n                ',' +\r\n                rgba.g +\r\n                ',' +\r\n                rgba.b +\r\n                ',' +\r\n                rgba.a * (this.shadowOpacity() || 1) +\r\n                ')');\r\n        }\r\n    };\r\n    /**\r\n     * returns whether or not the shape will be filled\r\n     * @method\r\n     * @name Konva.Shape#hasFill\r\n     * @returns {Boolean}\r\n     */\r\n    Shape.prototype.hasFill = function () {\r\n        return !!(this.fill() ||\r\n            this.fillPatternImage() ||\r\n            this.fillLinearGradientColorStops() ||\r\n            this.fillRadialGradientColorStops());\r\n    };\r\n    /**\r\n     * returns whether or not the shape will be stroked\r\n     * @method\r\n     * @name Konva.Shape#hasStroke\r\n     * @returns {Boolean}\r\n     */\r\n    Shape.prototype.hasStroke = function () {\r\n        return (this.strokeEnabled() &&\r\n            this.strokeWidth() &&\r\n            !!(this.stroke() || this.strokeLinearGradientColorStops())\r\n        // this.getStrokeRadialGradientColorStops()\r\n        );\r\n    };\r\n    /**\r\n     * determines if point is in the shape, regardless if other shapes are on top of it.  Note: because\r\n     *  this method clears a temporary canvas and then redraws the shape, it performs very poorly if executed many times\r\n     *  consecutively.  Please use the {@link Konva.Stage#getIntersection} method if at all possible\r\n     *  because it performs much better\r\n     * @method\r\n     * @name Konva.Shape#intersects\r\n     * @param {Object} point\r\n     * @param {Number} point.x\r\n     * @param {Number} point.y\r\n     * @returns {Boolean}\r\n     */\r\n    Shape.prototype.intersects = function (point) {\r\n        var stage = this.getStage(), bufferHitCanvas = stage.bufferHitCanvas, p;\r\n        bufferHitCanvas.getContext().clear();\r\n        this.drawHit(bufferHitCanvas);\r\n        p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;\r\n        return p[3] > 0;\r\n    };\r\n    Shape.prototype.destroy = function () {\r\n        Node.prototype.destroy.call(this);\r\n        delete shapes[this.colorKey];\r\n        delete this.colorKey;\r\n        return this;\r\n    };\r\n    // why do we need buffer canvas?\r\n    // it give better result when a shape has\r\n    // stroke with fill and with some opacity\r\n    Shape.prototype._useBufferCanvas = function (caching) {\r\n        return !!((!caching || this.hasShadow()) &&\r\n            this.perfectDrawEnabled() &&\r\n            this.getAbsoluteOpacity() !== 1 &&\r\n            this.hasFill() &&\r\n            this.hasStroke() &&\r\n            this.getStage());\r\n    };\r\n    Shape.prototype.setStrokeHitEnabled = function (val) {\r\n        if (val) {\r\n            this.hitStrokeWidth('auto');\r\n        }\r\n        else {\r\n            this.hitStrokeWidth(0);\r\n        }\r\n    };\r\n    Shape.prototype.getStrokeHitEnabled = function () {\r\n        if (this.hitStrokeWidth() === 0) {\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    };\r\n    /**\r\n     * return self rectangle (x, y, width, height) of shape.\r\n     * This method are not taken into account transformation and styles.\r\n     * @method\r\n     * @name Konva.Shape#getSelfRect\r\n     * @returns {Object} rect with {x, y, width, height} properties\r\n     * @example\r\n     *\r\n     * rect.getSelfRect();  // return {x:0, y:0, width:rect.width(), height:rect.height()}\r\n     * circle.getSelfRect();  // return {x: - circle.width() / 2, y: - circle.height() / 2, width:circle.width(), height:circle.height()}\r\n     *\r\n     */\r\n    Shape.prototype.getSelfRect = function () {\r\n        var size = this.size();\r\n        return {\r\n            x: this._centroid ? Math.round(-size.width / 2) : 0,\r\n            y: this._centroid ? Math.round(-size.height / 2) : 0,\r\n            width: size.width,\r\n            height: size.height\r\n        };\r\n    };\r\n    Shape.prototype.getClientRect = function (attrs) {\r\n        attrs = attrs || {};\r\n        var skipTransform = attrs.skipTransform;\r\n        var relativeTo = attrs.relativeTo;\r\n        var fillRect = this.getSelfRect();\r\n        var applyStroke = !attrs.skipStroke && this.hasStroke();\r\n        var strokeWidth = (applyStroke && this.strokeWidth()) || 0;\r\n        var fillAndStrokeWidth = fillRect.width + strokeWidth;\r\n        var fillAndStrokeHeight = fillRect.height + strokeWidth;\r\n        var applyShadow = !attrs.skipShadow && this.hasShadow();\r\n        var shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;\r\n        var shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;\r\n        var preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);\r\n        var preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);\r\n        var blurRadius = (applyShadow && this.shadowBlur()) || 0;\r\n        var width = preWidth + blurRadius * 2;\r\n        var height = preHeight + blurRadius * 2;\r\n        // if stroke, for example = 3\r\n        // we need to set x to 1.5, but after Math.round it will be 2\r\n        // as we have additional offset we need to increase width and height by 1 pixel\r\n        var roundingOffset = 0;\r\n        if (Math.round(strokeWidth / 2) !== strokeWidth / 2) {\r\n            roundingOffset = 1;\r\n        }\r\n        var rect = {\r\n            width: width + roundingOffset,\r\n            height: height + roundingOffset,\r\n            x: -Math.round(strokeWidth / 2 + blurRadius) +\r\n                Math.min(shadowOffsetX, 0) +\r\n                fillRect.x,\r\n            y: -Math.round(strokeWidth / 2 + blurRadius) +\r\n                Math.min(shadowOffsetY, 0) +\r\n                fillRect.y\r\n        };\r\n        if (!skipTransform) {\r\n            return this._transformedRect(rect, relativeTo);\r\n        }\r\n        return rect;\r\n    };\r\n    Shape.prototype.drawScene = function (can, top, caching, skipBuffer) {\r\n        var layer = this.getLayer(), canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.sceneFunc(), hasShadow = this.hasShadow(), hasStroke = this.hasStroke(), stage, bufferCanvas, bufferContext;\r\n        if (!this.isVisible() && !caching) {\r\n            return this;\r\n        }\r\n        if (cachedCanvas) {\r\n            context.save();\r\n            layer._applyTransform(this, context, top);\r\n            this._drawCachedSceneCanvas(context);\r\n            context.restore();\r\n            return this;\r\n        }\r\n        if (!drawFunc) {\r\n            return this;\r\n        }\r\n        context.save();\r\n        // if buffer canvas is needed\r\n        if (this._useBufferCanvas(caching) && !skipBuffer) {\r\n            stage = this.getStage();\r\n            bufferCanvas = stage.bufferCanvas;\r\n            bufferContext = bufferCanvas.getContext();\r\n            bufferContext.clear();\r\n            bufferContext.save();\r\n            bufferContext._applyLineJoin(this);\r\n            // layer might be undefined if we are using cache before adding to layer\r\n            if (!caching) {\r\n                if (layer) {\r\n                    layer._applyTransform(this, bufferContext, top);\r\n                }\r\n                else {\r\n                    var m = this.getAbsoluteTransform(top).getMatrix();\r\n                    context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\r\n                }\r\n            }\r\n            drawFunc.call(this, bufferContext, this);\r\n            bufferContext.restore();\r\n            var ratio = bufferCanvas.pixelRatio;\r\n            if (hasShadow && !canvas.hitCanvas) {\r\n                context.save();\r\n                context._applyShadow(this);\r\n                context._applyOpacity(this);\r\n                context._applyGlobalCompositeOperation(this);\r\n                context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio, bufferCanvas.height / ratio);\r\n                context.restore();\r\n            }\r\n            else {\r\n                context._applyOpacity(this);\r\n                context._applyGlobalCompositeOperation(this);\r\n                context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio, bufferCanvas.height / ratio);\r\n            }\r\n        }\r\n        else {\r\n            // if buffer canvas is not needed\r\n            context._applyLineJoin(this);\r\n            // layer might be undefined if we are using cache before adding to layer\r\n            if (!caching) {\r\n                if (layer) {\r\n                    layer._applyTransform(this, context, top);\r\n                }\r\n                else {\r\n                    var o = this.getAbsoluteTransform(top).getMatrix();\r\n                    context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\r\n                }\r\n            }\r\n            if (hasShadow && hasStroke && !canvas.hitCanvas) {\r\n                context.save();\r\n                // apply shadow\r\n                if (!caching) {\r\n                    context._applyOpacity(this);\r\n                    context._applyGlobalCompositeOperation(this);\r\n                }\r\n                context._applyShadow(this);\r\n                drawFunc.call(this, context, this);\r\n                context.restore();\r\n                // if shape has stroke we need to redraw shape\r\n                // otherwise we will see a shadow under stroke (and over fill)\r\n                // but I think this is unexpected behavior\r\n                if (this.hasFill() && this.shadowForStrokeEnabled()) {\r\n                    drawFunc.call(this, context, this);\r\n                }\r\n            }\r\n            else if (hasShadow && !canvas.hitCanvas) {\r\n                context.save();\r\n                if (!caching) {\r\n                    context._applyOpacity(this);\r\n                    context._applyGlobalCompositeOperation(this);\r\n                }\r\n                context._applyShadow(this);\r\n                drawFunc.call(this, context, this);\r\n                context.restore();\r\n            }\r\n            else {\r\n                if (!caching) {\r\n                    context._applyOpacity(this);\r\n                    context._applyGlobalCompositeOperation(this);\r\n                }\r\n                drawFunc.call(this, context, this);\r\n            }\r\n        }\r\n        context.restore();\r\n        return this;\r\n    };\r\n    Shape.prototype.drawHit = function (can, top, caching) {\r\n        var layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;\r\n        if (!this.colorKey) {\r\n            Util.warn('Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. See the shape in logs above. If you want to reuse shape you should call remove() instead of destroy()');\r\n        }\r\n        if (!this.shouldDrawHit() && !caching) {\r\n            return this;\r\n        }\r\n        if (cachedHitCanvas) {\r\n            context.save();\r\n            layer._applyTransform(this, context, top);\r\n            this._drawCachedHitCanvas(context);\r\n            context.restore();\r\n            return this;\r\n        }\r\n        if (!drawFunc) {\r\n            return this;\r\n        }\r\n        context.save();\r\n        context._applyLineJoin(this);\r\n        if (!caching) {\r\n            if (layer) {\r\n                layer._applyTransform(this, context, top);\r\n            }\r\n            else {\r\n                var o = this.getAbsoluteTransform(top).getMatrix();\r\n                context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\r\n            }\r\n        }\r\n        drawFunc.call(this, context, this);\r\n        context.restore();\r\n        return this;\r\n    };\r\n    /**\r\n     * draw hit graph using the cached scene canvas\r\n     * @method\r\n     * @name Konva.Shape#drawHitFromCache\r\n     * @param {Integer} alphaThreshold alpha channel threshold that determines whether or not\r\n     *  a pixel should be drawn onto the hit graph.  Must be a value between 0 and 255.\r\n     *  The default is 0\r\n     * @returns {Konva.Shape}\r\n     * @example\r\n     * shape.cache();\r\n     * shape.drawHitFromCache();\r\n     */\r\n    Shape.prototype.drawHitFromCache = function (alphaThreshold) {\r\n        if (alphaThreshold === void 0) { alphaThreshold = 0; }\r\n        var cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight(), hitImageData, hitData, len, rgbColorKey, i, alpha;\r\n        hitContext.clear();\r\n        hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);\r\n        try {\r\n            hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);\r\n            hitData = hitImageData.data;\r\n            len = hitData.length;\r\n            rgbColorKey = Util._hexToRgb(this.colorKey);\r\n            // replace non transparent pixels with color key\r\n            for (i = 0; i < len; i += 4) {\r\n                alpha = hitData[i + 3];\r\n                if (alpha > alphaThreshold) {\r\n                    hitData[i] = rgbColorKey.r;\r\n                    hitData[i + 1] = rgbColorKey.g;\r\n                    hitData[i + 2] = rgbColorKey.b;\r\n                    hitData[i + 3] = 255;\r\n                }\r\n                else {\r\n                    hitData[i + 3] = 0;\r\n                }\r\n            }\r\n            hitContext.putImageData(hitImageData, 0, 0);\r\n        }\r\n        catch (e) {\r\n            Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);\r\n        }\r\n        return this;\r\n    };\r\n    Shape.prototype.hasPointerCapture = function (pointerId) {\r\n        return PointerEvents.hasPointerCapture(pointerId, this);\r\n    };\r\n    Shape.prototype.setPointerCapture = function (pointerId) {\r\n        PointerEvents.setPointerCapture(pointerId, this);\r\n    };\r\n    Shape.prototype.releaseCapture = function (pointerId) {\r\n        PointerEvents.releaseCapture(pointerId, this);\r\n    };\r\n    return Shape;\r\n}(Node));\r\nexport { Shape };\r\nShape.prototype._fillFunc = _fillFunc;\r\nShape.prototype._strokeFunc = _strokeFunc;\r\nShape.prototype._fillFuncHit = _fillFuncHit;\r\nShape.prototype._strokeFuncHit = _strokeFuncHit;\r\nShape.prototype._centroid = false;\r\nShape.prototype.nodeType = 'Shape';\r\n_registerNode(Shape);\r\n// add getters and setters\r\nFactory.addGetterSetter(Shape, 'stroke', undefined, getStringValidator());\r\n/**\r\n * get/set stroke color\r\n * @name Konva.Shape#stroke\r\n * @method\r\n * @param {String} color\r\n * @returns {String}\r\n * @example\r\n * // get stroke color\r\n * var stroke = shape.stroke();\r\n *\r\n * // set stroke color with color string\r\n * shape.stroke('green');\r\n *\r\n * // set stroke color with hex\r\n * shape.stroke('#00ff00');\r\n *\r\n * // set stroke color with rgb\r\n * shape.stroke('rgb(0,255,0)');\r\n *\r\n * // set stroke color with rgba and make it 50% opaque\r\n * shape.stroke('rgba(0,255,0,0.5');\r\n */\r\nFactory.addGetterSetter(Shape, 'strokeWidth', 2, getNumberValidator());\r\n/**\r\n * get/set stroke width\r\n * @name Konva.Shape#strokeWidth\r\n * @method\r\n * @param {Number} strokeWidth\r\n * @returns {Number}\r\n * @example\r\n * // get stroke width\r\n * var strokeWidth = shape.strokeWidth();\r\n *\r\n * // set stroke width\r\n * shape.strokeWidth(10);\r\n */\r\nFactory.addGetterSetter(Shape, 'hitStrokeWidth', 'auto', getNumberOrAutoValidator());\r\n/**\r\n * get/set stroke width for hit detection. Default value is \"auto\", it means it will be equals to strokeWidth\r\n * @name Konva.Shape#hitStrokeWidth\r\n * @method\r\n * @param {Number} hitStrokeWidth\r\n * @returns {Number}\r\n * @example\r\n * // get stroke width\r\n * var hitStrokeWidth = shape.hitStrokeWidth();\r\n *\r\n * // set hit stroke width\r\n * shape.hitStrokeWidth(20);\r\n * // set hit stroke width always equals to scene stroke width\r\n * shape.hitStrokeWidth('auto');\r\n */\r\n// TODO: probably we should deprecate it\r\nFactory.addGetterSetter(Shape, 'strokeHitEnabled', true, getBooleanValidator());\r\n/**\r\n * get/set strokeHitEnabled property. Useful for performance optimization.\r\n * You may set `shape.strokeHitEnabled(false)`. In this case stroke will be no draw on hit canvas, so hit area\r\n * of shape will be decreased (by lineWidth / 2). Remember that non closed line with `strokeHitEnabled = false`\r\n * will be not drawn on hit canvas, that is mean line will no trigger pointer events (like mouseover)\r\n * Default value is true.\r\n * @name Konva.Shape#strokeHitEnabled\r\n * @method\r\n * @param {Boolean} strokeHitEnabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get strokeHitEnabled\r\n * var strokeHitEnabled = shape.strokeHitEnabled();\r\n *\r\n * // set strokeHitEnabled\r\n * shape.strokeHitEnabled();\r\n */\r\nFactory.addGetterSetter(Shape, 'perfectDrawEnabled', true, getBooleanValidator());\r\n/**\r\n * get/set perfectDrawEnabled. If a shape has fill, stroke and opacity you may set `perfectDrawEnabled` to false to improve performance.\r\n * See http://konvajs.org/docs/performance/Disable_Perfect_Draw.html for more information.\r\n * Default value is true\r\n * @name Konva.Shape#perfectDrawEnabled\r\n * @method\r\n * @param {Boolean} perfectDrawEnabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get perfectDrawEnabled\r\n * var perfectDrawEnabled = shape.perfectDrawEnabled();\r\n *\r\n * // set perfectDrawEnabled\r\n * shape.perfectDrawEnabled();\r\n */\r\nFactory.addGetterSetter(Shape, 'shadowForStrokeEnabled', true, getBooleanValidator());\r\n/**\r\n * get/set shadowForStrokeEnabled. Useful for performance optimization.\r\n * You may set `shape.shadowForStrokeEnabled(false)`. In this case stroke will no effect shadow.\r\n * Remember if you set `shadowForStrokeEnabled = false` for non closed line - that line will have no shadow!.\r\n * Default value is true\r\n * @name Konva.Shape#shadowForStrokeEnabled\r\n * @method\r\n * @param {Boolean} shadowForStrokeEnabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get shadowForStrokeEnabled\r\n * var shadowForStrokeEnabled = shape.shadowForStrokeEnabled();\r\n *\r\n * // set shadowForStrokeEnabled\r\n * shape.shadowForStrokeEnabled();\r\n */\r\nFactory.addGetterSetter(Shape, 'lineJoin');\r\n/**\r\n * get/set line join.  Can be miter, round, or bevel.  The\r\n *  default is miter\r\n * @name Konva.Shape#lineJoin\r\n * @method\r\n * @param {String} lineJoin\r\n * @returns {String}\r\n * @example\r\n * // get line join\r\n * var lineJoin = shape.lineJoin();\r\n *\r\n * // set line join\r\n * shape.lineJoin('round');\r\n */\r\nFactory.addGetterSetter(Shape, 'lineCap');\r\n/**\r\n * get/set line cap.  Can be butt, round, or square\r\n * @name Konva.Shape#lineCap\r\n * @method\r\n * @param {String} lineCap\r\n * @returns {String}\r\n * @example\r\n * // get line cap\r\n * var lineCap = shape.lineCap();\r\n *\r\n * // set line cap\r\n * shape.lineCap('round');\r\n */\r\nFactory.addGetterSetter(Shape, 'sceneFunc');\r\n/**\r\n * get/set scene draw function. That function is used to draw the shape on a canvas.\r\n * Also that function will be used to draw hit area of the shape, in case if hitFunc is not defined.\r\n * @name Konva.Shape#sceneFunc\r\n * @method\r\n * @param {Function} drawFunc drawing function\r\n * @returns {Function}\r\n * @example\r\n * // get scene draw function\r\n * var sceneFunc = shape.sceneFunc();\r\n *\r\n * // set scene draw function\r\n * shape.sceneFunc(function(context, shape) {\r\n *   context.beginPath();\r\n *   context.rect(0, 0, shape.width(), shape.height());\r\n *   context.closePath();\r\n *   // important Konva method that fill and stroke shape from its properties\r\n *   // like stroke and fill\r\n *   context.fillStrokeShape(shape);\r\n * });\r\n */\r\nFactory.addGetterSetter(Shape, 'hitFunc');\r\n/**\r\n * get/set hit draw function. That function is used to draw custom hit area of a shape.\r\n * @name Konva.Shape#hitFunc\r\n * @method\r\n * @param {Function} drawFunc drawing function\r\n * @returns {Function}\r\n * @example\r\n * // get hit draw function\r\n * var hitFunc = shape.hitFunc();\r\n *\r\n * // set hit draw function\r\n * shape.hitFunc(function(context) {\r\n *   context.beginPath();\r\n *   context.rect(0, 0, shape.width(), shape.height());\r\n *   context.closePath();\r\n *   // important Konva method that fill and stroke shape from its properties\r\n *   context.fillStrokeShape(shape);\r\n * });\r\n */\r\nFactory.addGetterSetter(Shape, 'dash');\r\n/**\r\n * get/set dash array for stroke.\r\n * @name Konva.Shape#dash\r\n * @method\r\n * @param {Array} dash\r\n * @returns {Array}\r\n * @example\r\n *  // apply dashed stroke that is 10px long and 5 pixels apart\r\n *  line.dash([10, 5]);\r\n *  // apply dashed stroke that is made up of alternating dashed\r\n *  // lines that are 10px long and 20px apart, and dots that have\r\n *  // a radius of 5px and are 20px apart\r\n *  line.dash([10, 20, 0.001, 20]);\r\n */\r\nFactory.addGetterSetter(Shape, 'dashOffset', 0, getNumberValidator());\r\n/**\r\n * get/set dash offset for stroke.\r\n * @name Konva.Shape#dash\r\n * @method\r\n * @param {Number} dash offset\r\n * @returns {Number}\r\n * @example\r\n *  // apply dashed stroke that is 10px long and 5 pixels apart with an offset of 5px\r\n *  line.dash([10, 5]);\r\n *  line.dashOffset(5);\r\n */\r\nFactory.addGetterSetter(Shape, 'shadowColor', undefined, getStringValidator());\r\n/**\r\n * get/set shadow color\r\n * @name Konva.Shape#shadowColor\r\n * @method\r\n * @param {String} color\r\n * @returns {String}\r\n * @example\r\n * // get shadow color\r\n * var shadow = shape.shadowColor();\r\n *\r\n * // set shadow color with color string\r\n * shape.shadowColor('green');\r\n *\r\n * // set shadow color with hex\r\n * shape.shadowColor('#00ff00');\r\n *\r\n * // set shadow color with rgb\r\n * shape.shadowColor('rgb(0,255,0)');\r\n *\r\n * // set shadow color with rgba and make it 50% opaque\r\n * shape.shadowColor('rgba(0,255,0,0.5');\r\n */\r\nFactory.addGetterSetter(Shape, 'shadowBlur', 0, getNumberValidator());\r\n/**\r\n * get/set shadow blur\r\n * @name Konva.Shape#shadowBlur\r\n * @method\r\n * @param {Number} blur\r\n * @returns {Number}\r\n * @example\r\n * // get shadow blur\r\n * var shadowBlur = shape.shadowBlur();\r\n *\r\n * // set shadow blur\r\n * shape.shadowBlur(10);\r\n */\r\nFactory.addGetterSetter(Shape, 'shadowOpacity', 1, getNumberValidator());\r\n/**\r\n * get/set shadow opacity.  must be a value between 0 and 1\r\n * @name Konva.Shape#shadowOpacity\r\n * @method\r\n * @param {Number} opacity\r\n * @returns {Number}\r\n * @example\r\n * // get shadow opacity\r\n * var shadowOpacity = shape.shadowOpacity();\r\n *\r\n * // set shadow opacity\r\n * shape.shadowOpacity(0.5);\r\n */\r\nFactory.addComponentsGetterSetter(Shape, 'shadowOffset', ['x', 'y']);\r\n/**\r\n * get/set shadow offset\r\n * @name Konva.Shape#shadowOffset\r\n * @method\r\n * @param {Object} offset\r\n * @param {Number} offset.x\r\n * @param {Number} offset.y\r\n * @returns {Object}\r\n * @example\r\n * // get shadow offset\r\n * var shadowOffset = shape.shadowOffset();\r\n *\r\n * // set shadow offset\r\n * shape.shadowOffset({\r\n *   x: 20,\r\n *   y: 10\r\n * });\r\n */\r\nFactory.addGetterSetter(Shape, 'shadowOffsetX', 0, getNumberValidator());\r\n/**\r\n * get/set shadow offset x\r\n * @name Konva.Shape#shadowOffsetX\r\n * @method\r\n * @param {Number} x\r\n * @returns {Number}\r\n * @example\r\n * // get shadow offset x\r\n * var shadowOffsetX = shape.shadowOffsetX();\r\n *\r\n * // set shadow offset x\r\n * shape.shadowOffsetX(5);\r\n */\r\nFactory.addGetterSetter(Shape, 'shadowOffsetY', 0, getNumberValidator());\r\n/**\r\n * get/set shadow offset y\r\n * @name Konva.Shape#shadowOffsetY\r\n * @method\r\n * @param {Number} y\r\n * @returns {Number}\r\n * @example\r\n * // get shadow offset y\r\n * var shadowOffsetY = shape.shadowOffsetY();\r\n *\r\n * // set shadow offset y\r\n * shape.shadowOffsetY(5);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillPatternImage');\r\n/**\r\n * get/set fill pattern image\r\n * @name Konva.Shape#fillPatternImage\r\n * @method\r\n * @param {Image} image object\r\n * @returns {Image}\r\n * @example\r\n * // get fill pattern image\r\n * var fillPatternImage = shape.fillPatternImage();\r\n *\r\n * // set fill pattern image\r\n * var imageObj = new Image();\r\n * imageObj.onload = function() {\r\n *   shape.fillPatternImage(imageObj);\r\n * };\r\n * imageObj.src = 'path/to/image/jpg';\r\n */\r\nFactory.addGetterSetter(Shape, 'fill', undefined, getStringValidator());\r\n/**\r\n * get/set fill color\r\n * @name Konva.Shape#fill\r\n * @method\r\n * @param {String} color\r\n * @returns {String}\r\n * @example\r\n * // get fill color\r\n * var fill = shape.fill();\r\n *\r\n * // set fill color with color string\r\n * shape.fill('green');\r\n *\r\n * // set fill color with hex\r\n * shape.fill('#00ff00');\r\n *\r\n * // set fill color with rgb\r\n * shape.fill('rgb(0,255,0)');\r\n *\r\n * // set fill color with rgba and make it 50% opaque\r\n * shape.fill('rgba(0,255,0,0.5');\r\n *\r\n * // shape without fill\r\n * shape.fill(null);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillPatternX', 0, getNumberValidator());\r\n/**\r\n * get/set fill pattern x\r\n * @name Konva.Shape#fillPatternX\r\n * @method\r\n * @param {Number} x\r\n * @returns {Number}\r\n * @example\r\n * // get fill pattern x\r\n * var fillPatternX = shape.fillPatternX();\r\n * // set fill pattern x\r\n * shape.fillPatternX(20);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillPatternY', 0, getNumberValidator());\r\n/**\r\n * get/set fill pattern y\r\n * @name Konva.Shape#fillPatternY\r\n * @method\r\n * @param {Number} y\r\n * @returns {Number}\r\n * @example\r\n * // get fill pattern y\r\n * var fillPatternY = shape.fillPatternY();\r\n * // set fill pattern y\r\n * shape.fillPatternY(20);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillLinearGradientColorStops');\r\n/**\r\n * get/set fill linear gradient color stops\r\n * @name Konva.Shape#fillLinearGradientColorStops\r\n * @method\r\n * @param {Array} colorStops\r\n * @returns {Array} colorStops\r\n * @example\r\n * // get fill linear gradient color stops\r\n * var colorStops = shape.fillLinearGradientColorStops();\r\n *\r\n * // create a linear gradient that starts with red, changes to blue\r\n * // halfway through, and then changes to green\r\n * shape.fillLinearGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');\r\n */\r\nFactory.addGetterSetter(Shape, 'strokeLinearGradientColorStops');\r\n/**\r\n * get/set stroke linear gradient color stops\r\n * @name Konva.Shape#strokeLinearGradientColorStops\r\n * @method\r\n * @param {Array} colorStops\r\n * @returns {Array} colorStops\r\n * @example\r\n * // get stroke linear gradient color stops\r\n * var colorStops = shape.strokeLinearGradientColorStops();\r\n *\r\n * // create a linear gradient that starts with red, changes to blue\r\n * // halfway through, and then changes to green\r\n * shape.strokeLinearGradientColorStops([0, 'red', 0.5, 'blue', 1, 'green']);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartRadius', 0);\r\n/**\r\n * get/set fill radial gradient start radius\r\n * @name Konva.Shape#fillRadialGradientStartRadius\r\n * @method\r\n * @param {Number} radius\r\n * @returns {Number}\r\n * @example\r\n * // get radial gradient start radius\r\n * var startRadius = shape.fillRadialGradientStartRadius();\r\n *\r\n * // set radial gradient start radius\r\n * shape.fillRadialGradientStartRadius(0);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndRadius', 0);\r\n/**\r\n * get/set fill radial gradient end radius\r\n * @name Konva.Shape#fillRadialGradientEndRadius\r\n * @method\r\n * @param {Number} radius\r\n * @returns {Number}\r\n * @example\r\n * // get radial gradient end radius\r\n * var endRadius = shape.fillRadialGradientEndRadius();\r\n *\r\n * // set radial gradient end radius\r\n * shape.fillRadialGradientEndRadius(100);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillRadialGradientColorStops');\r\n/**\r\n * get/set fill radial gradient color stops\r\n * @name Konva.Shape#fillRadialGradientColorStops\r\n * @method\r\n * @param {Number} colorStops\r\n * @returns {Array}\r\n * @example\r\n * // get fill radial gradient color stops\r\n * var colorStops = shape.fillRadialGradientColorStops();\r\n *\r\n * // create a radial gradient that starts with red, changes to blue\r\n * // halfway through, and then changes to green\r\n * shape.fillRadialGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');\r\n */\r\nFactory.addGetterSetter(Shape, 'fillPatternRepeat', 'repeat');\r\n/**\r\n * get/set fill pattern repeat.  Can be 'repeat', 'repeat-x', 'repeat-y', or 'no-repeat'.  The default is 'repeat'\r\n * @name Konva.Shape#fillPatternRepeat\r\n * @method\r\n * @param {String} repeat\r\n * @returns {String}\r\n * @example\r\n * // get fill pattern repeat\r\n * var repeat = shape.fillPatternRepeat();\r\n *\r\n * // repeat pattern in x direction only\r\n * shape.fillPatternRepeat('repeat-x');\r\n *\r\n * // do not repeat the pattern\r\n * shape.fillPatternRepeat('no-repeat');\r\n */\r\nFactory.addGetterSetter(Shape, 'fillEnabled', true);\r\n/**\r\n * get/set fill enabled flag\r\n * @name Konva.Shape#fillEnabled\r\n * @method\r\n * @param {Boolean} enabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get fill enabled flag\r\n * var fillEnabled = shape.fillEnabled();\r\n *\r\n * // disable fill\r\n * shape.fillEnabled(false);\r\n *\r\n * // enable fill\r\n * shape.fillEnabled(true);\r\n */\r\nFactory.addGetterSetter(Shape, 'strokeEnabled', true);\r\n/**\r\n * get/set stroke enabled flag\r\n * @name Konva.Shape#strokeEnabled\r\n * @method\r\n * @param {Boolean} enabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get stroke enabled flag\r\n * var strokeEnabled = shape.strokeEnabled();\r\n *\r\n * // disable stroke\r\n * shape.strokeEnabled(false);\r\n *\r\n * // enable stroke\r\n * shape.strokeEnabled(true);\r\n */\r\nFactory.addGetterSetter(Shape, 'shadowEnabled', true);\r\n/**\r\n * get/set shadow enabled flag\r\n * @name Konva.Shape#shadowEnabled\r\n * @method\r\n * @param {Boolean} enabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get shadow enabled flag\r\n * var shadowEnabled = shape.shadowEnabled();\r\n *\r\n * // disable shadow\r\n * shape.shadowEnabled(false);\r\n *\r\n * // enable shadow\r\n * shape.shadowEnabled(true);\r\n */\r\nFactory.addGetterSetter(Shape, 'dashEnabled', true);\r\n/**\r\n * get/set dash enabled flag\r\n * @name Konva.Shape#dashEnabled\r\n * @method\r\n * @param {Boolean} enabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get dash enabled flag\r\n * var dashEnabled = shape.dashEnabled();\r\n *\r\n * // disable dash\r\n * shape.dashEnabled(false);\r\n *\r\n * // enable dash\r\n * shape.dashEnabled(true);\r\n */\r\nFactory.addGetterSetter(Shape, 'strokeScaleEnabled', true);\r\n/**\r\n * get/set strokeScale enabled flag\r\n * @name Konva.Shape#strokeScaleEnabled\r\n * @method\r\n * @param {Boolean} enabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get stroke scale enabled flag\r\n * var strokeScaleEnabled = shape.strokeScaleEnabled();\r\n *\r\n * // disable stroke scale\r\n * shape.strokeScaleEnabled(false);\r\n *\r\n * // enable stroke scale\r\n * shape.strokeScaleEnabled(true);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillPriority', 'color');\r\n/**\r\n * get/set fill priority.  can be color, pattern, linear-gradient, or radial-gradient.  The default is color.\r\n *   This is handy if you want to toggle between different fill types.\r\n * @name Konva.Shape#fillPriority\r\n * @method\r\n * @param {String} priority\r\n * @returns {String}\r\n * @example\r\n * // get fill priority\r\n * var fillPriority = shape.fillPriority();\r\n *\r\n * // set fill priority\r\n * shape.fillPriority('linear-gradient');\r\n */\r\nFactory.addComponentsGetterSetter(Shape, 'fillPatternOffset', ['x', 'y']);\r\n/**\r\n * get/set fill pattern offset\r\n * @name Konva.Shape#fillPatternOffset\r\n * @method\r\n * @param {Object} offset\r\n * @param {Number} offset.x\r\n * @param {Number} offset.y\r\n * @returns {Object}\r\n * @example\r\n * // get fill pattern offset\r\n * var patternOffset = shape.fillPatternOffset();\r\n *\r\n * // set fill pattern offset\r\n * shape.fillPatternOffset({\r\n *   x: 20,\r\n *   y: 10\r\n * });\r\n */\r\nFactory.addGetterSetter(Shape, 'fillPatternOffsetX', 0, getNumberValidator());\r\n/**\r\n * get/set fill pattern offset x\r\n * @name Konva.Shape#fillPatternOffsetX\r\n * @method\r\n * @param {Number} x\r\n * @returns {Number}\r\n * @example\r\n * // get fill pattern offset x\r\n * var patternOffsetX = shape.fillPatternOffsetX();\r\n *\r\n * // set fill pattern offset x\r\n * shape.fillPatternOffsetX(20);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillPatternOffsetY', 0, getNumberValidator());\r\n/**\r\n * get/set fill pattern offset y\r\n * @name Konva.Shape#fillPatternOffsetY\r\n * @method\r\n * @param {Number} y\r\n * @returns {Number}\r\n * @example\r\n * // get fill pattern offset y\r\n * var patternOffsetY = shape.fillPatternOffsetY();\r\n *\r\n * // set fill pattern offset y\r\n * shape.fillPatternOffsetY(10);\r\n */\r\nFactory.addComponentsGetterSetter(Shape, 'fillPatternScale', ['x', 'y']);\r\n/**\r\n * get/set fill pattern scale\r\n * @name Konva.Shape#fillPatternScale\r\n * @method\r\n * @param {Object} scale\r\n * @param {Number} scale.x\r\n * @param {Number} scale.y\r\n * @returns {Object}\r\n * @example\r\n * // get fill pattern scale\r\n * var patternScale = shape.fillPatternScale();\r\n *\r\n * // set fill pattern scale\r\n * shape.fillPatternScale({\r\n *   x: 2,\r\n *   y: 2\r\n * });\r\n */\r\nFactory.addGetterSetter(Shape, 'fillPatternScaleX', 1, getNumberValidator());\r\n/**\r\n * get/set fill pattern scale x\r\n * @name Konva.Shape#fillPatternScaleX\r\n * @method\r\n * @param {Number} x\r\n * @returns {Number}\r\n * @example\r\n * // get fill pattern scale x\r\n * var patternScaleX = shape.fillPatternScaleX();\r\n *\r\n * // set fill pattern scale x\r\n * shape.fillPatternScaleX(2);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillPatternScaleY', 1, getNumberValidator());\r\n/**\r\n * get/set fill pattern scale y\r\n * @name Konva.Shape#fillPatternScaleY\r\n * @method\r\n * @param {Number} y\r\n * @returns {Number}\r\n * @example\r\n * // get fill pattern scale y\r\n * var patternScaleY = shape.fillPatternScaleY();\r\n *\r\n * // set fill pattern scale y\r\n * shape.fillPatternScaleY(2);\r\n */\r\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientStartPoint', [\r\n    'x',\r\n    'y'\r\n]);\r\n/**\r\n * get/set fill linear gradient start point\r\n * @name Konva.Shape#fillLinearGradientStartPoint\r\n * @method\r\n * @param {Object} startPoint\r\n * @param {Number} startPoint.x\r\n * @param {Number} startPoint.y\r\n * @returns {Object}\r\n * @example\r\n * // get fill linear gradient start point\r\n * var startPoint = shape.fillLinearGradientStartPoint();\r\n *\r\n * // set fill linear gradient start point\r\n * shape.fillLinearGradientStartPoint({\r\n *   x: 20,\r\n *   y: 10\r\n * });\r\n */\r\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientStartPoint', [\r\n    'x',\r\n    'y'\r\n]);\r\n/**\r\n * get/set stroke linear gradient start point\r\n * @name Konva.Shape#strokeLinearGradientStartPoint\r\n * @method\r\n * @param {Object} startPoint\r\n * @param {Number} startPoint.x\r\n * @param {Number} startPoint.y\r\n * @returns {Object}\r\n * @example\r\n * // get stroke linear gradient start point\r\n * var startPoint = shape.strokeLinearGradientStartPoint();\r\n *\r\n * // set stroke linear gradient start point\r\n * shape.strokeLinearGradientStartPoint({\r\n *   x: 20,\r\n *   y: 10\r\n * });\r\n */\r\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointX', 0);\r\n/**\r\n * get/set fill linear gradient start point x\r\n * @name Konva.Shape#fillLinearGradientStartPointX\r\n * @method\r\n * @param {Number} x\r\n * @returns {Number}\r\n * @example\r\n * // get fill linear gradient start point x\r\n * var startPointX = shape.fillLinearGradientStartPointX();\r\n *\r\n * // set fill linear gradient start point x\r\n * shape.fillLinearGradientStartPointX(20);\r\n */\r\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointX', 0);\r\n/**\r\n * get/set stroke linear gradient start point x\r\n * @name Konva.Shape#linearLinearGradientStartPointX\r\n * @method\r\n * @param {Number} x\r\n * @returns {Number}\r\n * @example\r\n * // get stroke linear gradient start point x\r\n * var startPointX = shape.strokeLinearGradientStartPointX();\r\n *\r\n * // set stroke linear gradient start point x\r\n * shape.strokeLinearGradientStartPointX(20);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointY', 0);\r\n/**\r\n * get/set fill linear gradient start point y\r\n * @name Konva.Shape#fillLinearGradientStartPointY\r\n * @method\r\n * @param {Number} y\r\n * @returns {Number}\r\n * @example\r\n * // get fill linear gradient start point y\r\n * var startPointY = shape.fillLinearGradientStartPointY();\r\n *\r\n * // set fill linear gradient start point y\r\n * shape.fillLinearGradientStartPointY(20);\r\n */\r\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointY', 0);\r\n/**\r\n * get/set stroke linear gradient start point y\r\n * @name Konva.Shape#strokeLinearGradientStartPointY\r\n * @method\r\n * @param {Number} y\r\n * @returns {Number}\r\n * @example\r\n * // get stroke linear gradient start point y\r\n * var startPointY = shape.strokeLinearGradientStartPointY();\r\n *\r\n * // set stroke linear gradient start point y\r\n * shape.strokeLinearGradientStartPointY(20);\r\n */\r\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientEndPoint', [\r\n    'x',\r\n    'y'\r\n]);\r\n/**\r\n * get/set fill linear gradient end point\r\n * @name Konva.Shape#fillLinearGradientEndPoint\r\n * @method\r\n * @param {Object} endPoint\r\n * @param {Number} endPoint.x\r\n * @param {Number} endPoint.y\r\n * @returns {Object}\r\n * @example\r\n * // get fill linear gradient end point\r\n * var endPoint = shape.fillLinearGradientEndPoint();\r\n *\r\n * // set fill linear gradient end point\r\n * shape.fillLinearGradientEndPoint({\r\n *   x: 20,\r\n *   y: 10\r\n * });\r\n */\r\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientEndPoint', [\r\n    'x',\r\n    'y'\r\n]);\r\n/**\r\n * get/set stroke linear gradient end point\r\n * @name Konva.Shape#strokeLinearGradientEndPoint\r\n * @method\r\n * @param {Object} endPoint\r\n * @param {Number} endPoint.x\r\n * @param {Number} endPoint.y\r\n * @returns {Object}\r\n * @example\r\n * // get stroke linear gradient end point\r\n * var endPoint = shape.strokeLinearGradientEndPoint();\r\n *\r\n * // set stroke linear gradient end point\r\n * shape.strokeLinearGradientEndPoint({\r\n *   x: 20,\r\n *   y: 10\r\n * });\r\n */\r\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointX', 0);\r\n/**\r\n * get/set fill linear gradient end point x\r\n * @name Konva.Shape#fillLinearGradientEndPointX\r\n * @method\r\n * @param {Number} x\r\n * @returns {Number}\r\n * @example\r\n * // get fill linear gradient end point x\r\n * var endPointX = shape.fillLinearGradientEndPointX();\r\n *\r\n * // set fill linear gradient end point x\r\n * shape.fillLinearGradientEndPointX(20);\r\n */\r\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointX', 0);\r\n/**\r\n * get/set fill linear gradient end point x\r\n * @name Konva.Shape#strokeLinearGradientEndPointX\r\n * @method\r\n * @param {Number} x\r\n * @returns {Number}\r\n * @example\r\n * // get stroke linear gradient end point x\r\n * var endPointX = shape.strokeLinearGradientEndPointX();\r\n *\r\n * // set stroke linear gradient end point x\r\n * shape.strokeLinearGradientEndPointX(20);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointY', 0);\r\n/**\r\n * get/set fill linear gradient end point y\r\n * @name Konva.Shape#fillLinearGradientEndPointY\r\n * @method\r\n * @param {Number} y\r\n * @returns {Number}\r\n * @example\r\n * // get fill linear gradient end point y\r\n * var endPointY = shape.fillLinearGradientEndPointY();\r\n *\r\n * // set fill linear gradient end point y\r\n * shape.fillLinearGradientEndPointY(20);\r\n */\r\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointY', 0);\r\n/**\r\n * get/set stroke linear gradient end point y\r\n * @name Konva.Shape#strokeLinearGradientEndPointY\r\n * @method\r\n * @param {Number} y\r\n * @returns {Number}\r\n * @example\r\n * // get stroke linear gradient end point y\r\n * var endPointY = shape.strokeLinearGradientEndPointY();\r\n *\r\n * // set stroke linear gradient end point y\r\n * shape.strokeLinearGradientEndPointY(20);\r\n */\r\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientStartPoint', [\r\n    'x',\r\n    'y'\r\n]);\r\n/**\r\n * get/set fill radial gradient start point\r\n * @name Konva.Shape#fillRadialGradientStartPoint\r\n * @method\r\n * @param {Object} startPoint\r\n * @param {Number} startPoint.x\r\n * @param {Number} startPoint.y\r\n * @returns {Object}\r\n * @example\r\n * // get fill radial gradient start point\r\n * var startPoint = shape.fillRadialGradientStartPoint();\r\n *\r\n * // set fill radial gradient start point\r\n * shape.fillRadialGradientStartPoint({\r\n *   x: 20,\r\n *   y: 10\r\n * });\r\n */\r\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointX', 0);\r\n/**\r\n * get/set fill radial gradient start point x\r\n * @name Konva.Shape#fillRadialGradientStartPointX\r\n * @method\r\n * @param {Number} x\r\n * @returns {Number}\r\n * @example\r\n * // get fill radial gradient start point x\r\n * var startPointX = shape.fillRadialGradientStartPointX();\r\n *\r\n * // set fill radial gradient start point x\r\n * shape.fillRadialGradientStartPointX(20);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointY', 0);\r\n/**\r\n * get/set fill radial gradient start point y\r\n * @name Konva.Shape#fillRadialGradientStartPointY\r\n * @method\r\n * @param {Number} y\r\n * @returns {Number}\r\n * @example\r\n * // get fill radial gradient start point y\r\n * var startPointY = shape.fillRadialGradientStartPointY();\r\n *\r\n * // set fill radial gradient start point y\r\n * shape.fillRadialGradientStartPointY(20);\r\n */\r\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientEndPoint', [\r\n    'x',\r\n    'y'\r\n]);\r\n/**\r\n * get/set fill radial gradient end point\r\n * @name Konva.Shape#fillRadialGradientEndPoint\r\n * @method\r\n * @param {Object} endPoint\r\n * @param {Number} endPoint.x\r\n * @param {Number} endPoint.y\r\n * @returns {Object}\r\n * @example\r\n * // get fill radial gradient end point\r\n * var endPoint = shape.fillRadialGradientEndPoint();\r\n *\r\n * // set fill radial gradient end point\r\n * shape.fillRadialGradientEndPoint({\r\n *   x: 20,\r\n *   y: 10\r\n * });\r\n */\r\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointX', 0);\r\n/**\r\n * get/set fill radial gradient end point x\r\n * @name Konva.Shape#fillRadialGradientEndPointX\r\n * @method\r\n * @param {Number} x\r\n * @returns {Number}\r\n * @example\r\n * // get fill radial gradient end point x\r\n * var endPointX = shape.fillRadialGradientEndPointX();\r\n *\r\n * // set fill radial gradient end point x\r\n * shape.fillRadialGradientEndPointX(20);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointY', 0);\r\n/**\r\n * get/set fill radial gradient end point y\r\n * @name Konva.Shape#fillRadialGradientEndPointY\r\n * @method\r\n * @param {Number} y\r\n * @returns {Number}\r\n * @example\r\n * // get fill radial gradient end point y\r\n * var endPointY = shape.fillRadialGradientEndPointY();\r\n *\r\n * // set fill radial gradient end point y\r\n * shape.fillRadialGradientEndPointY(20);\r\n */\r\nFactory.addGetterSetter(Shape, 'fillPatternRotation', 0);\r\n/**\r\n * get/set fill pattern rotation in degrees\r\n * @name Konva.Shape#fillPatternRotation\r\n * @method\r\n * @param {Number} rotation\r\n * @returns {Konva.Shape}\r\n * @example\r\n * // get fill pattern rotation\r\n * var patternRotation = shape.fillPatternRotation();\r\n *\r\n * // set fill pattern rotation\r\n * shape.fillPatternRotation(20);\r\n */\r\nFactory.backCompat(Shape, {\r\n    dashArray: 'dash',\r\n    getDashArray: 'getDash',\r\n    setDashArray: 'getDash',\r\n    drawFunc: 'sceneFunc',\r\n    getDrawFunc: 'getSceneFunc',\r\n    setDrawFunc: 'setSceneFunc',\r\n    drawHitFunc: 'hitFunc',\r\n    getDrawHitFunc: 'getHitFunc',\r\n    setDrawHitFunc: 'setHitFunc'\r\n});\r\nCollection.mapMethods(Shape);\r\n"}
