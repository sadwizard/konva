{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Util } from './Util';\r\nimport { Konva } from './Global';\r\nvar COMMA = ',', OPEN_PAREN = '(', CLOSE_PAREN = ')', OPEN_PAREN_BRACKET = '([', CLOSE_BRACKET_PAREN = '])', SEMICOLON = ';', DOUBLE_PAREN = '()', \r\n// EMPTY_STRING = '',\r\nEQUALS = '=', \r\n// SET = 'set',\r\nCONTEXT_METHODS = [\r\n    'arc',\r\n    'arcTo',\r\n    'beginPath',\r\n    'bezierCurveTo',\r\n    'clearRect',\r\n    'clip',\r\n    'closePath',\r\n    'createLinearGradient',\r\n    'createPattern',\r\n    'createRadialGradient',\r\n    'drawImage',\r\n    'ellipse',\r\n    'fill',\r\n    'fillText',\r\n    'getImageData',\r\n    'createImageData',\r\n    'lineTo',\r\n    'moveTo',\r\n    'putImageData',\r\n    'quadraticCurveTo',\r\n    'rect',\r\n    'restore',\r\n    'rotate',\r\n    'save',\r\n    'scale',\r\n    'setLineDash',\r\n    'setTransform',\r\n    'stroke',\r\n    'strokeText',\r\n    'transform',\r\n    'translate'\r\n];\r\nvar CONTEXT_PROPERTIES = [\r\n    'fillStyle',\r\n    'strokeStyle',\r\n    'shadowColor',\r\n    'shadowBlur',\r\n    'shadowOffsetX',\r\n    'shadowOffsetY',\r\n    'lineCap',\r\n    'lineDashOffset',\r\n    'lineJoin',\r\n    'lineWidth',\r\n    'miterLimit',\r\n    'font',\r\n    'textAlign',\r\n    'textBaseline',\r\n    'globalAlpha',\r\n    'globalCompositeOperation',\r\n    'imageSmoothingEnabled'\r\n];\r\n// TODO: document all context methods\r\nvar traceArrMax = 100;\r\n/**\r\n * Konva wrapper around native 2d canvas context. It has almost the same API of 2d context with some additional functions.\r\n * With core Konva shapes you don't need to use this object. But you have to use it if you want to create\r\n * a custom shape or a custom hit regions.\r\n * @constructor\r\n * @memberof Konva\r\n * @example\r\n * const rect = new Konva.Shape({\r\n *    fill: 'red',\r\n *    width: 100,\r\n *    height: 100,\r\n *    sceneFunc: (ctx, shape) => {\r\n *      // ctx - is context wrapper\r\n *      // shape - is instance of Konva.Shape, so it equals to \"rect\" variable\r\n *      ctx.rect(0, 0, shape.getAttr('width'), shape.getAttr('height'));\r\n *\r\n *      // automatically fill shape from props and draw hit region\r\n *      ctx.fillStrokeShape(shape);\r\n *    }\r\n * })\r\n */\r\nvar Context = /** @class */ (function () {\r\n    function Context(canvas) {\r\n        this.canvas = canvas;\r\n        this._context = canvas._canvas.getContext('2d');\r\n        if (Konva.enableTrace) {\r\n            this.traceArr = [];\r\n            this._enableTrace();\r\n        }\r\n    }\r\n    /**\r\n     * fill shape\r\n     * @method\r\n     * @name Konva.Context#fillShape\r\n     * @param {Konva.Shape} shape\r\n     */\r\n    Context.prototype.fillShape = function (shape) {\r\n        if (shape.getFillEnabled()) {\r\n            this._fill(shape);\r\n        }\r\n    };\r\n    Context.prototype._fill = function (shape) {\r\n        // abstract\r\n    };\r\n    /**\r\n     * stroke shape\r\n     * @method\r\n     * @name Konva.Context#strokeShape\r\n     * @param {Konva.Shape} shape\r\n     */\r\n    Context.prototype.strokeShape = function (shape) {\r\n        if (shape.getStrokeEnabled()) {\r\n            this._stroke(shape);\r\n        }\r\n    };\r\n    Context.prototype._stroke = function (shape) {\r\n        // abstract\r\n    };\r\n    /**\r\n     * fill then stroke\r\n     * @method\r\n     * @name Konva.Context#fillStrokeShape\r\n     * @param {Konva.Shape} shape\r\n     */\r\n    Context.prototype.fillStrokeShape = function (shape) {\r\n        if (shape.getFillEnabled()) {\r\n            this._fill(shape);\r\n        }\r\n        if (shape.getStrokeEnabled()) {\r\n            this._stroke(shape);\r\n        }\r\n    };\r\n    Context.prototype.getTrace = function (relaxed) {\r\n        var traceArr = this.traceArr, len = traceArr.length, str = '', n, trace, method, args;\r\n        for (n = 0; n < len; n++) {\r\n            trace = traceArr[n];\r\n            method = trace.method;\r\n            // methods\r\n            if (method) {\r\n                args = trace.args;\r\n                str += method;\r\n                if (relaxed) {\r\n                    str += DOUBLE_PAREN;\r\n                }\r\n                else {\r\n                    if (Util._isArray(args[0])) {\r\n                        str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;\r\n                    }\r\n                    else {\r\n                        str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // properties\r\n                str += trace.property;\r\n                if (!relaxed) {\r\n                    str += EQUALS + trace.val;\r\n                }\r\n            }\r\n            str += SEMICOLON;\r\n        }\r\n        return str;\r\n    };\r\n    Context.prototype.clearTrace = function () {\r\n        this.traceArr = [];\r\n    };\r\n    Context.prototype._trace = function (str) {\r\n        var traceArr = this.traceArr, len;\r\n        traceArr.push(str);\r\n        len = traceArr.length;\r\n        if (len >= traceArrMax) {\r\n            traceArr.shift();\r\n        }\r\n    };\r\n    /**\r\n     * reset canvas context transform\r\n     * @method\r\n     * @name Konva.Context#reset\r\n     */\r\n    Context.prototype.reset = function () {\r\n        var pixelRatio = this.getCanvas().getPixelRatio();\r\n        this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);\r\n    };\r\n    /**\r\n     * get canvas wrapper\r\n     * @method\r\n     * @name Konva.Context#getCanvas\r\n     * @returns {Konva.Canvas}\r\n     */\r\n    Context.prototype.getCanvas = function () {\r\n        return this.canvas;\r\n    };\r\n    /**\r\n     * clear canvas\r\n     * @method\r\n     * @name Konva.Context#clear\r\n     * @param {Object} [bounds]\r\n     * @param {Number} [bounds.x]\r\n     * @param {Number} [bounds.y]\r\n     * @param {Number} [bounds.width]\r\n     * @param {Number} [bounds.height]\r\n     */\r\n    Context.prototype.clear = function (bounds) {\r\n        var canvas = this.getCanvas();\r\n        if (bounds) {\r\n            this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);\r\n        }\r\n        else {\r\n            this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);\r\n        }\r\n    };\r\n    Context.prototype._applyLineCap = function (shape) {\r\n        var lineCap = shape.getLineCap();\r\n        if (lineCap) {\r\n            this.setAttr('lineCap', lineCap);\r\n        }\r\n    };\r\n    Context.prototype._applyOpacity = function (shape) {\r\n        var absOpacity = shape.getAbsoluteOpacity();\r\n        if (absOpacity !== 1) {\r\n            this.setAttr('globalAlpha', absOpacity);\r\n        }\r\n    };\r\n    Context.prototype._applyLineJoin = function (shape) {\r\n        var lineJoin = shape.getLineJoin();\r\n        if (lineJoin) {\r\n            this.setAttr('lineJoin', lineJoin);\r\n        }\r\n    };\r\n    Context.prototype.setAttr = function (attr, val) {\r\n        this._context[attr] = val;\r\n    };\r\n    // context pass through methods\r\n    Context.prototype.arc = function (a0, a1, a2, a3, a4, a5) {\r\n        this._context.arc(a0, a1, a2, a3, a4, a5);\r\n    };\r\n    Context.prototype.arcTo = function (a0, a1, a2, a3, a4, a5) {\r\n        this._context.arc(a0, a1, a2, a3, a4, a5);\r\n    };\r\n    Context.prototype.beginPath = function () {\r\n        this._context.beginPath();\r\n    };\r\n    Context.prototype.bezierCurveTo = function (a0, a1, a2, a3, a4, a5) {\r\n        this._context.bezierCurveTo(a0, a1, a2, a3, a4, a5);\r\n    };\r\n    Context.prototype.clearRect = function (a0, a1, a2, a3) {\r\n        this._context.clearRect(a0, a1, a2, a3);\r\n    };\r\n    Context.prototype.clip = function () {\r\n        this._context.clip();\r\n    };\r\n    Context.prototype.closePath = function () {\r\n        this._context.closePath();\r\n    };\r\n    Context.prototype.createImageData = function (a0, a1) {\r\n        var a = arguments;\r\n        if (a.length === 2) {\r\n            return this._context.createImageData(a0, a1);\r\n        }\r\n        else if (a.length === 1) {\r\n            return this._context.createImageData(a0);\r\n        }\r\n    };\r\n    Context.prototype.createLinearGradient = function (a0, a1, a2, a3) {\r\n        return this._context.createLinearGradient(a0, a1, a2, a3);\r\n    };\r\n    Context.prototype.createPattern = function (a0, a1) {\r\n        return this._context.createPattern(a0, a1);\r\n    };\r\n    Context.prototype.createRadialGradient = function (a0, a1, a2, a3, a4, a5) {\r\n        return this._context.createRadialGradient(a0, a1, a2, a3, a4, a5);\r\n    };\r\n    Context.prototype.drawImage = function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\r\n        var a = arguments, _context = this._context;\r\n        if (a.length === 3) {\r\n            _context.drawImage(a0, a1, a2);\r\n        }\r\n        else if (a.length === 5) {\r\n            _context.drawImage(a0, a1, a2, a3, a4);\r\n        }\r\n        else if (a.length === 9) {\r\n            _context.drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8);\r\n        }\r\n    };\r\n    Context.prototype.ellipse = function (a0, a1, a2, a3, a4, a5, a6, a7) {\r\n        this._context.ellipse(a0, a1, a2, a3, a4, a5, a6, a7);\r\n    };\r\n    Context.prototype.isPointInPath = function (x, y) {\r\n        return this._context.isPointInPath(x, y);\r\n    };\r\n    Context.prototype.fill = function () {\r\n        this._context.fill();\r\n    };\r\n    Context.prototype.fillRect = function (x, y, width, height) {\r\n        this._context.fillRect(x, y, width, height);\r\n    };\r\n    Context.prototype.strokeRect = function (x, y, width, height) {\r\n        this._context.strokeRect(x, y, width, height);\r\n    };\r\n    Context.prototype.fillText = function (a0, a1, a2) {\r\n        this._context.fillText(a0, a1, a2);\r\n    };\r\n    Context.prototype.measureText = function (text) {\r\n        return this._context.measureText(text);\r\n    };\r\n    Context.prototype.getImageData = function (a0, a1, a2, a3) {\r\n        return this._context.getImageData(a0, a1, a2, a3);\r\n    };\r\n    Context.prototype.lineTo = function (a0, a1) {\r\n        this._context.lineTo(a0, a1);\r\n    };\r\n    Context.prototype.moveTo = function (a0, a1) {\r\n        this._context.moveTo(a0, a1);\r\n    };\r\n    Context.prototype.rect = function (a0, a1, a2, a3) {\r\n        this._context.rect(a0, a1, a2, a3);\r\n    };\r\n    Context.prototype.putImageData = function (a0, a1, a2) {\r\n        this._context.putImageData(a0, a1, a2);\r\n    };\r\n    Context.prototype.quadraticCurveTo = function (a0, a1, a2, a3) {\r\n        this._context.quadraticCurveTo(a0, a1, a2, a3);\r\n    };\r\n    Context.prototype.restore = function () {\r\n        this._context.restore();\r\n    };\r\n    Context.prototype.rotate = function (a0) {\r\n        this._context.rotate(a0);\r\n    };\r\n    Context.prototype.save = function () {\r\n        this._context.save();\r\n    };\r\n    Context.prototype.scale = function (a0, a1) {\r\n        this._context.scale(a0, a1);\r\n    };\r\n    Context.prototype.setLineDash = function (a0) {\r\n        // works for Chrome and IE11\r\n        if (this._context.setLineDash) {\r\n            this._context.setLineDash(a0);\r\n        }\r\n        else if ('mozDash' in this._context) {\r\n            // verified that this works in firefox\r\n            this._context['mozDash'] = a0;\r\n        }\r\n        else if ('webkitLineDash' in this._context) {\r\n            // does not currently work for Safari\r\n            this._context['webkitLineDash'] = a0;\r\n        }\r\n        // no support for IE9 and IE10\r\n    };\r\n    Context.prototype.getLineDash = function () {\r\n        return this._context.getLineDash();\r\n    };\r\n    Context.prototype.setTransform = function (a0, a1, a2, a3, a4, a5) {\r\n        this._context.setTransform(a0, a1, a2, a3, a4, a5);\r\n    };\r\n    Context.prototype.stroke = function () {\r\n        this._context.stroke();\r\n    };\r\n    Context.prototype.strokeText = function (a0, a1, a2, a3) {\r\n        this._context.strokeText(a0, a1, a2, a3);\r\n    };\r\n    Context.prototype.transform = function (a0, a1, a2, a3, a4, a5) {\r\n        this._context.transform(a0, a1, a2, a3, a4, a5);\r\n    };\r\n    Context.prototype.translate = function (a0, a1) {\r\n        this._context.translate(a0, a1);\r\n    };\r\n    Context.prototype._enableTrace = function () {\r\n        var that = this, len = CONTEXT_METHODS.length, _simplifyArray = Util._simplifyArray, origSetter = this.setAttr, n, args;\r\n        // to prevent creating scope function at each loop\r\n        var func = function (methodName) {\r\n            var origMethod = that[methodName], ret;\r\n            that[methodName] = function () {\r\n                args = _simplifyArray(Array.prototype.slice.call(arguments, 0));\r\n                ret = origMethod.apply(that, arguments);\r\n                that._trace({\r\n                    method: methodName,\r\n                    args: args\r\n                });\r\n                return ret;\r\n            };\r\n        };\r\n        // methods\r\n        for (n = 0; n < len; n++) {\r\n            func(CONTEXT_METHODS[n]);\r\n        }\r\n        // attrs\r\n        that.setAttr = function () {\r\n            origSetter.apply(that, arguments);\r\n            var prop = arguments[0];\r\n            var val = arguments[1];\r\n            if (prop === 'shadowOffsetX' ||\r\n                prop === 'shadowOffsetY' ||\r\n                prop === 'shadowBlur') {\r\n                val = val / this.canvas.getPixelRatio();\r\n            }\r\n            that._trace({\r\n                property: prop,\r\n                val: val\r\n            });\r\n        };\r\n    };\r\n    Context.prototype._applyGlobalCompositeOperation = function (node) {\r\n        var globalCompositeOperation = node.getGlobalCompositeOperation();\r\n        if (globalCompositeOperation !== 'source-over') {\r\n            this.setAttr('globalCompositeOperation', globalCompositeOperation);\r\n        }\r\n    };\r\n    return Context;\r\n}());\r\nexport { Context };\r\nCONTEXT_PROPERTIES.forEach(function (prop) {\r\n    Object.defineProperty(Context.prototype, prop, {\r\n        get: function () {\r\n            return this._context[prop];\r\n        },\r\n        set: function (val) {\r\n            this._context[prop] = val;\r\n        }\r\n    });\r\n});\r\nvar SceneContext = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SceneContext, _super);\r\n    function SceneContext() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    SceneContext.prototype._fillColor = function (shape) {\r\n        var fill = shape.fill();\r\n        this.setAttr('fillStyle', fill);\r\n        shape._fillFunc(this);\r\n    };\r\n    SceneContext.prototype._fillPattern = function (shape) {\r\n        var fillPatternX = shape.getFillPatternX(), fillPatternY = shape.getFillPatternY(), fillPatternScaleX = shape.getFillPatternScaleX(), fillPatternScaleY = shape.getFillPatternScaleY(), fillPatternRotation = Konva.getAngle(shape.getFillPatternRotation()), fillPatternOffsetX = shape.getFillPatternOffsetX(), fillPatternOffsetY = shape.getFillPatternOffsetY();\r\n        if (fillPatternX || fillPatternY) {\r\n            this.translate(fillPatternX || 0, fillPatternY || 0);\r\n        }\r\n        if (fillPatternRotation) {\r\n            this.rotate(fillPatternRotation);\r\n        }\r\n        if (fillPatternScaleX || fillPatternScaleY) {\r\n            this.scale(fillPatternScaleX, fillPatternScaleY);\r\n        }\r\n        if (fillPatternOffsetX || fillPatternOffsetY) {\r\n            this.translate(-1 * fillPatternOffsetX, -1 * fillPatternOffsetY);\r\n        }\r\n        this.setAttr('fillStyle', shape._getFillPattern());\r\n        shape._fillFunc(this);\r\n    };\r\n    SceneContext.prototype._fillLinearGradient = function (shape) {\r\n        var grd = shape._getLinearGradient();\r\n        if (grd) {\r\n            this.setAttr('fillStyle', grd);\r\n            shape._fillFunc(this);\r\n        }\r\n    };\r\n    SceneContext.prototype._fillRadialGradient = function (shape) {\r\n        var grd = shape._getRadialGradient();\r\n        if (grd) {\r\n            this.setAttr('fillStyle', grd);\r\n            shape._fillFunc(this);\r\n        }\r\n    };\r\n    SceneContext.prototype._fill = function (shape) {\r\n        var hasColor = shape.fill(), fillPriority = shape.getFillPriority();\r\n        // priority fills\r\n        if (hasColor && fillPriority === 'color') {\r\n            this._fillColor(shape);\r\n            return;\r\n        }\r\n        var hasPattern = shape.getFillPatternImage();\r\n        if (hasPattern && fillPriority === 'pattern') {\r\n            this._fillPattern(shape);\r\n            return;\r\n        }\r\n        var hasLinearGradient = shape.getFillLinearGradientColorStops();\r\n        if (hasLinearGradient && fillPriority === 'linear-gradient') {\r\n            this._fillLinearGradient(shape);\r\n            return;\r\n        }\r\n        var hasRadialGradient = shape.getFillRadialGradientColorStops();\r\n        if (hasRadialGradient && fillPriority === 'radial-gradient') {\r\n            this._fillRadialGradient(shape);\r\n            return;\r\n        }\r\n        // now just try and fill with whatever is available\r\n        if (hasColor) {\r\n            this._fillColor(shape);\r\n        }\r\n        else if (hasPattern) {\r\n            this._fillPattern(shape);\r\n        }\r\n        else if (hasLinearGradient) {\r\n            this._fillLinearGradient(shape);\r\n        }\r\n        else if (hasRadialGradient) {\r\n            this._fillRadialGradient(shape);\r\n        }\r\n    };\r\n    SceneContext.prototype._strokeLinearGradient = function (shape) {\r\n        var start = shape.getStrokeLinearGradientStartPoint(), end = shape.getStrokeLinearGradientEndPoint(), colorStops = shape.getStrokeLinearGradientColorStops(), grd = this.createLinearGradient(start.x, start.y, end.x, end.y);\r\n        if (colorStops) {\r\n            // build color stops\r\n            for (var n = 0; n < colorStops.length; n += 2) {\r\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\r\n            }\r\n            this.setAttr('strokeStyle', grd);\r\n        }\r\n    };\r\n    SceneContext.prototype._stroke = function (shape) {\r\n        var dash = shape.dash(), \r\n        // ignore strokeScaleEnabled for Text\r\n        strokeScaleEnabled = shape.getStrokeScaleEnabled();\r\n        if (shape.hasStroke()) {\r\n            if (!strokeScaleEnabled) {\r\n                this.save();\r\n                var pixelRatio = this.getCanvas().getPixelRatio();\r\n                this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\r\n            }\r\n            this._applyLineCap(shape);\r\n            if (dash && shape.dashEnabled()) {\r\n                this.setLineDash(dash);\r\n                this.setAttr('lineDashOffset', shape.dashOffset());\r\n            }\r\n            this.setAttr('lineWidth', shape.strokeWidth());\r\n            if (!shape.getShadowForStrokeEnabled()) {\r\n                this.setAttr('shadowColor', 'rgba(0,0,0,0)');\r\n            }\r\n            var hasLinearGradient = shape.getStrokeLinearGradientColorStops();\r\n            if (hasLinearGradient) {\r\n                this._strokeLinearGradient(shape);\r\n            }\r\n            else {\r\n                this.setAttr('strokeStyle', shape.stroke());\r\n            }\r\n            shape._strokeFunc(this);\r\n            if (!strokeScaleEnabled) {\r\n                this.restore();\r\n            }\r\n        }\r\n    };\r\n    SceneContext.prototype._applyShadow = function (shape) {\r\n        var util = Util, color = util.get(shape.getShadowRGBA(), 'black'), blur = util.get(shape.getShadowBlur(), 5), offset = util.get(shape.getShadowOffset(), {\r\n            x: 0,\r\n            y: 0\r\n        }), scale = shape.getAbsoluteScale(), ratio = this.canvas.getPixelRatio(), scaleX = scale.x * ratio, scaleY = scale.y * ratio;\r\n        this.setAttr('shadowColor', color);\r\n        this.setAttr('shadowBlur', blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));\r\n        this.setAttr('shadowOffsetX', offset.x * scaleX);\r\n        this.setAttr('shadowOffsetY', offset.y * scaleY);\r\n    };\r\n    return SceneContext;\r\n}(Context));\r\nexport { SceneContext };\r\nvar HitContext = /** @class */ (function (_super) {\r\n    tslib_1.__extends(HitContext, _super);\r\n    function HitContext() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    HitContext.prototype._fill = function (shape) {\r\n        this.save();\r\n        this.setAttr('fillStyle', shape.colorKey);\r\n        shape._fillFuncHit(this);\r\n        this.restore();\r\n    };\r\n    HitContext.prototype._stroke = function (shape) {\r\n        if (shape.hasStroke() && shape.hitStrokeWidth()) {\r\n            // ignore strokeScaleEnabled for Text\r\n            var strokeScaleEnabled = shape.getStrokeScaleEnabled();\r\n            if (!strokeScaleEnabled) {\r\n                this.save();\r\n                var pixelRatio = this.getCanvas().getPixelRatio();\r\n                this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\r\n            }\r\n            this._applyLineCap(shape);\r\n            var hitStrokeWidth = shape.hitStrokeWidth();\r\n            var strokeWidth = hitStrokeWidth === 'auto' ? shape.strokeWidth() : hitStrokeWidth;\r\n            this.setAttr('lineWidth', strokeWidth);\r\n            this.setAttr('strokeStyle', shape.colorKey);\r\n            shape._strokeFuncHit(this);\r\n            if (!strokeScaleEnabled) {\r\n                this.restore();\r\n            }\r\n        }\r\n    };\r\n    return HitContext;\r\n}(Context));\r\nexport { HitContext };\r\n"}
