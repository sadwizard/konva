{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Util, Collection } from '../Util';\r\nimport { Factory } from '../Factory';\r\nimport { Shape } from '../Shape';\r\nimport { Path } from './Path';\r\nimport { Text } from './Text';\r\nimport { getNumberValidator } from '../Validators';\r\nimport { _registerNode } from '../Global';\r\nvar EMPTY_STRING = '', NORMAL = 'normal';\r\nfunction _fillFunc(context) {\r\n    context.fillText(this.partialText, 0, 0);\r\n}\r\nfunction _strokeFunc(context) {\r\n    context.strokeText(this.partialText, 0, 0);\r\n}\r\n/**\r\n * Path constructor.\r\n * @author Jason Follas\r\n * @constructor\r\n * @memberof Konva\r\n * @augments Konva.Shape\r\n * @param {Object} config\r\n * @param {String} [config.fontFamily] default is Calibri\r\n * @param {Number} [config.fontSize] default is 12\r\n * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal\r\n * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal\r\n * @param {String} [config.textBaseline] Can be 'top', 'bottom', 'middle', 'alphabetic', 'hanging'. Default is middle\r\n * @param {String} config.text\r\n * @param {String} config.data SVG data string\r\n * @param {Function} config.getKerning a getter for kerning values for the specified characters\r\n * @param {Function} config.kerningFunc a getter for kerning values for the specified characters\r\n * @@shapeParams\r\n * @@nodeParams\r\n * @example\r\n * var kerningPairs = {\r\n *   'A': {\r\n *     ' ': -0.05517578125,\r\n *     'T': -0.07421875,\r\n *     'V': -0.07421875\r\n *   }\r\n *   'V': {\r\n *     ',': -0.091796875,\r\n *     \":\": -0.037109375,\r\n *     \";\": -0.037109375,\r\n *     \"A\": -0.07421875\r\n *   }\r\n * }\r\n * var textpath = new Konva.TextPath({\r\n *   x: 100,\r\n *   y: 50,\r\n *   fill: '#333',\r\n *   fontSize: '24',\r\n *   fontFamily: 'Arial',\r\n *   text: 'All the world\\'s a stage, and all the men and women merely players.',\r\n *   data: 'M10,10 C0,0 10,150 100,100 S300,150 400,50',\r\n *   kerningFunc(leftChar, rightChar) {\r\n *     return kerningPairs.hasOwnProperty(leftChar) ? pairs[leftChar][rightChar] || 0 : 0\r\n *   }\r\n * });\r\n */\r\nvar TextPath = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TextPath, _super);\r\n    function TextPath(config) {\r\n        var _this = \r\n        // call super constructor\r\n        _super.call(this, config) || this;\r\n        _this.dummyCanvas = Util.createCanvasElement();\r\n        _this.dataArray = [];\r\n        _this.dataArray = Path.parsePathData(_this.attrs.data);\r\n        _this.on('dataChange.konva', function () {\r\n            this.dataArray = Path.parsePathData(this.attrs.data);\r\n            this._setTextData();\r\n        });\r\n        // update text data for certain attr changes\r\n        _this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva', _this._setTextData);\r\n        if (config && config['getKerning']) {\r\n            Util.warn('getKerning TextPath API is deprecated. Please use \"kerningFunc\" instead.');\r\n            _this.kerningFunc(config['getKerning']);\r\n        }\r\n        _this._setTextData();\r\n        return _this;\r\n    }\r\n    TextPath.prototype._sceneFunc = function (context) {\r\n        context.setAttr('font', this._getContextFont());\r\n        context.setAttr('textBaseline', this.textBaseline());\r\n        context.setAttr('textAlign', 'left');\r\n        context.save();\r\n        var textDecoration = this.textDecoration();\r\n        var fill = this.fill();\r\n        var fontSize = this.fontSize();\r\n        var glyphInfo = this.glyphInfo;\r\n        if (textDecoration === 'underline') {\r\n            context.beginPath();\r\n        }\r\n        for (var i = 0; i < glyphInfo.length; i++) {\r\n            context.save();\r\n            var p0 = glyphInfo[i].p0;\r\n            context.translate(p0.x, p0.y);\r\n            context.rotate(glyphInfo[i].rotation);\r\n            this.partialText = glyphInfo[i].text;\r\n            context.fillStrokeShape(this);\r\n            if (textDecoration === 'underline') {\r\n                if (i === 0) {\r\n                    context.moveTo(0, fontSize / 2 + 1);\r\n                }\r\n                context.lineTo(fontSize, fontSize / 2 + 1);\r\n            }\r\n            context.restore();\r\n            //// To assist with debugging visually, uncomment following\r\n            //\r\n            // if (i % 2) context.strokeStyle = 'cyan';\r\n            // else context.strokeStyle = 'green';\r\n            // var p1 = glyphInfo[i].p1;\r\n            // context.moveTo(p0.x, p0.y);\r\n            // context.lineTo(p1.x, p1.y);\r\n            // context.stroke();\r\n        }\r\n        if (textDecoration === 'underline') {\r\n            context.strokeStyle = fill;\r\n            context.lineWidth = fontSize / 20;\r\n            context.stroke();\r\n        }\r\n        context.restore();\r\n    };\r\n    TextPath.prototype._hitFunc = function (context) {\r\n        context.beginPath();\r\n        var glyphInfo = this.glyphInfo;\r\n        if (glyphInfo.length >= 1) {\r\n            var p0 = glyphInfo[0].p0;\r\n            context.moveTo(p0.x, p0.y);\r\n        }\r\n        for (var i = 0; i < glyphInfo.length; i++) {\r\n            var p1 = glyphInfo[i].p1;\r\n            context.lineTo(p1.x, p1.y);\r\n        }\r\n        context.setAttr('lineWidth', this.fontSize());\r\n        context.setAttr('strokeStyle', this.colorKey);\r\n        context.stroke();\r\n    };\r\n    /**\r\n     * get text width in pixels\r\n     * @method\r\n     * @name Konva.TextPath#getTextWidth\r\n     */\r\n    TextPath.prototype.getTextWidth = function () {\r\n        return this.textWidth;\r\n    };\r\n    TextPath.prototype.getTextHeight = function () {\r\n        Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\r\n        return this.textHeight;\r\n    };\r\n    TextPath.prototype.setText = function (text) {\r\n        return Text.prototype.setText.call(this, text);\r\n    };\r\n    TextPath.prototype._getContextFont = function () {\r\n        return Text.prototype._getContextFont.call(this);\r\n    };\r\n    TextPath.prototype._getTextSize = function (text) {\r\n        var dummyCanvas = this.dummyCanvas;\r\n        var _context = dummyCanvas.getContext('2d');\r\n        _context.save();\r\n        _context.font = this._getContextFont();\r\n        var metrics = _context.measureText(text);\r\n        _context.restore();\r\n        return {\r\n            width: metrics.width,\r\n            height: parseInt(this.attrs.fontSize, 10)\r\n        };\r\n    };\r\n    TextPath.prototype._setTextData = function () {\r\n        var that = this;\r\n        var size = this._getTextSize(this.attrs.text);\r\n        var letterSpacing = this.letterSpacing();\r\n        var align = this.align();\r\n        var kerningFunc = this.kerningFunc();\r\n        this.textWidth = size.width;\r\n        this.textHeight = size.height;\r\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\r\n        this.glyphInfo = [];\r\n        var fullPathWidth = 0;\r\n        for (var l = 0; l < that.dataArray.length; l++) {\r\n            if (that.dataArray[l].pathLength > 0) {\r\n                fullPathWidth += that.dataArray[l].pathLength;\r\n            }\r\n        }\r\n        var offset = 0;\r\n        if (align === 'center') {\r\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\r\n        }\r\n        if (align === 'right') {\r\n            offset = Math.max(0, fullPathWidth - textFullWidth);\r\n        }\r\n        var charArr = this.text().split('');\r\n        var spacesNumber = this.text().split(' ').length - 1;\r\n        var p0, p1, pathCmd;\r\n        var pIndex = -1;\r\n        var currentT = 0;\r\n        // var sumLength = 0;\r\n        // for(var j = 0; j < that.dataArray.length; j++) {\r\n        //   if(that.dataArray[j].pathLength > 0) {\r\n        //\r\n        //     if (sumLength + that.dataArray[j].pathLength > offset) {}\r\n        //       fullPathWidth += that.dataArray[j].pathLength;\r\n        //   }\r\n        // }\r\n        var getNextPathSegment = function () {\r\n            currentT = 0;\r\n            var pathData = that.dataArray;\r\n            for (var j = pIndex + 1; j < pathData.length; j++) {\r\n                if (pathData[j].pathLength > 0) {\r\n                    pIndex = j;\r\n                    return pathData[j];\r\n                }\r\n                else if (pathData[j].command === 'M') {\r\n                    p0 = {\r\n                        x: pathData[j].points[0],\r\n                        y: pathData[j].points[1]\r\n                    };\r\n                }\r\n            }\r\n            return {};\r\n        };\r\n        var findSegmentToFitCharacter = function (c) {\r\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\r\n            if (c === ' ' && align === 'justify') {\r\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\r\n            }\r\n            var currLen = 0;\r\n            var attempts = 0;\r\n            p1 = undefined;\r\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\r\n                attempts < 25) {\r\n                attempts++;\r\n                var cumulativePathLength = currLen;\r\n                while (pathCmd === undefined) {\r\n                    pathCmd = getNextPathSegment();\r\n                    if (pathCmd &&\r\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\r\n                        cumulativePathLength += pathCmd.pathLength;\r\n                        pathCmd = undefined;\r\n                    }\r\n                }\r\n                if (pathCmd === {} || p0 === undefined) {\r\n                    return undefined;\r\n                }\r\n                var needNewSegment = false;\r\n                switch (pathCmd.command) {\r\n                    case 'L':\r\n                        if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\r\n                            p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\r\n                        }\r\n                        else {\r\n                            pathCmd = undefined;\r\n                        }\r\n                        break;\r\n                    case 'A':\r\n                        var start = pathCmd.points[4];\r\n                        // 4 = theta\r\n                        var dTheta = pathCmd.points[5];\r\n                        // 5 = dTheta\r\n                        var end = pathCmd.points[4] + dTheta;\r\n                        if (currentT === 0) {\r\n                            currentT = start + 0.00000001;\r\n                        }\r\n                        else if (glyphWidth > currLen) {\r\n                            // Just in case start is 0\r\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\r\n                        }\r\n                        else {\r\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\r\n                        }\r\n                        // Credit for bug fix: @therth https://github.com/ericdrowell/KonvaJS/issues/249\r\n                        // Old code failed to render text along arc of this path: \"M 50 50 a 150 50 0 0 1 250 50 l 50 0\"\r\n                        if ((dTheta < 0 && currentT < end) ||\r\n                            (dTheta >= 0 && currentT > end)) {\r\n                            currentT = end;\r\n                            needNewSegment = true;\r\n                        }\r\n                        p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\r\n                        break;\r\n                    case 'C':\r\n                        if (currentT === 0) {\r\n                            if (glyphWidth > pathCmd.pathLength) {\r\n                                currentT = 0.00000001;\r\n                            }\r\n                            else {\r\n                                currentT = glyphWidth / pathCmd.pathLength;\r\n                            }\r\n                        }\r\n                        else if (glyphWidth > currLen) {\r\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\r\n                        }\r\n                        else {\r\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\r\n                        }\r\n                        if (currentT > 1.0) {\r\n                            currentT = 1.0;\r\n                            needNewSegment = true;\r\n                        }\r\n                        p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\r\n                        break;\r\n                    case 'Q':\r\n                        if (currentT === 0) {\r\n                            currentT = glyphWidth / pathCmd.pathLength;\r\n                        }\r\n                        else if (glyphWidth > currLen) {\r\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\r\n                        }\r\n                        else {\r\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\r\n                        }\r\n                        if (currentT > 1.0) {\r\n                            currentT = 1.0;\r\n                            needNewSegment = true;\r\n                        }\r\n                        p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\r\n                        break;\r\n                }\r\n                if (p1 !== undefined) {\r\n                    currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\r\n                }\r\n                if (needNewSegment) {\r\n                    needNewSegment = false;\r\n                    pathCmd = undefined;\r\n                }\r\n            }\r\n        };\r\n        // fake search for offset, this is very bad approach\r\n        // find other way to add offset from start (for align)\r\n        var testChar = 'C';\r\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\r\n        for (var k = 0; k < offset / glyphWidth; k++) {\r\n            findSegmentToFitCharacter(testChar);\r\n            if (p0 === undefined || p1 === undefined) {\r\n                break;\r\n            }\r\n            p0 = p1;\r\n        }\r\n        for (var i = 0; i < charArr.length; i++) {\r\n            // Find p1 such that line segment between p0 and p1 is approx. width of glyph\r\n            findSegmentToFitCharacter(charArr[i]);\r\n            if (p0 === undefined || p1 === undefined) {\r\n                break;\r\n            }\r\n            var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\r\n            var kern = 0;\r\n            if (kerningFunc) {\r\n                try {\r\n                    // getKerning is a user provided getter. Make sure it never breaks our logic\r\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\r\n                }\r\n                catch (e) {\r\n                    kern = 0;\r\n                }\r\n            }\r\n            p0.x += kern;\r\n            p1.x += kern;\r\n            this.textWidth += kern;\r\n            var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\r\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\r\n            this.glyphInfo.push({\r\n                transposeX: midpoint.x,\r\n                transposeY: midpoint.y,\r\n                text: charArr[i],\r\n                rotation: rotation,\r\n                p0: p0,\r\n                p1: p1\r\n            });\r\n            p0 = p1;\r\n        }\r\n    };\r\n    TextPath.prototype.getSelfRect = function () {\r\n        var points = [];\r\n        this.glyphInfo.forEach(function (info) {\r\n            points.push(info.p0.x);\r\n            points.push(info.p0.y);\r\n            points.push(info.p1.x);\r\n            points.push(info.p1.y);\r\n        });\r\n        var minX = points[0];\r\n        var maxX = points[0];\r\n        var minY = points[0];\r\n        var maxY = points[0];\r\n        var x, y;\r\n        for (var i = 0; i < points.length / 2; i++) {\r\n            x = points[i * 2];\r\n            y = points[i * 2 + 1];\r\n            minX = Math.min(minX, x);\r\n            maxX = Math.max(maxX, x);\r\n            minY = Math.min(minY, y);\r\n            maxY = Math.max(maxY, y);\r\n        }\r\n        var fontSize = this.fontSize();\r\n        return {\r\n            x: Math.round(minX) - fontSize / 2,\r\n            y: Math.round(minY) - fontSize / 2,\r\n            width: Math.round(maxX - minX) + fontSize,\r\n            height: Math.round(maxY - minY) + fontSize\r\n        };\r\n    };\r\n    return TextPath;\r\n}(Shape));\r\nexport { TextPath };\r\nTextPath.prototype._fillFunc = _fillFunc;\r\nTextPath.prototype._strokeFunc = _strokeFunc;\r\nTextPath.prototype._fillFuncHit = _fillFunc;\r\nTextPath.prototype._strokeFuncHit = _strokeFunc;\r\nTextPath.prototype.className = 'TextPath';\r\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\r\n_registerNode(TextPath);\r\n/**\r\n * get/set SVG path data string.  This method\r\n *  also automatically parses the data string\r\n *  into a data array.  Currently supported SVG data:\r\n *  M, m, L, l, H, h, V, v, Q, q, T, t, C, c, S, s, A, a, Z, z\r\n * @name Konva.TextPath#data\r\n * @method\r\n * @param {String} data svg path string\r\n * @returns {String}\r\n * @example\r\n * // get data\r\n * var data = shape.data();\r\n *\r\n * // set data\r\n * shape.data('M200,100h100v50z');\r\n */\r\nFactory.addGetterSetter(TextPath, 'data');\r\n/**\r\n * get/set font family\r\n * @name Konva.TextPath#fontFamily\r\n * @method\r\n * @param {String} fontFamily\r\n * @returns {String}\r\n * @example\r\n * // get font family\r\n * var fontFamily = shape.fontFamily();\r\n *\r\n * // set font family\r\n * shape.fontFamily('Arial');\r\n */\r\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\r\n/**\r\n * get/set font size in pixels\r\n * @name Konva.TextPath#fontSize\r\n * @method\r\n * @param {Number} fontSize\r\n * @returns {Number}\r\n * @example\r\n * // get font size\r\n * var fontSize = shape.fontSize();\r\n *\r\n * // set font size to 22px\r\n * shape.fontSize(22);\r\n */\r\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\r\n/**\r\n * get/set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.\r\n * @name Konva.TextPath#fontStyle\r\n * @method\r\n * @param {String} fontStyle\r\n * @returns {String}\r\n * @example\r\n * // get font style\r\n * var fontStyle = shape.fontStyle();\r\n *\r\n * // set font style\r\n * shape.fontStyle('bold');\r\n */\r\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\r\n/**\r\n * get/set horizontal align of text.  Can be 'left', 'center', 'right' or 'justify'\r\n * @name Konva.Text#align\r\n * @method\r\n * @param {String} align\r\n * @returns {String}\r\n * @example\r\n * // get text align\r\n * var align = text.align();\r\n *\r\n * // center text\r\n * text.align('center');\r\n *\r\n * // align text to right\r\n * text.align('right');\r\n */\r\nFactory.addGetterSetter(TextPath, 'align', 'left');\r\n/**\r\n * get/set letter spacing.  The default is 0.\r\n * @name Konva.TextPath#letterSpacing\r\n * @method\r\n * @param {Number} letterSpacing\r\n * @returns {Number}\r\n * @example\r\n * // get line height\r\n * var letterSpacing = shape.letterSpacing();\r\n *\r\n * // set the line height\r\n * shape.letterSpacing(2);\r\n */\r\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\r\n/**\r\n * get/set text baselineg.  The default is 'middle'. Can be 'top', 'bottom', 'middle', 'alphabetic', 'hanging'\r\n * @name Konva.TextPath#textBaseline\r\n * @method\r\n * @param {String} textBaseline\r\n * @returns {String}\r\n * @example\r\n * // get line height\r\n * var textBaseline = shape.textBaseline();\r\n *\r\n * // set the line height\r\n * shape.textBaseline('top');\r\n */\r\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\r\n/**\r\n * get/set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.\r\n * @name Konva.TextPath#fontVariant\r\n * @method\r\n * @param {String} fontVariant\r\n * @returns {String}\r\n * @example\r\n * // get font variant\r\n * var fontVariant = shape.fontVariant();\r\n *\r\n * // set font variant\r\n * shape.fontVariant('small-caps');\r\n */\r\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\r\n/**\r\n * get/set text\r\n * @name Konva.TextPath#getText\r\n * @method\r\n * @param {String} text\r\n * @returns {String}\r\n * @example\r\n * // get text\r\n * var text = text.text();\r\n *\r\n * // set text\r\n * text.text('Hello world!');\r\n */\r\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\r\n/**\r\n * get/set text decoration of a text.  Can be '' or 'underline'.\r\n * @name Konva.TextPath#textDecoration\r\n * @method\r\n * @param {String} textDecoration\r\n * @returns {String}\r\n * @example\r\n * // get text decoration\r\n * var textDecoration = shape.textDecoration();\r\n *\r\n * // underline text\r\n * shape.textDecoration('underline');\r\n */\r\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\r\n/**\r\n * get/set kerning function.\r\n * @name Konva.TextPath#kerningFunc\r\n * @method\r\n * @param {String} kerningFunc\r\n * @returns {String}\r\n * @example\r\n * // get text decoration\r\n * var kerningFunc = text.kerningFunc();\r\n *\r\n * // center text\r\n * text.kerningFunc(function(leftChar, rightChar) {\r\n *   return 1;\r\n * });\r\n */\r\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);\r\nCollection.mapMethods(TextPath);\r\n"}
