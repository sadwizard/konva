{"code":"import { Factory } from '../Factory';\r\nimport { Node } from '../Node';\r\nimport { Util } from '../Util';\r\nimport { getNumberValidator } from '../Validators';\r\n/*\r\n * ToPolar Filter. Converts image data to polar coordinates. Performs\r\n *  w*h*4 pixel reads and w*h pixel writes. The r axis is placed along\r\n *  what would be the y axis and the theta axis along the x axis.\r\n * @function\r\n * @author ippo615\r\n * @memberof Konva.Filters\r\n * @param {ImageData} src, the source image data (what will be transformed)\r\n * @param {ImageData} dst, the destination image data (where it will be saved)\r\n * @param {Object} opt\r\n * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,\r\n *  default is in the middle\r\n * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,\r\n *  default is in the middle\r\n */\r\nvar ToPolar = function (src, dst, opt) {\r\n    var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i, x, y, r = 0, g = 0, b = 0, a = 0;\r\n    // Find the largest radius\r\n    var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);\r\n    x = xSize - xMid;\r\n    y = ySize - yMid;\r\n    rad = Math.sqrt(x * x + y * y);\r\n    rMax = rad > rMax ? rad : rMax;\r\n    // We'll be uisng y as the radius, and x as the angle (theta=t)\r\n    var rSize = ySize, tSize = xSize, radius, theta;\r\n    // We want to cover all angles (0-360) and we need to convert to\r\n    // radians (*PI/180)\r\n    var conversion = ((360 / tSize) * Math.PI) / 180, sin, cos;\r\n    // var x1, x2, x1i, x2i, y1, y2, y1i, y2i, scale;\r\n    for (theta = 0; theta < tSize; theta += 1) {\r\n        sin = Math.sin(theta * conversion);\r\n        cos = Math.cos(theta * conversion);\r\n        for (radius = 0; radius < rSize; radius += 1) {\r\n            x = Math.floor(xMid + ((rMax * radius) / rSize) * cos);\r\n            y = Math.floor(yMid + ((rMax * radius) / rSize) * sin);\r\n            i = (y * xSize + x) * 4;\r\n            r = srcPixels[i + 0];\r\n            g = srcPixels[i + 1];\r\n            b = srcPixels[i + 2];\r\n            a = srcPixels[i + 3];\r\n            // Store it\r\n            //i = (theta * xSize  +  radius) * 4;\r\n            i = (theta + radius * xSize) * 4;\r\n            dstPixels[i + 0] = r;\r\n            dstPixels[i + 1] = g;\r\n            dstPixels[i + 2] = b;\r\n            dstPixels[i + 3] = a;\r\n        }\r\n    }\r\n};\r\n/*\r\n * FromPolar Filter. Converts image data from polar coordinates back to rectangular.\r\n *  Performs w*h*4 pixel reads and w*h pixel writes.\r\n * @function\r\n * @author ippo615\r\n * @memberof Konva.Filters\r\n * @param {ImageData} src, the source image data (what will be transformed)\r\n * @param {ImageData} dst, the destination image data (where it will be saved)\r\n * @param {Object} opt\r\n * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,\r\n *  default is in the middle\r\n * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,\r\n *  default is in the middle\r\n * @param {Number} [opt.polarRotation] amount to rotate the image counterclockwis,\r\n *  0 is no rotation, 360 degrees is a full rotation\r\n */\r\nvar FromPolar = function (src, dst, opt) {\r\n    var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i, x, y, dx, dy, r = 0, g = 0, b = 0, a = 0;\r\n    // Find the largest radius\r\n    var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);\r\n    x = xSize - xMid;\r\n    y = ySize - yMid;\r\n    rad = Math.sqrt(x * x + y * y);\r\n    rMax = rad > rMax ? rad : rMax;\r\n    // We'll be uisng x as the radius, and y as the angle (theta=t)\r\n    var rSize = ySize, tSize = xSize, radius, theta, phaseShift = opt.polarRotation || 0;\r\n    // We need to convert to degrees and we need to make sure\r\n    // it's between (0-360)\r\n    // var conversion = tSize/360*180/Math.PI;\r\n    //var conversion = tSize/360*180/Math.PI;\r\n    var x1, y1;\r\n    for (x = 0; x < xSize; x += 1) {\r\n        for (y = 0; y < ySize; y += 1) {\r\n            dx = x - xMid;\r\n            dy = y - yMid;\r\n            radius = (Math.sqrt(dx * dx + dy * dy) * rSize) / rMax;\r\n            theta = ((Math.atan2(dy, dx) * 180) / Math.PI + 360 + phaseShift) % 360;\r\n            theta = (theta * tSize) / 360;\r\n            x1 = Math.floor(theta);\r\n            y1 = Math.floor(radius);\r\n            i = (y1 * xSize + x1) * 4;\r\n            r = srcPixels[i + 0];\r\n            g = srcPixels[i + 1];\r\n            b = srcPixels[i + 2];\r\n            a = srcPixels[i + 3];\r\n            // Store it\r\n            i = (y * xSize + x) * 4;\r\n            dstPixels[i + 0] = r;\r\n            dstPixels[i + 1] = g;\r\n            dstPixels[i + 2] = b;\r\n            dstPixels[i + 3] = a;\r\n        }\r\n    }\r\n};\r\n//Konva.Filters.ToPolar = Util._FilterWrapDoubleBuffer(ToPolar);\r\n//Konva.Filters.FromPolar = Util._FilterWrapDoubleBuffer(FromPolar);\r\n// create a temporary canvas for working - shared between multiple calls\r\n/*\r\n * Kaleidoscope Filter.\r\n * @function\r\n * @name Kaleidoscope\r\n * @author ippo615\r\n * @memberof Konva.Filters\r\n * @example\r\n * node.cache();\r\n * node.filters([Konva.Filters.Kaleidoscope]);\r\n * node.kaleidoscopePower(3);\r\n * node.kaleidoscopeAngle(45);\r\n */\r\nexport var Kaleidoscope = function (imageData) {\r\n    var xSize = imageData.width, ySize = imageData.height;\r\n    var x, y, xoff, i, r, g, b, a, srcPos, dstPos;\r\n    var power = Math.round(this.kaleidoscopePower());\r\n    var angle = Math.round(this.kaleidoscopeAngle());\r\n    var offset = Math.floor((xSize * (angle % 360)) / 360);\r\n    if (power < 1) {\r\n        return;\r\n    }\r\n    // Work with our shared buffer canvas\r\n    var tempCanvas = Util.createCanvasElement();\r\n    tempCanvas.width = xSize;\r\n    tempCanvas.height = ySize;\r\n    var scratchData = tempCanvas\r\n        .getContext('2d')\r\n        .getImageData(0, 0, xSize, ySize);\r\n    // Convert thhe original to polar coordinates\r\n    ToPolar(imageData, scratchData, {\r\n        polarCenterX: xSize / 2,\r\n        polarCenterY: ySize / 2\r\n    });\r\n    // Determine how big each section will be, if it's too small\r\n    // make it bigger\r\n    var minSectionSize = xSize / Math.pow(2, power);\r\n    while (minSectionSize <= 8) {\r\n        minSectionSize = minSectionSize * 2;\r\n        power -= 1;\r\n    }\r\n    minSectionSize = Math.ceil(minSectionSize);\r\n    var sectionSize = minSectionSize;\r\n    // Copy the offset region to 0\r\n    // Depending on the size of filter and location of the offset we may need\r\n    // to copy the section backwards to prevent it from rewriting itself\r\n    var xStart = 0, xEnd = sectionSize, xDelta = 1;\r\n    if (offset + minSectionSize > xSize) {\r\n        xStart = sectionSize;\r\n        xEnd = 0;\r\n        xDelta = -1;\r\n    }\r\n    for (y = 0; y < ySize; y += 1) {\r\n        for (x = xStart; x !== xEnd; x += xDelta) {\r\n            xoff = Math.round(x + offset) % xSize;\r\n            srcPos = (xSize * y + xoff) * 4;\r\n            r = scratchData.data[srcPos + 0];\r\n            g = scratchData.data[srcPos + 1];\r\n            b = scratchData.data[srcPos + 2];\r\n            a = scratchData.data[srcPos + 3];\r\n            dstPos = (xSize * y + x) * 4;\r\n            scratchData.data[dstPos + 0] = r;\r\n            scratchData.data[dstPos + 1] = g;\r\n            scratchData.data[dstPos + 2] = b;\r\n            scratchData.data[dstPos + 3] = a;\r\n        }\r\n    }\r\n    // Perform the actual effect\r\n    for (y = 0; y < ySize; y += 1) {\r\n        sectionSize = Math.floor(minSectionSize);\r\n        for (i = 0; i < power; i += 1) {\r\n            for (x = 0; x < sectionSize + 1; x += 1) {\r\n                srcPos = (xSize * y + x) * 4;\r\n                r = scratchData.data[srcPos + 0];\r\n                g = scratchData.data[srcPos + 1];\r\n                b = scratchData.data[srcPos + 2];\r\n                a = scratchData.data[srcPos + 3];\r\n                dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;\r\n                scratchData.data[dstPos + 0] = r;\r\n                scratchData.data[dstPos + 1] = g;\r\n                scratchData.data[dstPos + 2] = b;\r\n                scratchData.data[dstPos + 3] = a;\r\n            }\r\n            sectionSize *= 2;\r\n        }\r\n    }\r\n    // Convert back from polar coordinates\r\n    FromPolar(scratchData, imageData, { polarRotation: 0 });\r\n};\r\n/**\r\n * get/set kaleidoscope power. Use with {@link Konva.Filters.Kaleidoscope} filter.\r\n * @name Konva.Node#kaleidoscopePower\r\n * @method\r\n * @param {Integer} power of kaleidoscope\r\n * @returns {Integer}\r\n */\r\nFactory.addGetterSetter(Node, 'kaleidoscopePower', 2, getNumberValidator(), Factory.afterSetFilter);\r\n/**\r\n * get/set kaleidoscope angle. Use with {@link Konva.Filters.Kaleidoscope} filter.\r\n * @name Konva.Node#kaleidoscopeAngle\r\n * @method\r\n * @param {Integer} degrees\r\n * @returns {Integer}\r\n */\r\nFactory.addGetterSetter(Node, 'kaleidoscopeAngle', 0, getNumberValidator(), Factory.afterSetFilter);\r\n"}
