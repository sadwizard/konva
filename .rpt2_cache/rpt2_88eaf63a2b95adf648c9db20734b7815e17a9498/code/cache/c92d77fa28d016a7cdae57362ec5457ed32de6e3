{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Util, Collection } from '../Util';\r\nimport { Factory } from '../Factory';\r\nimport { Shape } from '../Shape';\r\nimport { Konva } from '../Global';\r\nimport { getNumberValidator, getStringValidator, getNumberOrAutoValidator } from '../Validators';\r\nimport { _registerNode } from '../Global';\r\n// constants\r\nvar AUTO = 'auto', \r\n//CANVAS = 'canvas',\r\nCENTER = 'center', JUSTIFY = 'justify', CHANGE_KONVA = 'Change.konva', CONTEXT_2D = '2d', DASH = '-', LEFT = 'left', TEXT = 'text', TEXT_UPPER = 'Text', TOP = 'top', BOTTOM = 'bottom', MIDDLE = 'middle', NORMAL = 'normal', PX_SPACE = 'px ', SPACE = ' ', RIGHT = 'right', WORD = 'word', CHAR = 'char', NONE = 'none', ELLIPSIS = 'â€¦', ATTR_CHANGE_LIST = [\r\n    'fontFamily',\r\n    'fontSize',\r\n    'fontStyle',\r\n    'fontVariant',\r\n    'padding',\r\n    'align',\r\n    'verticalAlign',\r\n    'lineHeight',\r\n    'text',\r\n    'width',\r\n    'height',\r\n    'wrap',\r\n    'ellipsis',\r\n    'letterSpacing'\r\n], \r\n// cached variables\r\nattrChangeListLen = ATTR_CHANGE_LIST.length;\r\nvar dummyContext;\r\nfunction getDummyContext() {\r\n    if (dummyContext) {\r\n        return dummyContext;\r\n    }\r\n    dummyContext = Util.createCanvasElement().getContext(CONTEXT_2D);\r\n    return dummyContext;\r\n}\r\nfunction _fillFunc(context) {\r\n    context.fillText(this._partialText, this._partialTextX, this._partialTextY);\r\n}\r\nfunction _strokeFunc(context) {\r\n    context.strokeText(this._partialText, this._partialTextX, this._partialTextY);\r\n}\r\nfunction checkDefaultFill(config) {\r\n    config = config || {};\r\n    // set default color to black\r\n    if (!config.fillLinearGradientColorStops &&\r\n        !config.fillRadialGradientColorStops &&\r\n        !config.fillPatternImage) {\r\n        config.fill = config.fill || 'black';\r\n    }\r\n    return config;\r\n}\r\n/**\r\n * Text constructor\r\n * @constructor\r\n * @memberof Konva\r\n * @augments Konva.Shape\r\n * @param {Object} config\r\n * @param {String} [config.fontFamily] default is Arial\r\n * @param {Number} [config.fontSize] in pixels.  Default is 12\r\n * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal\r\n * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal\r\n * @param {String} [config.textDecoration] can be line-through, underline or empty string. Default is empty string.\r\n * @param {String} config.text\r\n * @param {String} [config.align] can be left, center, or right\r\n * @param {String} [config.verticalAlign] can be top, middle or bottom\r\n * @param {Number} [config.padding]\r\n * @param {Number} [config.lineHeight] default is 1\r\n * @param {String} [config.wrap] can be \"word\", \"char\", or \"none\". Default is word\r\n * @param {Boolean} [config.ellipsis] can be true or false. Default is false. if Konva.Text config is set to wrap=\"none\" and ellipsis=true, then it will add \"...\" to the end\r\n * @@shapeParams\r\n * @@nodeParams\r\n * @example\r\n * var text = new Konva.Text({\r\n *   x: 10,\r\n *   y: 15,\r\n *   text: 'Simple Text',\r\n *   fontSize: 30,\r\n *   fontFamily: 'Calibri',\r\n *   fill: 'green'\r\n * });\r\n */\r\nvar Text = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Text, _super);\r\n    function Text(config) {\r\n        var _this = _super.call(this, checkDefaultFill(config)) || this;\r\n        _this._partialTextX = 0;\r\n        _this._partialTextY = 0;\r\n        // update text data for certain attr changes\r\n        for (var n = 0; n < attrChangeListLen; n++) {\r\n            _this.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, _this._setTextData);\r\n        }\r\n        _this._setTextData();\r\n        return _this;\r\n    }\r\n    Text.prototype._sceneFunc = function (context) {\r\n        var padding = this.padding(), fontSize = this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, textArr = this.textArr, textArrLen = textArr.length, verticalAlign = this.verticalAlign(), alignY = 0, align = this.align(), totalWidth = this.getWidth(), letterSpacing = this.letterSpacing(), fill = this.fill(), textDecoration = this.textDecoration(), shouldUnderline = textDecoration.indexOf('underline') !== -1, shouldLineThrough = textDecoration.indexOf('line-through') !== -1, n;\r\n        var translateY = 0;\r\n        var translateY = lineHeightPx / 2;\r\n        var lineTranslateX = 0;\r\n        var lineTranslateY = 0;\r\n        context.setAttr('font', this._getContextFont());\r\n        context.setAttr('textBaseline', MIDDLE);\r\n        context.setAttr('textAlign', LEFT);\r\n        // handle vertical alignment\r\n        if (verticalAlign === MIDDLE) {\r\n            alignY = (this.getHeight() - textArrLen * lineHeightPx - padding * 2) / 2;\r\n        }\r\n        else if (verticalAlign === BOTTOM) {\r\n            alignY = this.getHeight() - textArrLen * lineHeightPx - padding * 2;\r\n        }\r\n        context.translate(padding, alignY + padding);\r\n        // draw text lines\r\n        for (n = 0; n < textArrLen; n++) {\r\n            var lineTranslateX = 0;\r\n            var lineTranslateY = 0;\r\n            var obj = textArr[n], text = obj.text, width = obj.width, lastLine = n !== textArrLen - 1, spacesNumber, oneWord, lineWidth;\r\n            // horizontal alignment\r\n            context.save();\r\n            if (align === RIGHT) {\r\n                lineTranslateX += totalWidth - width - padding * 2;\r\n            }\r\n            else if (align === CENTER) {\r\n                lineTranslateX += (totalWidth - width - padding * 2) / 2;\r\n            }\r\n            if (shouldUnderline) {\r\n                context.save();\r\n                context.beginPath();\r\n                context.moveTo(lineTranslateX, translateY + lineTranslateY + Math.round(fontSize / 2));\r\n                spacesNumber = text.split(' ').length - 1;\r\n                oneWord = spacesNumber === 0;\r\n                lineWidth =\r\n                    align === JUSTIFY && lastLine && !oneWord\r\n                        ? totalWidth - padding * 2\r\n                        : width;\r\n                context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY + Math.round(fontSize / 2));\r\n                // I have no idea what is real ratio\r\n                // just /15 looks good enough\r\n                context.lineWidth = fontSize / 15;\r\n                context.strokeStyle = fill;\r\n                context.stroke();\r\n                context.restore();\r\n            }\r\n            if (shouldLineThrough) {\r\n                context.save();\r\n                context.beginPath();\r\n                context.moveTo(lineTranslateX, translateY + lineTranslateY);\r\n                spacesNumber = text.split(' ').length - 1;\r\n                oneWord = spacesNumber === 0;\r\n                lineWidth =\r\n                    align === JUSTIFY && lastLine && !oneWord\r\n                        ? totalWidth - padding * 2\r\n                        : width;\r\n                context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY);\r\n                context.lineWidth = fontSize / 15;\r\n                context.strokeStyle = fill;\r\n                context.stroke();\r\n                context.restore();\r\n            }\r\n            if (letterSpacing !== 0 || align === JUSTIFY) {\r\n                //   var words = text.split(' ');\r\n                spacesNumber = text.split(' ').length - 1;\r\n                for (var li = 0; li < text.length; li++) {\r\n                    var letter = text[li];\r\n                    // skip justify for the last line\r\n                    if (letter === ' ' && n !== textArrLen - 1 && align === JUSTIFY) {\r\n                        lineTranslateX += Math.floor((totalWidth - padding * 2 - width) / spacesNumber);\r\n                        // context.translate(\r\n                        //   Math.floor((totalWidth - padding * 2 - width) / spacesNumber),\r\n                        //   0\r\n                        // );\r\n                    }\r\n                    this._partialTextX = lineTranslateX;\r\n                    this._partialTextY = translateY + lineTranslateY;\r\n                    this._partialText = letter;\r\n                    context.fillStrokeShape(this);\r\n                    lineTranslateX +=\r\n                        Math.round(this.measureSize(letter).width) + letterSpacing;\r\n                }\r\n            }\r\n            else {\r\n                this._partialTextX = lineTranslateX;\r\n                this._partialTextY = translateY + lineTranslateY;\r\n                this._partialText = text;\r\n                context.fillStrokeShape(this);\r\n            }\r\n            context.restore();\r\n            if (textArrLen > 1) {\r\n                translateY += lineHeightPx;\r\n            }\r\n        }\r\n    };\r\n    Text.prototype._hitFunc = function (context) {\r\n        var width = this.getWidth(), height = this.getHeight();\r\n        context.beginPath();\r\n        context.rect(0, 0, width, height);\r\n        context.closePath();\r\n        context.fillStrokeShape(this);\r\n    };\r\n    Text.prototype.setText = function (text) {\r\n        var str = Util._isString(text) ? text : (text || '').toString();\r\n        this._setAttr(TEXT, str);\r\n        return this;\r\n    };\r\n    Text.prototype.getWidth = function () {\r\n        var isAuto = this.attrs.width === AUTO || this.attrs.width === undefined;\r\n        return isAuto ? this.getTextWidth() + this.padding() * 2 : this.attrs.width;\r\n    };\r\n    Text.prototype.getHeight = function () {\r\n        var isAuto = this.attrs.height === AUTO || this.attrs.height === undefined;\r\n        return isAuto\r\n            ? this.fontSize() * this.textArr.length * this.lineHeight() +\r\n                this.padding() * 2\r\n            : this.attrs.height;\r\n    };\r\n    /**\r\n     * get pure text width without padding\r\n     * @method\r\n     * @name Konva.Text#getTextWidth\r\n     * @returns {Number}\r\n     */\r\n    Text.prototype.getTextWidth = function () {\r\n        return this.textWidth;\r\n    };\r\n    Text.prototype.getTextHeight = function () {\r\n        Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\r\n        return this.textHeight;\r\n    };\r\n    /**\r\n     * measure string with the font of current text shape.\r\n     * That method can't handle multiline text.\r\n     * @method\r\n     * @name Konva.Text#measureSize\r\n     * @param {String} [text] text to measure\r\n     * @returns {Object} { width , height} of measured text\r\n     */\r\n    Text.prototype.measureSize = function (text) {\r\n        var _context = getDummyContext(), fontSize = this.fontSize(), metrics;\r\n        _context.save();\r\n        _context.font = this._getContextFont();\r\n        metrics = _context.measureText(text);\r\n        _context.restore();\r\n        return {\r\n            width: metrics.width,\r\n            height: fontSize\r\n        };\r\n    };\r\n    Text.prototype._getContextFont = function () {\r\n        // IE don't want to work with usual font style\r\n        // bold was not working\r\n        // removing font variant will solve\r\n        // fix for: https://github.com/konvajs/konva/issues/94\r\n        if (Konva.UA.isIE) {\r\n            return (this.fontStyle() +\r\n                SPACE +\r\n                this.fontSize() +\r\n                PX_SPACE +\r\n                this.fontFamily());\r\n        }\r\n        return (this.fontStyle() +\r\n            SPACE +\r\n            this.fontVariant() +\r\n            SPACE +\r\n            this.fontSize() +\r\n            PX_SPACE +\r\n            this.fontFamily());\r\n    };\r\n    Text.prototype._addTextLine = function (line) {\r\n        if (this.align() === JUSTIFY) {\r\n            line = line.trim();\r\n        }\r\n        var width = this._getTextWidth(line);\r\n        return this.textArr.push({ text: line, width: width });\r\n    };\r\n    Text.prototype._getTextWidth = function (text) {\r\n        var letterSpacing = this.letterSpacing();\r\n        var length = text.length;\r\n        return (getDummyContext().measureText(text).width +\r\n            (length ? letterSpacing * (length - 1) : 0));\r\n    };\r\n    Text.prototype._setTextData = function () {\r\n        var lines = this.text().split('\\n'), fontSize = +this.fontSize(), textWidth = 0, lineHeightPx = this.lineHeight() * fontSize, width = this.attrs.width, height = this.attrs.height, fixedWidth = width !== AUTO && width !== undefined, fixedHeight = height !== AUTO && height !== undefined, padding = this.padding(), maxWidth = width - padding * 2, maxHeightPx = height - padding * 2, currentHeightPx = 0, wrap = this.wrap(), \r\n        // align = this.align(),\r\n        shouldWrap = wrap !== NONE, wrapAtWord = wrap !== CHAR && shouldWrap, shouldAddEllipsis = this.ellipsis() && !shouldWrap;\r\n        this.textArr = [];\r\n        getDummyContext().font = this._getContextFont();\r\n        var additionalWidth = shouldAddEllipsis ? this._getTextWidth(ELLIPSIS) : 0;\r\n        for (var i = 0, max = lines.length; i < max; ++i) {\r\n            var line = lines[i];\r\n            var lineWidth = this._getTextWidth(line);\r\n            if (fixedWidth && lineWidth > maxWidth) {\r\n                /*\r\n                 * if width is fixed and line does not fit entirely\r\n                 * break the line into multiple fitting lines\r\n                 */\r\n                while (line.length > 0) {\r\n                    /*\r\n                     * use binary search to find the longest substring that\r\n                     * that would fit in the specified width\r\n                     */\r\n                    var low = 0, high = line.length, match = '', matchWidth = 0;\r\n                    while (low < high) {\r\n                        var mid = (low + high) >>> 1, substr = line.slice(0, mid + 1), substrWidth = this._getTextWidth(substr) + additionalWidth;\r\n                        if (substrWidth <= maxWidth) {\r\n                            low = mid + 1;\r\n                            match = substr + (shouldAddEllipsis ? ELLIPSIS : '');\r\n                            matchWidth = substrWidth;\r\n                        }\r\n                        else {\r\n                            high = mid;\r\n                        }\r\n                    }\r\n                    /*\r\n                     * 'low' is now the index of the substring end\r\n                     * 'match' is the substring\r\n                     * 'matchWidth' is the substring width in px\r\n                     */\r\n                    if (match) {\r\n                        // a fitting substring was found\r\n                        if (wrapAtWord) {\r\n                            // try to find a space or dash where wrapping could be done\r\n                            var wrapIndex;\r\n                            var nextChar = line[match.length];\r\n                            var nextIsSpaceOrDash = nextChar === SPACE || nextChar === DASH;\r\n                            if (nextIsSpaceOrDash && matchWidth <= maxWidth) {\r\n                                wrapIndex = match.length;\r\n                            }\r\n                            else {\r\n                                wrapIndex =\r\n                                    Math.max(match.lastIndexOf(SPACE), match.lastIndexOf(DASH)) +\r\n                                        1;\r\n                            }\r\n                            if (wrapIndex > 0) {\r\n                                // re-cut the substring found at the space/dash position\r\n                                low = wrapIndex;\r\n                                match = match.slice(0, low);\r\n                                matchWidth = this._getTextWidth(match);\r\n                            }\r\n                        }\r\n                        // if (align === 'right') {\r\n                        match = match.trimRight();\r\n                        // }\r\n                        this._addTextLine(match);\r\n                        textWidth = Math.max(textWidth, matchWidth);\r\n                        currentHeightPx += lineHeightPx;\r\n                        if (!shouldWrap ||\r\n                            (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx)) {\r\n                            /*\r\n                             * stop wrapping if wrapping is disabled or if adding\r\n                             * one more line would overflow the fixed height\r\n                             */\r\n                            break;\r\n                        }\r\n                        line = line.slice(low);\r\n                        line = line.trimLeft();\r\n                        if (line.length > 0) {\r\n                            // Check if the remaining text would fit on one line\r\n                            lineWidth = this._getTextWidth(line);\r\n                            if (lineWidth <= maxWidth) {\r\n                                // if it does, add the line and break out of the loop\r\n                                this._addTextLine(line);\r\n                                currentHeightPx += lineHeightPx;\r\n                                textWidth = Math.max(textWidth, lineWidth);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        // not even one character could fit in the element, abort\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // element width is automatically adjusted to max line width\r\n                this._addTextLine(line);\r\n                currentHeightPx += lineHeightPx;\r\n                textWidth = Math.max(textWidth, lineWidth);\r\n            }\r\n            // if element height is fixed, abort if adding one more line would overflow\r\n            if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {\r\n                break;\r\n            }\r\n        }\r\n        this.textHeight = fontSize;\r\n        // var maxTextWidth = 0;\r\n        // for(var j = 0; j < this.textArr.length; j++) {\r\n        //     maxTextWidth = Math.max(maxTextWidth, this.textArr[j].width);\r\n        // }\r\n        this.textWidth = textWidth;\r\n    };\r\n    // for text we can't disable stroke scaling\r\n    // if we do, the result will be unexpected\r\n    Text.prototype.getStrokeScaleEnabled = function () {\r\n        return true;\r\n    };\r\n    return Text;\r\n}(Shape));\r\nexport { Text };\r\nText.prototype._fillFunc = _fillFunc;\r\nText.prototype._strokeFunc = _strokeFunc;\r\nText.prototype.className = TEXT_UPPER;\r\nText.prototype._attrsAffectingSize = [\r\n    'text',\r\n    'fontSize',\r\n    'padding',\r\n    'wrap',\r\n    'lineHeight'\r\n];\r\n_registerNode(Text);\r\n/**\r\n * get/set width of text area, which includes padding.\r\n * @name Konva.Text#width\r\n * @method\r\n * @param {Number} width\r\n * @returns {Number}\r\n * @example\r\n * // get width\r\n * var width = text.width();\r\n *\r\n * // set width\r\n * text.width(20);\r\n *\r\n * // set to auto\r\n * text.width('auto');\r\n * text.width() // will return calculated width, and not \"auto\"\r\n */\r\nFactory.overWriteSetter(Text, 'width', getNumberOrAutoValidator());\r\n/**\r\n * get/set the height of the text area, which takes into account multi-line text, line heights, and padding.\r\n * @name Konva.Text#height\r\n * @method\r\n * @param {Number} height\r\n * @returns {Number}\r\n * @example\r\n * // get height\r\n * var height = text.height();\r\n *\r\n * // set height\r\n * text.height(20);\r\n *\r\n * // set to auto\r\n * text.height('auto');\r\n * text.height() // will return calculated height, and not \"auto\"\r\n */\r\nFactory.overWriteSetter(Text, 'height', getNumberOrAutoValidator());\r\n/**\r\n * get/set font family\r\n * @name Konva.Text#fontFamily\r\n * @method\r\n * @param {String} fontFamily\r\n * @returns {String}\r\n * @example\r\n * // get font family\r\n * var fontFamily = text.fontFamily();\r\n *\r\n * // set font family\r\n * text.fontFamily('Arial');\r\n */\r\nFactory.addGetterSetter(Text, 'fontFamily', 'Arial');\r\n/**\r\n * get/set font size in pixels\r\n * @name Konva.Text#fontSize\r\n * @method\r\n * @param {Number} fontSize\r\n * @returns {Number}\r\n * @example\r\n * // get font size\r\n * var fontSize = text.fontSize();\r\n *\r\n * // set font size to 22px\r\n * text.fontSize(22);\r\n */\r\nFactory.addGetterSetter(Text, 'fontSize', 12, getNumberValidator());\r\n/**\r\n * get/set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.\r\n * @name Konva.Text#fontStyle\r\n * @method\r\n * @param {String} fontStyle\r\n * @returns {String}\r\n * @example\r\n * // get font style\r\n * var fontStyle = text.fontStyle();\r\n *\r\n * // set font style\r\n * text.fontStyle('bold');\r\n */\r\nFactory.addGetterSetter(Text, 'fontStyle', NORMAL);\r\n/**\r\n * get/set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.\r\n * @name Konva.Text#fontVariant\r\n * @method\r\n * @param {String} fontVariant\r\n * @returns {String}\r\n * @example\r\n * // get font variant\r\n * var fontVariant = text.fontVariant();\r\n *\r\n * // set font variant\r\n * text.fontVariant('small-caps');\r\n */\r\nFactory.addGetterSetter(Text, 'fontVariant', NORMAL);\r\n/**\r\n * get/set padding\r\n * @name Konva.Text#padding\r\n * @method\r\n * @param {Number} padding\r\n * @returns {Number}\r\n * @example\r\n * // get padding\r\n * var padding = text.padding();\r\n *\r\n * // set padding to 10 pixels\r\n * text.padding(10);\r\n */\r\nFactory.addGetterSetter(Text, 'padding', 0, getNumberValidator());\r\n/**\r\n * get/set horizontal align of text.  Can be 'left', 'center', 'right' or 'justify'\r\n * @name Konva.Text#align\r\n * @method\r\n * @param {String} align\r\n * @returns {String}\r\n * @example\r\n * // get text align\r\n * var align = text.align();\r\n *\r\n * // center text\r\n * text.align('center');\r\n *\r\n * // align text to right\r\n * text.align('right');\r\n */\r\nFactory.addGetterSetter(Text, 'align', LEFT);\r\n/**\r\n * get/set vertical align of text.  Can be 'top', 'middle', 'bottom'.\r\n * @name Konva.Text#verticalAlign\r\n * @method\r\n * @param {String} verticalAlign\r\n * @returns {String}\r\n * @example\r\n * // get text vertical align\r\n * var verticalAlign = text.verticalAlign();\r\n *\r\n * // center text\r\n * text.verticalAlign('middle');\r\n */\r\nFactory.addGetterSetter(Text, 'verticalAlign', TOP);\r\n/**\r\n * get/set line height.  The default is 1.\r\n * @name Konva.Text#lineHeight\r\n * @method\r\n * @param {Number} lineHeight\r\n * @returns {Number}\r\n * @example\r\n * // get line height\r\n * var lineHeight = text.lineHeight();\r\n *\r\n * // set the line height\r\n * text.lineHeight(2);\r\n */\r\nFactory.addGetterSetter(Text, 'lineHeight', 1, getNumberValidator());\r\n/**\r\n * get/set wrap.  Can be \"word\", \"char\", or \"none\". Default is \"word\".\r\n * In \"word\" wrapping any word still can be wrapped if it can't be placed in the required width\r\n * without breaks.\r\n * @name Konva.Text#wrap\r\n * @method\r\n * @param {String} wrap\r\n * @returns {String}\r\n * @example\r\n * // get wrap\r\n * var wrap = text.wrap();\r\n *\r\n * // set wrap\r\n * text.wrap('word');\r\n */\r\nFactory.addGetterSetter(Text, 'wrap', WORD);\r\n/**\r\n * get/set ellipsis.  Can be true or false. Default is false.\r\n * if Konva.Text config is set to wrap=\"none\" and ellipsis=true, then it will add \"...\" to the end\r\n * @name Konva.Text#ellipsis\r\n * @method\r\n * @param {Boolean} ellipsis\r\n * @returns {Boolean}\r\n * @example\r\n * // get ellipsis\r\n * var ellipsis = text.ellipsis();\r\n *\r\n * // set ellipsis\r\n * text.ellipsis(true);\r\n */\r\nFactory.addGetterSetter(Text, 'ellipsis', false);\r\n/**\r\n * set letter spacing property. Default value is 0.\r\n * @name Konva.Text#letterSpacing\r\n * @method\r\n * @param {Number} letterSpacing\r\n */\r\nFactory.addGetterSetter(Text, 'letterSpacing', 0, getNumberValidator());\r\n/**\r\n * get/set text\r\n * @name Konva.Text#text\r\n * @method\r\n * @param {String} text\r\n * @returns {String}\r\n * @example\r\n * // get text\r\n * var text = text.text();\r\n *\r\n * // set text\r\n * text.text('Hello world!');\r\n */\r\nFactory.addGetterSetter(Text, 'text', '', getStringValidator());\r\n/**\r\n * get/set text decoration of a text.  Possible values are 'underline', 'line-through' or combination of these values separated by space\r\n * @name Konva.Text#textDecoration\r\n * @method\r\n * @param {String} textDecoration\r\n * @returns {String}\r\n * @example\r\n * // get text decoration\r\n * var textDecoration = text.textDecoration();\r\n *\r\n * // underline text\r\n * text.textDecoration('underline');\r\n *\r\n * // strike text\r\n * text.textDecoration('line-through');\r\n *\r\n * // underline and strike text\r\n * text.textDecoration('underline line-through');\r\n */\r\nFactory.addGetterSetter(Text, 'textDecoration', '');\r\nCollection.mapMethods(Text);\r\n"}
