{"code":"import * as tslib_1 from \"tslib\";\r\nimport { Util, Collection } from '../Util';\r\nimport { Factory } from '../Factory';\r\nimport { Node } from '../Node';\r\nimport { Shape } from '../Shape';\r\nimport { Rect } from './Rect';\r\nimport { Group } from '../Group';\r\nimport { Konva } from '../Global';\r\nimport { getNumberValidator } from '../Validators';\r\nimport { _registerNode } from '../Global';\r\nvar ATTR_CHANGE_LIST = [\r\n    'resizeEnabledChange',\r\n    'rotateAnchorOffsetChange',\r\n    'rotateEnabledChange',\r\n    'enabledAnchorsChange',\r\n    'anchorSizeChange',\r\n    'borderEnabledChange',\r\n    'borderStrokeChange',\r\n    'borderStrokeWidthChange',\r\n    'borderDashChange',\r\n    'anchorStrokeChange',\r\n    'anchorStrokeWidthChange',\r\n    'anchorFillChange',\r\n    'anchorCornerRadiusChange',\r\n    'ignoreStrokeChange'\r\n].join(' ');\r\nvar NODE_RECT = 'nodeRect';\r\nvar TRANSFORM_CHANGE_STR = [\r\n    'widthChange.tr',\r\n    'heightChange.tr',\r\n    'scaleXChange.tr',\r\n    'scaleYChange.tr',\r\n    'skewXChange.tr',\r\n    'skewYChange.tr',\r\n    'rotationChange.tr',\r\n    'offsetXChange.tr',\r\n    'offsetYChange.tr',\r\n    'transformsEnabledChange.tr',\r\n    'strokeWidthChange.tr'\r\n].join(' ');\r\nvar ANGLES = {\r\n    'top-left': -45,\r\n    'top-center': 0,\r\n    'top-right': 45,\r\n    'middle-right': -90,\r\n    'middle-left': 90,\r\n    'bottom-left': -135,\r\n    'bottom-center': 180,\r\n    'bottom-right': 135\r\n};\r\nfunction getCursor(anchorName, rad, isMirrored) {\r\n    if (anchorName === 'rotater') {\r\n        return 'crosshair';\r\n    }\r\n    rad += Util._degToRad(ANGLES[anchorName] || 0);\r\n    // If we are mirrored, we need to mirror the angle (this is not the same as\r\n    // rotate).\r\n    if (isMirrored) {\r\n        rad *= -1;\r\n    }\r\n    var angle = ((Util._radToDeg(rad) % 360) + 360) % 360;\r\n    if (Util._inRange(angle, 315 + 22.5, 360) || Util._inRange(angle, 0, 22.5)) {\r\n        // TOP\r\n        return 'ns-resize';\r\n    }\r\n    else if (Util._inRange(angle, 45 - 22.5, 45 + 22.5)) {\r\n        // TOP - RIGHT\r\n        return 'nesw-resize';\r\n    }\r\n    else if (Util._inRange(angle, 90 - 22.5, 90 + 22.5)) {\r\n        // RIGHT\r\n        return 'ew-resize';\r\n    }\r\n    else if (Util._inRange(angle, 135 - 22.5, 135 + 22.5)) {\r\n        // BOTTOM - RIGHT\r\n        return 'nwse-resize';\r\n    }\r\n    else if (Util._inRange(angle, 180 - 22.5, 180 + 22.5)) {\r\n        // BOTTOM\r\n        return 'ns-resize';\r\n    }\r\n    else if (Util._inRange(angle, 225 - 22.5, 225 + 22.5)) {\r\n        // BOTTOM - LEFT\r\n        return 'nesw-resize';\r\n    }\r\n    else if (Util._inRange(angle, 270 - 22.5, 270 + 22.5)) {\r\n        // RIGHT\r\n        return 'ew-resize';\r\n    }\r\n    else if (Util._inRange(angle, 315 - 22.5, 315 + 22.5)) {\r\n        // BOTTOM - RIGHT\r\n        return 'nwse-resize';\r\n    }\r\n    else {\r\n        // how can we can there?\r\n        Util.error('Transformer has unknown angle for cursor detection: ' + angle);\r\n        return 'pointer';\r\n    }\r\n}\r\nvar ANCHORS_NAMES = [\r\n    'top-left',\r\n    'top-center',\r\n    'top-right',\r\n    'middle-right',\r\n    'middle-left',\r\n    'bottom-left',\r\n    'bottom-center',\r\n    'bottom-right'\r\n];\r\nvar MAX_SAFE_INTEGER = 100000000;\r\n/**\r\n * Transformer constructor.  Transformer is a special type of group that allow you transform Konva\r\n * primitives and shapes. Transforming tool is not changing `width` and `height` properties of nodes\r\n * when you resize them. Instead it changes `scaleX` and `scaleY` properties.\r\n * @constructor\r\n * @memberof Konva\r\n * @param {Object} config\r\n * @param {Boolean} [config.resizeEnabled] Default is true\r\n * @param {Boolean} [config.rotateEnabled] Default is true\r\n * @param {Array} [config.rotationSnaps] Array of angles for rotation snaps. Default is []\r\n * @param {Number} [config.rotateAnchorOffset] Default is 50\r\n * @param {Number} [config.padding] Default is 0\r\n * @param {Boolean} [config.borderEnabled] Should we draw border? Default is true\r\n * @param {String} [config.borderStroke] Border stroke color\r\n * @param {Number} [config.borderStrokeWidth] Border stroke size\r\n * @param {Array} [config.borderDash] Array for border dash.\r\n * @param {String} [config.anchorFill] Anchor fill color\r\n * @param {String} [config.anchorStroke] Anchor stroke color\r\n * @param {String} [config.anchorCornerRadius] Anchor corner radius\r\n * @param {Number} [config.anchorStrokeWidth] Anchor stroke size\r\n * @param {Number} [config.anchorSize] Default is 10\r\n * @param {Boolean} [config.keepRatio] Should we keep ratio when we are moving edges? Default is true\r\n * @param {Boolean} [config.centeredScaling] Should we resize relative to node's center? Default is false\r\n * @param {Array} [config.enabledAnchors] Array of names of enabled handles\r\n * @param {Function} [config.boundBoxFunc] Bounding box function\r\n * @param {Function} [config.ignoreStroke] Should we ignore stroke size? Default is false\r\n *\r\n * @example\r\n * var transformer = new Konva.Transformer({\r\n *   node: rectangle,\r\n *   rotateAnchorOffset: 60,\r\n *   enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right']\r\n * });\r\n * layer.add(transformer);\r\n */\r\nvar Transformer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Transformer, _super);\r\n    function Transformer(config) {\r\n        var _this = \r\n        // call super constructor\r\n        _super.call(this, config) || this;\r\n        _this._transforming = false;\r\n        _this._createElements();\r\n        // bindings\r\n        _this._handleMouseMove = _this._handleMouseMove.bind(_this);\r\n        _this._handleMouseUp = _this._handleMouseUp.bind(_this);\r\n        _this.update = _this.update.bind(_this);\r\n        // update transformer data for certain attr changes\r\n        _this.on(ATTR_CHANGE_LIST, _this.update);\r\n        if (_this.getNode()) {\r\n            _this.update();\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * alias to `tr.node(shape)`\r\n     * @method\r\n     * @name Konva.Transformer#attachTo\r\n     * @returns {Konva.Transformer}\r\n     * @example\r\n     * transformer.attachTo(shape);\r\n     */\r\n    Transformer.prototype.attachTo = function (node) {\r\n        this.setNode(node);\r\n        return this;\r\n    };\r\n    Transformer.prototype.setNode = function (node) {\r\n        var _this = this;\r\n        if (this._node) {\r\n            this.detach();\r\n        }\r\n        this._node = node;\r\n        this._resetTransformCache();\r\n        var additionalEvents = node._attrsAffectingSize\r\n            .map(function (prop) { return prop + 'Change.tr'; })\r\n            .join(' ');\r\n        var onChange = function () {\r\n            _this._resetTransformCache();\r\n            if (!_this._transforming) {\r\n                _this.update();\r\n            }\r\n        };\r\n        node.on(additionalEvents, onChange);\r\n        node.on(TRANSFORM_CHANGE_STR, onChange);\r\n        node.on('xChange.tr yChange.tr', function () { return _this._resetTransformCache(); });\r\n        // we may need it if we set node in initial props\r\n        // so elements are not defined yet\r\n        var elementsCreated = !!this.findOne('.top-left');\r\n        if (elementsCreated) {\r\n            this.update();\r\n        }\r\n        return this;\r\n    };\r\n    Transformer.prototype.getNode = function () {\r\n        return this._node;\r\n    };\r\n    /**\r\n     * detach transformer from an attached node\r\n     * @method\r\n     * @name Konva.Transformer#detach\r\n     * @returns {Konva.Transformer}\r\n     * @example\r\n     * transformer.detach();\r\n     */\r\n    Transformer.prototype.detach = function () {\r\n        if (this.getNode()) {\r\n            this.getNode().off('.tr');\r\n            this._node = undefined;\r\n        }\r\n        this._resetTransformCache();\r\n    };\r\n    Transformer.prototype._resetTransformCache = function () {\r\n        this._clearCache(NODE_RECT);\r\n        this._clearCache('transform');\r\n        this._clearSelfAndDescendantCache('absoluteTransform');\r\n    };\r\n    Transformer.prototype._getNodeRect = function () {\r\n        return this._getCache(NODE_RECT, this.__getNodeRect);\r\n    };\r\n    Transformer.prototype.__getNodeRect = function () {\r\n        var node = this.getNode();\r\n        if (!node) {\r\n            return {\r\n                x: -MAX_SAFE_INTEGER,\r\n                y: -MAX_SAFE_INTEGER,\r\n                width: 0,\r\n                height: 0,\r\n                rotation: 0\r\n            };\r\n        }\r\n        if (node.parent && this.parent && node.parent !== this.parent) {\r\n            Util.warn('Transformer and attached node have different parents. Konva does not support such case right now. Please move Transformer to the parent of attaching node.');\r\n        }\r\n        var rect = node.getClientRect({\r\n            skipTransform: true,\r\n            skipShadow: true,\r\n            skipStroke: this.ignoreStroke()\r\n        });\r\n        var rotation = Konva.getAngle(node.rotation());\r\n        var dx = rect.x * node.scaleX() - node.offsetX() * node.scaleX();\r\n        var dy = rect.y * node.scaleY() - node.offsetY() * node.scaleY();\r\n        return {\r\n            x: node.x() + dx * Math.cos(rotation) + dy * Math.sin(-rotation),\r\n            y: node.y() + dy * Math.cos(rotation) + dx * Math.sin(rotation),\r\n            width: rect.width * node.scaleX(),\r\n            height: rect.height * node.scaleY(),\r\n            rotation: node.rotation()\r\n        };\r\n    };\r\n    Transformer.prototype.getX = function () {\r\n        return this._getNodeRect().x;\r\n    };\r\n    Transformer.prototype.getY = function () {\r\n        return this._getNodeRect().y;\r\n    };\r\n    Transformer.prototype.getRotation = function () {\r\n        return this._getNodeRect().rotation;\r\n    };\r\n    Transformer.prototype.getWidth = function () {\r\n        return this._getNodeRect().width;\r\n    };\r\n    Transformer.prototype.getHeight = function () {\r\n        return this._getNodeRect().height;\r\n    };\r\n    Transformer.prototype._createElements = function () {\r\n        this._createBack();\r\n        ANCHORS_NAMES.forEach(function (name) {\r\n            this._createAnchor(name);\r\n        }.bind(this));\r\n        this._createAnchor('rotater');\r\n    };\r\n    Transformer.prototype._createAnchor = function (name) {\r\n        var _this = this;\r\n        var anchor = new Rect({\r\n            stroke: 'rgb(0, 161, 255)',\r\n            fill: 'white',\r\n            strokeWidth: 1,\r\n            name: name + ' _anchor',\r\n            dragDistance: 0,\r\n            draggable: true\r\n        });\r\n        var self = this;\r\n        anchor.on('mousedown touchstart', function (e) {\r\n            self._handleMouseDown(e);\r\n        });\r\n        anchor.on('dragstart', function (e) {\r\n            e.cancelBubble = true;\r\n        });\r\n        anchor.on('dragmove', function (e) {\r\n            e.cancelBubble = true;\r\n        });\r\n        anchor.on('dragend', function (e) {\r\n            e.cancelBubble = true;\r\n        });\r\n        // add hover styling\r\n        anchor.on('mouseenter', function () {\r\n            var rad = Konva.getAngle(_this.rotation());\r\n            var scale = _this.getNode().getAbsoluteScale();\r\n            // If scale.y < 0 xor scale.x < 0 we need to flip (not rotate).\r\n            var isMirrored = scale.y * scale.x < 0;\r\n            var cursor = getCursor(name, rad, isMirrored);\r\n            anchor.getStage().content.style.cursor = cursor;\r\n            _this._cursorChange = true;\r\n        });\r\n        anchor.on('mouseout', function () {\r\n            if (!anchor.getStage() || !anchor.getParent()) {\r\n                return;\r\n            }\r\n            anchor.getStage().content.style.cursor = '';\r\n            _this._cursorChange = false;\r\n        });\r\n        this.add(anchor);\r\n    };\r\n    Transformer.prototype._createBack = function () {\r\n        var back = new Shape({\r\n            name: 'back',\r\n            width: 0,\r\n            height: 0,\r\n            listening: false,\r\n            sceneFunc: function (ctx) {\r\n                var tr = this.getParent();\r\n                var padding = tr.padding();\r\n                ctx.beginPath();\r\n                ctx.rect(-padding, -padding, this.width() + padding * 2, this.height() + padding * 2);\r\n                ctx.moveTo(this.width() / 2, -padding);\r\n                if (tr.rotateEnabled()) {\r\n                    ctx.lineTo(this.width() / 2, -tr.rotateAnchorOffset() * Util._sign(this.height()));\r\n                }\r\n                ctx.fillStrokeShape(this);\r\n            }\r\n        });\r\n        this.add(back);\r\n    };\r\n    Transformer.prototype._handleMouseDown = function (e) {\r\n        this.movingResizer = e.target.name().split(' ')[0];\r\n        // var node = this.getNode();\r\n        var attrs = this._getNodeRect();\r\n        var width = attrs.width;\r\n        var height = attrs.height;\r\n        var hypotenuse = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\r\n        this.sin = Math.abs(height / hypotenuse);\r\n        this.cos = Math.abs(width / hypotenuse);\r\n        window.addEventListener('mousemove', this._handleMouseMove);\r\n        window.addEventListener('touchmove', this._handleMouseMove);\r\n        window.addEventListener('mouseup', this._handleMouseUp, true);\r\n        window.addEventListener('touchend', this._handleMouseUp, true);\r\n        this._transforming = true;\r\n        this._fire('transformstart', { evt: e });\r\n        this.getNode()._fire('transformstart', { evt: e });\r\n    };\r\n    Transformer.prototype._handleMouseMove = function (e) {\r\n        var x, y, newHypotenuse;\r\n        var resizerNode = this.findOne('.' + this.movingResizer);\r\n        var stage = resizerNode.getStage();\r\n        var box = stage.getContent().getBoundingClientRect();\r\n        var zeroPoint = {\r\n            x: box.left,\r\n            y: box.top\r\n        };\r\n        var pointerPos = {\r\n            left: e.clientX !== undefined ? e.clientX : e.touches[0].clientX,\r\n            top: e.clientX !== undefined ? e.clientY : e.touches[0].clientY\r\n        };\r\n        var newAbsPos = {\r\n            x: pointerPos.left - zeroPoint.x,\r\n            y: pointerPos.top - zeroPoint.y\r\n        };\r\n        resizerNode.setAbsolutePosition(newAbsPos);\r\n        var keepProportion = this.keepRatio() || e.shiftKey;\r\n        // console.log(keepProportion);\r\n        if (this.movingResizer === 'top-left') {\r\n            if (keepProportion) {\r\n                newHypotenuse = Math.sqrt(Math.pow(this.findOne('.bottom-right').x() - resizerNode.x(), 2) +\r\n                    Math.pow(this.findOne('.bottom-right').y() - resizerNode.y(), 2));\r\n                var reverse = this.findOne('.top-left').x() > this.findOne('.bottom-right').x()\r\n                    ? -1\r\n                    : 1;\r\n                x = newHypotenuse * this.cos * reverse;\r\n                y = newHypotenuse * this.sin * reverse;\r\n                this.findOne('.top-left').x(this.findOne('.bottom-right').x() - x);\r\n                this.findOne('.top-left').y(this.findOne('.bottom-right').y() - y);\r\n            }\r\n        }\r\n        else if (this.movingResizer === 'top-center') {\r\n            this.findOne('.top-left').y(resizerNode.y());\r\n        }\r\n        else if (this.movingResizer === 'top-right') {\r\n            if (keepProportion) {\r\n                newHypotenuse = Math.sqrt(Math.pow(this.findOne('.bottom-left').x() - resizerNode.x(), 2) +\r\n                    Math.pow(this.findOne('.bottom-left').y() - resizerNode.y(), 2));\r\n                var reverse = this.findOne('.top-right').x() < this.findOne('.top-left').x()\r\n                    ? -1\r\n                    : 1;\r\n                x = newHypotenuse * this.cos * reverse;\r\n                y = newHypotenuse * this.sin * reverse;\r\n                this.findOne('.top-right').x(x);\r\n                this.findOne('.top-right').y(this.findOne('.bottom-left').y() - y);\r\n            }\r\n            var pos = resizerNode.position();\r\n            this.findOne('.top-left').y(pos.y);\r\n            this.findOne('.bottom-right').x(pos.x);\r\n        }\r\n        else if (this.movingResizer === 'middle-left') {\r\n            this.findOne('.top-left').x(resizerNode.x());\r\n        }\r\n        else if (this.movingResizer === 'middle-right') {\r\n            this.findOne('.bottom-right').x(resizerNode.x());\r\n        }\r\n        else if (this.movingResizer === 'bottom-left') {\r\n            if (keepProportion) {\r\n                newHypotenuse = Math.sqrt(Math.pow(this.findOne('.top-right').x() - resizerNode.x(), 2) +\r\n                    Math.pow(this.findOne('.top-right').y() - resizerNode.y(), 2));\r\n                var reverse = this.findOne('.top-right').x() < this.findOne('.bottom-left').x()\r\n                    ? -1\r\n                    : 1;\r\n                x = newHypotenuse * this.cos * reverse;\r\n                y = newHypotenuse * this.sin * reverse;\r\n                this.findOne('.bottom-left').x(this.findOne('.top-right').x() - x);\r\n                this.findOne('.bottom-left').y(y);\r\n            }\r\n            pos = resizerNode.position();\r\n            this.findOne('.top-left').x(pos.x);\r\n            this.findOne('.bottom-right').y(pos.y);\r\n        }\r\n        else if (this.movingResizer === 'bottom-center') {\r\n            this.findOne('.bottom-right').y(resizerNode.y());\r\n        }\r\n        else if (this.movingResizer === 'bottom-right') {\r\n            if (keepProportion) {\r\n                newHypotenuse = Math.sqrt(Math.pow(this.findOne('.bottom-right').x(), 2) +\r\n                    Math.pow(this.findOne('.bottom-right').y(), 2));\r\n                var reverse = this.findOne('.top-left').x() > this.findOne('.bottom-right').x()\r\n                    ? -1\r\n                    : 1;\r\n                x = newHypotenuse * this.cos * reverse;\r\n                y = newHypotenuse * this.sin * reverse;\r\n                this.findOne('.bottom-right').x(x);\r\n                this.findOne('.bottom-right').y(y);\r\n            }\r\n        }\r\n        else if (this.movingResizer === 'rotater') {\r\n            var padding = this.padding();\r\n            var attrs = this._getNodeRect();\r\n            x = resizerNode.x() - attrs.width / 2;\r\n            y = -resizerNode.y() + attrs.height / 2;\r\n            var dAlpha = Math.atan2(-y, x) + Math.PI / 2;\r\n            if (attrs.height < 0) {\r\n                dAlpha -= Math.PI;\r\n            }\r\n            var rot = Konva.getAngle(this.rotation());\r\n            var newRotation = Util._radToDeg(rot) + Util._radToDeg(dAlpha);\r\n            var alpha = Konva.getAngle(this.getNode().rotation());\r\n            var newAlpha = Util._degToRad(newRotation);\r\n            var snaps = this.rotationSnaps();\r\n            var offset = 0.1;\r\n            for (var i = 0; i < snaps.length; i++) {\r\n                var angle = Konva.getAngle(snaps[i]);\r\n                var dif = Math.abs(angle - Util._degToRad(newRotation)) % (Math.PI * 2);\r\n                if (dif < offset) {\r\n                    newRotation = Util._radToDeg(angle);\r\n                    newAlpha = Util._degToRad(newRotation);\r\n                }\r\n            }\r\n            var dx = padding;\r\n            var dy = padding;\r\n            this._fitNodeInto({\r\n                rotation: Konva.angleDeg ? newRotation : Util._degToRad(newRotation),\r\n                x: attrs.x +\r\n                    (attrs.width / 2 + padding) *\r\n                        (Math.cos(alpha) - Math.cos(newAlpha)) +\r\n                    (attrs.height / 2 + padding) *\r\n                        (Math.sin(-alpha) - Math.sin(-newAlpha)) -\r\n                    (dx * Math.cos(rot) + dy * Math.sin(-rot)),\r\n                y: attrs.y +\r\n                    (attrs.height / 2 + padding) *\r\n                        (Math.cos(alpha) - Math.cos(newAlpha)) +\r\n                    (attrs.width / 2 + padding) *\r\n                        (Math.sin(alpha) - Math.sin(newAlpha)) -\r\n                    (dy * Math.cos(rot) + dx * Math.sin(rot)),\r\n                width: attrs.width + padding * 2,\r\n                height: attrs.height + padding * 2\r\n            }, e);\r\n        }\r\n        else {\r\n            console.error(new Error('Wrong position argument of selection resizer: ' + this.movingResizer));\r\n        }\r\n        if (this.movingResizer === 'rotater') {\r\n            return;\r\n        }\r\n        var absPos = this.findOne('.top-left').getAbsolutePosition(this.getParent());\r\n        var centeredScaling = this.centeredScaling() || e.altKey;\r\n        if (centeredScaling) {\r\n            var topLeft = this.findOne('.top-left');\r\n            var bottomRight = this.findOne('.bottom-right');\r\n            var topOffsetX = topLeft.x();\r\n            var topOffsetY = topLeft.y();\r\n            var bottomOffsetX = this.getWidth() - bottomRight.x();\r\n            var bottomOffsetY = this.getHeight() - bottomRight.y();\r\n            // console.log(topOffsetX, topOffsetY, bottomOffsetX, bottomOffsetY);\r\n            bottomRight.move({\r\n                x: -topOffsetX,\r\n                y: -topOffsetY\r\n            });\r\n            topLeft.move({\r\n                x: bottomOffsetX,\r\n                y: bottomOffsetY\r\n            });\r\n            absPos = topLeft.getAbsolutePosition(this.getParent());\r\n        }\r\n        x = absPos.x;\r\n        y = absPos.y;\r\n        var width = this.findOne('.bottom-right').x() - this.findOne('.top-left').x();\r\n        var height = this.findOne('.bottom-right').y() - this.findOne('.top-left').y();\r\n        // console.log(x, y, width, height);\r\n        this._fitNodeInto({\r\n            x: x + this.offsetX(),\r\n            y: y + this.offsetY(),\r\n            width: width,\r\n            height: height\r\n        }, e);\r\n    };\r\n    Transformer.prototype._handleMouseUp = function (e) {\r\n        this._removeEvents(e);\r\n    };\r\n    Transformer.prototype._removeEvents = function (e) {\r\n        if (this._transforming) {\r\n            this._transforming = false;\r\n            window.removeEventListener('mousemove', this._handleMouseMove);\r\n            window.removeEventListener('touchmove', this._handleMouseMove);\r\n            window.removeEventListener('mouseup', this._handleMouseUp, true);\r\n            window.removeEventListener('touchend', this._handleMouseUp, true);\r\n            this._fire('transformend', { evt: e });\r\n            var node = this.getNode();\r\n            if (node) {\r\n                node.fire('transformend', { evt: e });\r\n            }\r\n        }\r\n    };\r\n    Transformer.prototype._fitNodeInto = function (newAttrs, evt) {\r\n        // waring! in this attrs padding may be included\r\n        var boundBoxFunc = this.boundBoxFunc();\r\n        if (boundBoxFunc) {\r\n            var oldAttrs = this._getNodeRect();\r\n            newAttrs = boundBoxFunc.call(this, oldAttrs, newAttrs);\r\n        }\r\n        var node = this.getNode();\r\n        if (newAttrs.rotation !== undefined) {\r\n            this.getNode().rotation(newAttrs.rotation);\r\n        }\r\n        var pure = node.getClientRect({\r\n            skipTransform: true,\r\n            skipShadow: true,\r\n            skipStroke: this.ignoreStroke()\r\n        });\r\n        var padding = this.padding();\r\n        var scaleX = (newAttrs.width - padding * 2) / pure.width;\r\n        var scaleY = (newAttrs.height - padding * 2) / pure.height;\r\n        var rotation = Konva.getAngle(node.rotation());\r\n        var dx = pure.x * scaleX - padding - node.offsetX() * scaleX;\r\n        var dy = pure.y * scaleY - padding - node.offsetY() * scaleY;\r\n        this.getNode().setAttrs({\r\n            scaleX: scaleX,\r\n            scaleY: scaleY,\r\n            x: newAttrs.x - (dx * Math.cos(rotation) + dy * Math.sin(-rotation)),\r\n            y: newAttrs.y - (dy * Math.cos(rotation) + dx * Math.sin(rotation))\r\n        });\r\n        this._fire('transform', { evt: evt });\r\n        this.getNode()._fire('transform', { evt: evt });\r\n        this.update();\r\n        this.getLayer().batchDraw();\r\n    };\r\n    /**\r\n     * force update of Konva.Transformer.\r\n     * Use it when you updated attached Konva.Group and now you need to reset transformer size\r\n     * @method\r\n     * @name Konva.Transformer#forceUpdate\r\n     */\r\n    Transformer.prototype.forceUpdate = function () {\r\n        this._resetTransformCache();\r\n        this.update();\r\n    };\r\n    Transformer.prototype.update = function () {\r\n        var _this = this;\r\n        var attrs = this._getNodeRect();\r\n        var node = this.getNode();\r\n        var scale = { x: 1, y: 1 };\r\n        if (node && node.getParent()) {\r\n            scale = node.getParent().getAbsoluteScale();\r\n        }\r\n        var invertedScale = {\r\n            x: 1 / scale.x,\r\n            y: 1 / scale.y\r\n        };\r\n        var width = attrs.width;\r\n        var height = attrs.height;\r\n        var enabledAnchors = this.enabledAnchors();\r\n        var resizeEnabled = this.resizeEnabled();\r\n        var padding = this.padding();\r\n        var anchorSize = this.anchorSize();\r\n        this.find('._anchor').each(function (node) {\r\n            return node.setAttrs({\r\n                width: anchorSize,\r\n                height: anchorSize,\r\n                offsetX: anchorSize / 2,\r\n                offsetY: anchorSize / 2,\r\n                stroke: _this.anchorStroke(),\r\n                strokeWidth: _this.anchorStrokeWidth(),\r\n                fill: _this.anchorFill(),\r\n                cornerRadius: _this.anchorCornerRadius()\r\n            });\r\n        });\r\n        this.findOne('.top-left').setAttrs({\r\n            x: -padding,\r\n            y: -padding,\r\n            scale: invertedScale,\r\n            visible: resizeEnabled && enabledAnchors.indexOf('top-left') >= 0\r\n        });\r\n        this.findOne('.top-center').setAttrs({\r\n            x: width / 2,\r\n            y: -padding,\r\n            scale: invertedScale,\r\n            visible: resizeEnabled && enabledAnchors.indexOf('top-center') >= 0\r\n        });\r\n        this.findOne('.top-right').setAttrs({\r\n            x: width + padding,\r\n            y: -padding,\r\n            scale: invertedScale,\r\n            visible: resizeEnabled && enabledAnchors.indexOf('top-right') >= 0\r\n        });\r\n        this.findOne('.middle-left').setAttrs({\r\n            x: -padding,\r\n            y: height / 2,\r\n            scale: invertedScale,\r\n            visible: resizeEnabled && enabledAnchors.indexOf('middle-left') >= 0\r\n        });\r\n        this.findOne('.middle-right').setAttrs({\r\n            x: width + padding,\r\n            y: height / 2,\r\n            scale: invertedScale,\r\n            visible: resizeEnabled && enabledAnchors.indexOf('middle-right') >= 0\r\n        });\r\n        this.findOne('.bottom-left').setAttrs({\r\n            x: -padding,\r\n            y: height + padding,\r\n            scale: invertedScale,\r\n            visible: resizeEnabled && enabledAnchors.indexOf('bottom-left') >= 0\r\n        });\r\n        this.findOne('.bottom-center').setAttrs({\r\n            x: width / 2,\r\n            y: height + padding,\r\n            scale: invertedScale,\r\n            visible: resizeEnabled && enabledAnchors.indexOf('bottom-center') >= 0\r\n        });\r\n        this.findOne('.bottom-right').setAttrs({\r\n            x: width + padding,\r\n            y: height + padding,\r\n            scale: invertedScale,\r\n            visible: resizeEnabled && enabledAnchors.indexOf('bottom-right') >= 0\r\n        });\r\n        var scaledRotateAnchorOffset = -this.rotateAnchorOffset() * Math.abs(invertedScale.y);\r\n        this.findOne('.rotater').setAttrs({\r\n            x: width / 2,\r\n            y: scaledRotateAnchorOffset * Util._sign(height),\r\n            scale: invertedScale,\r\n            visible: this.rotateEnabled()\r\n        });\r\n        this.findOne('.back').setAttrs({\r\n            width: width * scale.x,\r\n            height: height * scale.y,\r\n            scale: invertedScale,\r\n            visible: this.borderEnabled(),\r\n            stroke: this.borderStroke(),\r\n            strokeWidth: this.borderStrokeWidth(),\r\n            dash: this.borderDash()\r\n        });\r\n    };\r\n    /**\r\n     * determine if transformer is in active transform\r\n     * @method\r\n     * @name Konva.Transformer#isTransforming\r\n     * @returns {Boolean}\r\n     */\r\n    Transformer.prototype.isTransforming = function () {\r\n        return this._transforming;\r\n    };\r\n    /**\r\n     * Stop active transform action\r\n     * @method\r\n     * @name Konva.Transformer#stopTransform\r\n     * @returns {Boolean}\r\n     */\r\n    Transformer.prototype.stopTransform = function () {\r\n        if (this._transforming) {\r\n            this._removeEvents();\r\n            var resizerNode = this.findOne('.' + this.movingResizer);\r\n            if (resizerNode) {\r\n                resizerNode.stopDrag();\r\n            }\r\n        }\r\n    };\r\n    Transformer.prototype.destroy = function () {\r\n        if (this.getStage() && this._cursorChange) {\r\n            this.getStage().content.style.cursor = '';\r\n        }\r\n        Group.prototype.destroy.call(this);\r\n        this.detach();\r\n        this._removeEvents();\r\n        return this;\r\n    };\r\n    // do not work as a container\r\n    // we will recreate inner nodes manually\r\n    Transformer.prototype.toObject = function () {\r\n        return Node.prototype.toObject.call(this);\r\n    };\r\n    return Transformer;\r\n}(Group));\r\nexport { Transformer };\r\nfunction validateAnchors(val) {\r\n    if (!(val instanceof Array)) {\r\n        Util.warn('enabledAnchors value should be an array');\r\n    }\r\n    if (val instanceof Array) {\r\n        val.forEach(function (name) {\r\n            if (ANCHORS_NAMES.indexOf(name) === -1) {\r\n                Util.warn('Unknown anchor name: ' +\r\n                    name +\r\n                    '. Available names are: ' +\r\n                    ANCHORS_NAMES.join(', '));\r\n            }\r\n        });\r\n    }\r\n    return val || [];\r\n}\r\nTransformer.prototype.className = 'Transformer';\r\n_registerNode(Transformer);\r\n/**\r\n * get/set enabled handlers\r\n * @name Konva.Transformer#enabledAnchors\r\n * @method\r\n * @param {Array} array\r\n * @returns {Array}\r\n * @example\r\n * // get list of handlers\r\n * var enabledAnchors = transformer.enabledAnchors();\r\n *\r\n * // set handlers\r\n * transformer.enabledAnchors(['top-left', 'top-center', 'top-right', 'middle-right', 'middle-left', 'bottom-left', 'bottom-center', 'bottom-right']);\r\n */\r\nFactory.addGetterSetter(Transformer, 'enabledAnchors', ANCHORS_NAMES, validateAnchors);\r\n/**\r\n * get/set resize ability. If false it will automatically hide resizing handlers\r\n * @name Konva.Transformer#resizeEnabled\r\n * @method\r\n * @param {Array} array\r\n * @returns {Array}\r\n * @example\r\n * // get\r\n * var resizeEnabled = transformer.resizeEnabled();\r\n *\r\n * // set\r\n * transformer.resizeEnabled(false);\r\n */\r\nFactory.addGetterSetter(Transformer, 'resizeEnabled', true);\r\n/**\r\n * get/set anchor size. Default is 10\r\n * @name Konva.Transformer#validateAnchors\r\n * @method\r\n * @param {Number} 10\r\n * @returns {Number}\r\n * @example\r\n * // get\r\n * var anchorSize = transformer.anchorSize();\r\n *\r\n * // set\r\n * transformer.anchorSize(20)\r\n */\r\nFactory.addGetterSetter(Transformer, 'anchorSize', 10, getNumberValidator());\r\n/**\r\n * get/set ability to rotate.\r\n * @name Konva.Transformer#rotateEnabled\r\n * @method\r\n * @param {Boolean} enabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get\r\n * var rotateEnabled = transformer.rotateEnabled();\r\n *\r\n * // set\r\n * transformer.rotateEnabled(false);\r\n */\r\nFactory.addGetterSetter(Transformer, 'rotateEnabled', true);\r\n/**\r\n * get/set rotation snaps angles.\r\n * @name Konva.Transformer#rotationSnaps\r\n * @method\r\n * @param {Array} array\r\n * @returns {Array}\r\n * @example\r\n * // get\r\n * var rotationSnaps = transformer.rotationSnaps();\r\n *\r\n * // set\r\n * transformer.rotationSnaps([0, 90, 180, 270]);\r\n */\r\nFactory.addGetterSetter(Transformer, 'rotationSnaps', []);\r\n/**\r\n * get/set distance for rotation handler\r\n * @name Konva.Transformer#rotateAnchorOffset\r\n * @method\r\n * @param {Number} offset\r\n * @returns {Number}\r\n * @example\r\n * // get\r\n * var rotateAnchorOffset = transformer.rotateAnchorOffset();\r\n *\r\n * // set\r\n * transformer.rotateAnchorOffset(100);\r\n */\r\nFactory.addGetterSetter(Transformer, 'rotateAnchorOffset', 50, getNumberValidator());\r\n/**\r\n * get/set visibility of border\r\n * @name Konva.Transformer#borderEnabled\r\n * @method\r\n * @param {Boolean} enabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get\r\n * var borderEnabled = transformer.borderEnabled();\r\n *\r\n * // set\r\n * transformer.borderEnabled(false);\r\n */\r\nFactory.addGetterSetter(Transformer, 'borderEnabled', true);\r\n/**\r\n * get/set anchor stroke color\r\n * @name Konva.Transformer#anchorStroke\r\n * @method\r\n * @param {Boolean} enabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get\r\n * var anchorStroke = transformer.anchorStroke();\r\n *\r\n * // set\r\n * transformer.anchorStroke('red');\r\n */\r\nFactory.addGetterSetter(Transformer, 'anchorStroke', 'rgb(0, 161, 255)');\r\n/**\r\n * get/set anchor stroke width\r\n * @name Konva.Transformer#anchorStrokeWidth\r\n * @method\r\n * @param {Boolean} enabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get\r\n * var anchorStrokeWidth = transformer.anchorStrokeWidth();\r\n *\r\n * // set\r\n * transformer.anchorStrokeWidth(3);\r\n */\r\nFactory.addGetterSetter(Transformer, 'anchorStrokeWidth', 1, getNumberValidator());\r\n/**\r\n * get/set anchor fill color\r\n * @name Konva.Transformer#anchorFill\r\n * @method\r\n * @param {Boolean} enabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get\r\n * var anchorFill = transformer.anchorFill();\r\n *\r\n * // set\r\n * transformer.anchorFill('red');\r\n */\r\nFactory.addGetterSetter(Transformer, 'anchorFill', 'white');\r\n/**\r\n * get/set anchor corner radius\r\n * @name Konva.Transformer#anchorCornerRadius\r\n * @method\r\n * @param {Number} enabled\r\n * @returns {Number}\r\n * @example\r\n * // get\r\n * var anchorCornerRadius = transformer.anchorCornerRadius();\r\n *\r\n * // set\r\n * transformer.anchorCornerRadius(3);\r\n */\r\nFactory.addGetterSetter(Transformer, 'anchorCornerRadius', 0, getNumberValidator());\r\n/**\r\n * get/set border stroke color\r\n * @name Konva.Transformer#borderStroke\r\n * @method\r\n * @param {Boolean} enabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get\r\n * var borderStroke = transformer.borderStroke();\r\n *\r\n * // set\r\n * transformer.borderStroke('red');\r\n */\r\nFactory.addGetterSetter(Transformer, 'borderStroke', 'rgb(0, 161, 255)');\r\n/**\r\n * get/set border stroke width\r\n * @name Konva.Transformer#borderStrokeWidth\r\n * @method\r\n * @param {Boolean} enabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get\r\n * var borderStrokeWidth = transformer.borderStrokeWidth();\r\n *\r\n * // set\r\n * transformer.borderStrokeWidth(3);\r\n */\r\nFactory.addGetterSetter(Transformer, 'borderStrokeWidth', 1, getNumberValidator());\r\n/**\r\n * get/set border dash array\r\n * @name Konva.Transformer#borderDash\r\n * @method\r\n * @param {Boolean} enabled\r\n * @returns {Boolean}\r\n * @example\r\n * // get\r\n * var borderDash = transformer.borderDash();\r\n *\r\n * // set\r\n * transformer.borderDash([2, 2]);\r\n */\r\nFactory.addGetterSetter(Transformer, 'borderDash');\r\n/**\r\n * get/set should we keep ratio while resize anchors at corners\r\n * @name Konva.Transformer#keepRatio\r\n * @method\r\n * @param {Boolean} keepRatio\r\n * @returns {Boolean}\r\n * @example\r\n * // get\r\n * var keepRatio = transformer.keepRatio();\r\n *\r\n * // set\r\n * transformer.keepRatio(false);\r\n */\r\nFactory.addGetterSetter(Transformer, 'keepRatio', true);\r\n/**\r\n * get/set should we resize relative to node's center?\r\n * @name Konva.Transformer#centeredScaling\r\n * @method\r\n * @param {Boolean} centeredScaling\r\n * @returns {Boolean}\r\n * @example\r\n * // get\r\n * var centeredScaling = transformer.centeredScaling();\r\n *\r\n * // set\r\n * transformer.centeredScaling(true);\r\n */\r\nFactory.addGetterSetter(Transformer, 'centeredScaling', false);\r\n/**\r\n * get/set should we think about stroke while resize? Good to use when a shape has strokeScaleEnabled = false\r\n * default is false\r\n * @name Konva.Transformer#ignoreStroke\r\n * @method\r\n * @param {Boolean} ignoreStroke\r\n * @returns {Boolean}\r\n * @example\r\n * // get\r\n * var ignoreStroke = transformer.ignoreStroke();\r\n *\r\n * // set\r\n * transformer.ignoreStroke(true);\r\n */\r\nFactory.addGetterSetter(Transformer, 'ignoreStroke', false);\r\n/**\r\n * get/set padding\r\n * @name Konva.Transformer#padding\r\n * @method\r\n * @param {Number} padding\r\n * @returns {Number}\r\n * @example\r\n * // get\r\n * var padding = transformer.padding();\r\n *\r\n * // set\r\n * transformer.padding(10);\r\n */\r\nFactory.addGetterSetter(Transformer, 'padding', 0, getNumberValidator());\r\n/**\r\n * get/set attached node of the Transformer. Transformer will adapt to its size and listen to its events\r\n * @method\r\n * @name Konva.Transformer#Konva.Transformer#node\r\n * @returns {Konva.Node}\r\n * @example\r\n * // get\r\n * const node = transformer.node();\r\n *\r\n * // set\r\n * transformer.node(shape);\r\n */\r\nFactory.addGetterSetter(Transformer, 'node');\r\n/**\r\n * get/set bounding box function\r\n * @name Konva.Transformer#boundBoxFunc\r\n * @method\r\n * @param {Function} func\r\n * @returns {Function}\r\n * @example\r\n * // get\r\n * var boundBoxFunc = transformer.boundBoxFunc();\r\n *\r\n * // set\r\n * transformer.boundBoxFunc(function(oldBox, newBox) {\r\n *   if (newBox.width > 200) {\r\n *     return oldBox;\r\n *   }\r\n *   return newBox;\r\n * });\r\n */\r\nFactory.addGetterSetter(Transformer, 'boundBoxFunc');\r\nFactory.backCompat(Transformer, {\r\n    lineEnabled: 'borderEnabled',\r\n    rotateHandlerOffset: 'rotateAnchorOffset',\r\n    enabledHandlers: 'enabledAnchors'\r\n});\r\nCollection.mapMethods(Transformer);\r\n"}
