{"code":"import { Util, Collection, Transform } from './Util';\r\nimport { Factory } from './Factory';\r\nimport { SceneCanvas, HitCanvas } from './Canvas';\r\nimport { Konva, _NODES_REGISTRY } from './Global';\r\nimport { DD } from './DragAndDrop';\r\nimport { getNumberValidator, getStringValidator, getBooleanValidator } from './Validators';\r\nexport var ids = {};\r\nexport var names = {};\r\nvar _addId = function (node, id) {\r\n    if (!id) {\r\n        return;\r\n    }\r\n    ids[id] = node;\r\n};\r\nexport var _removeId = function (id, node) {\r\n    // node has no id\r\n    if (!id) {\r\n        return;\r\n    }\r\n    // another node is registered (possible for duplicate ids)\r\n    if (ids[id] !== node) {\r\n        return;\r\n    }\r\n    delete ids[id];\r\n};\r\nexport var _addName = function (node, name) {\r\n    if (name) {\r\n        if (!names[name]) {\r\n            names[name] = [];\r\n        }\r\n        names[name].push(node);\r\n    }\r\n};\r\nexport var _removeName = function (name, _id) {\r\n    if (!name) {\r\n        return;\r\n    }\r\n    var nodes = names[name];\r\n    if (!nodes) {\r\n        return;\r\n    }\r\n    for (var n = 0; n < nodes.length; n++) {\r\n        var no = nodes[n];\r\n        if (no._id === _id) {\r\n            nodes.splice(n, 1);\r\n        }\r\n    }\r\n    if (nodes.length === 0) {\r\n        delete names[name];\r\n    }\r\n};\r\n// CONSTANTS\r\nvar ABSOLUTE_OPACITY = 'absoluteOpacity', ABSOLUTE_TRANSFORM = 'absoluteTransform', ABSOLUTE_SCALE = 'absoluteScale', CANVAS = 'canvas', CHANGE = 'Change', CHILDREN = 'children', KONVA = 'konva', LISTENING = 'listening', MOUSEENTER = 'mouseenter', MOUSELEAVE = 'mouseleave', NAME = 'name', SET = 'set', SHAPE = 'Shape', SPACE = ' ', STAGE = 'stage', TRANSFORM = 'transform', UPPER_STAGE = 'Stage', VISIBLE = 'visible', CLONE_BLACK_LIST = ['id'], TRANSFORM_CHANGE_STR = [\r\n    'xChange.konva',\r\n    'yChange.konva',\r\n    'scaleXChange.konva',\r\n    'scaleYChange.konva',\r\n    'skewXChange.konva',\r\n    'skewYChange.konva',\r\n    'rotationChange.konva',\r\n    'offsetXChange.konva',\r\n    'offsetYChange.konva',\r\n    'transformsEnabledChange.konva'\r\n].join(SPACE), SCALE_CHANGE_STR = ['scaleXChange.konva', 'scaleYChange.konva'].join(SPACE);\r\n// TODO: can we remove children from node?\r\nvar emptyChildren = new Collection();\r\nvar idCounter = 1;\r\n/**\r\n * Node constructor. Nodes are entities that can be transformed, layered,\r\n * and have bound events. The stage, layers, groups, and shapes all extend Node.\r\n * @constructor\r\n * @memberof Konva\r\n * @param {Object} config\r\n * @@nodeParams\r\n */\r\nvar Node = /** @class */ (function () {\r\n    function Node(config) {\r\n        var _this = this;\r\n        this._id = idCounter++;\r\n        this.eventListeners = {};\r\n        this.attrs = {};\r\n        this.index = 0;\r\n        this.parent = null;\r\n        this.abstractParent = null;\r\n        this._cache = new Map();\r\n        this._lastPos = null;\r\n        this._filterUpToDate = false;\r\n        this._isUnderCache = false;\r\n        this.children = emptyChildren;\r\n        this.setAttrs(config);\r\n        // event bindings for cache handling\r\n        this.on(TRANSFORM_CHANGE_STR, function () {\r\n            _this._clearCache(TRANSFORM);\r\n            _this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);\r\n        });\r\n        this.on(SCALE_CHANGE_STR, function () {\r\n            _this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);\r\n        });\r\n        this.on('visibleChange.konva', function () {\r\n            _this._clearSelfAndDescendantCache(VISIBLE);\r\n        });\r\n        this.on('listeningChange.konva', function () {\r\n            _this._clearSelfAndDescendantCache(LISTENING);\r\n        });\r\n        this.on('opacityChange.konva', function () {\r\n            _this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);\r\n        });\r\n    }\r\n    Node.prototype.hasChildren = function () {\r\n        return false;\r\n    };\r\n    Node.prototype.getChildren = function () {\r\n        return emptyChildren;\r\n    };\r\n    /** @lends Konva.Node.prototype */\r\n    Node.prototype._clearCache = function (attr) {\r\n        if (attr) {\r\n            this._cache.delete(attr);\r\n        }\r\n        else {\r\n            this._cache.clear();\r\n        }\r\n    };\r\n    Node.prototype._getCache = function (attr, privateGetter) {\r\n        var cache = this._cache.get(attr);\r\n        // if not cached, we need to set it using the private getter method.\r\n        if (cache === undefined) {\r\n            cache = privateGetter.call(this);\r\n            this._cache.set(attr, cache);\r\n        }\r\n        return cache;\r\n    };\r\n    Node.prototype._getCanvasCache = function () {\r\n        return this._cache.get(CANVAS);\r\n    };\r\n    /*\r\n     * when the logic for a cached result depends on ancestor propagation, use this\r\n     * method to clear self and children cache\r\n     */\r\n    Node.prototype._clearSelfAndDescendantCache = function (attr) {\r\n        this._clearCache(attr);\r\n        // skip clearing if node is cached with canvas\r\n        if (this._getCanvasCache()) {\r\n            return;\r\n        }\r\n        if (this.children) {\r\n            this.children.each(function (node) {\r\n                node._clearSelfAndDescendantCache(attr);\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * clear cached canvas\r\n     * @method\r\n     * @name Konva.Node#clearCache\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * node.clearCache();\r\n     */\r\n    Node.prototype.clearCache = function () {\r\n        this._cache.delete(CANVAS);\r\n        this._clearSelfAndDescendantCache();\r\n        return this;\r\n    };\r\n    /**\r\n     *  cache node to improve drawing performance, apply filters, or create more accurate\r\n     *  hit regions. For all basic shapes size of cache canvas will be automatically detected.\r\n     *  If you need to cache your custom `Konva.Shape` instance you have to pass shape's bounding box\r\n     *  properties. Look at [https://konvajs.org/docs/performance/Shape_Caching.html](https://konvajs.org/docs/performance/Shape_Caching.html) for more information.\r\n     * @method\r\n     * @name Konva.Node#cache\r\n     * @param {Object} [config]\r\n     * @param {Number} [config.x]\r\n     * @param {Number} [config.y]\r\n     * @param {Number} [config.width]\r\n     * @param {Number} [config.height]\r\n     * @param {Number} [config.offset]  increase canvas size by `offset` pixel in all directions.\r\n     * @param {Boolean} [config.drawBorder] when set to true, a red border will be drawn around the cached\r\n     *  region for debugging purposes\r\n     * @param {Number} [config.pixelRatio] change quality (or pixel ratio) of cached image. pixelRatio = 2 will produce 2x sized cache.\r\n     * @param {Boolean} [config.imageSmoothingEnabled] control imageSmoothingEnabled property of created canvas for cache\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * // cache a shape with the x,y position of the bounding box at the center and\r\n     * // the width and height of the bounding box equal to the width and height of\r\n     * // the shape obtained from shape.width() and shape.height()\r\n     * image.cache();\r\n     *\r\n     * // cache a node and define the bounding box position and size\r\n     * node.cache({\r\n     *   x: -30,\r\n     *   y: -30,\r\n     *   width: 100,\r\n     *   height: 200\r\n     * });\r\n     *\r\n     * // cache a node and draw a red border around the bounding box\r\n     * // for debugging purposes\r\n     * node.cache({\r\n     *   x: -30,\r\n     *   y: -30,\r\n     *   width: 100,\r\n     *   height: 200,\r\n     *   offset : 10,\r\n     *   drawBorder: true\r\n     * });\r\n     */\r\n    Node.prototype.cache = function (config) {\r\n        var conf = config || {};\r\n        var rect = {};\r\n        // don't call getClientRect if we have all attributes\r\n        // it means call it only if have one undefined\r\n        if (conf.x === undefined ||\r\n            conf.y === undefined ||\r\n            conf.width === undefined ||\r\n            conf.height === undefined) {\r\n            rect = this.getClientRect({\r\n                skipTransform: true,\r\n                relativeTo: this.getParent()\r\n            });\r\n        }\r\n        var width = conf.width || rect.width, height = conf.height || rect.height, pixelRatio = conf.pixelRatio, x = conf.x === undefined ? rect.x : conf.x, y = conf.y === undefined ? rect.y : conf.y, offset = conf.offset || 0, drawBorder = conf.drawBorder || false;\r\n        if (!width || !height) {\r\n            Util.error('Can not cache the node. Width or height of the node equals 0. Caching is skipped.');\r\n            return;\r\n        }\r\n        width += offset * 2;\r\n        height += offset * 2;\r\n        x -= offset;\r\n        y -= offset;\r\n        var cachedSceneCanvas = new SceneCanvas({\r\n            pixelRatio: pixelRatio,\r\n            width: width,\r\n            height: height\r\n        }), cachedFilterCanvas = new SceneCanvas({\r\n            pixelRatio: pixelRatio,\r\n            width: width,\r\n            height: height\r\n        }), cachedHitCanvas = new HitCanvas({\r\n            pixelRatio: 1,\r\n            width: width,\r\n            height: height\r\n        }), sceneContext = cachedSceneCanvas.getContext(), hitContext = cachedHitCanvas.getContext();\r\n        cachedHitCanvas.isCache = true;\r\n        this._cache.delete('canvas');\r\n        this._filterUpToDate = false;\r\n        if (conf.imageSmoothingEnabled === false) {\r\n            cachedSceneCanvas.getContext()._context.imageSmoothingEnabled = false;\r\n            cachedFilterCanvas.getContext()._context.imageSmoothingEnabled = false;\r\n            cachedHitCanvas.getContext()._context.imageSmoothingEnabled = false;\r\n        }\r\n        sceneContext.save();\r\n        hitContext.save();\r\n        sceneContext.translate(-x, -y);\r\n        hitContext.translate(-x, -y);\r\n        // extra flag to skip on getAbsolute opacity calc\r\n        this._isUnderCache = true;\r\n        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);\r\n        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);\r\n        this.drawScene(cachedSceneCanvas, this, true);\r\n        this.drawHit(cachedHitCanvas, this, true);\r\n        this._isUnderCache = false;\r\n        sceneContext.restore();\r\n        hitContext.restore();\r\n        // this will draw a red border around the cached box for\r\n        // debugging purposes\r\n        if (drawBorder) {\r\n            sceneContext.save();\r\n            sceneContext.beginPath();\r\n            sceneContext.rect(0, 0, width, height);\r\n            sceneContext.closePath();\r\n            sceneContext.setAttr('strokeStyle', 'red');\r\n            sceneContext.setAttr('lineWidth', 5);\r\n            sceneContext.stroke();\r\n            sceneContext.restore();\r\n        }\r\n        this._cache.set(CANVAS, {\r\n            scene: cachedSceneCanvas,\r\n            filter: cachedFilterCanvas,\r\n            hit: cachedHitCanvas,\r\n            x: x,\r\n            y: y\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Return client rectangle {x, y, width, height} of node. This rectangle also include all styling (strokes, shadows, etc).\r\n     * The rectangle position is relative to parent container.\r\n     * The purpose of the method is similar to getBoundingClientRect API of the DOM.\r\n     * @method\r\n     * @name Konva.Node#getClientRect\r\n     * @param {Object} config\r\n     * @param {Boolean} [config.skipTransform] should we apply transform to node for calculating rect?\r\n     * @param {Boolean} [config.skipShadow] should we apply shadow to the node for calculating bound box?\r\n     * @param {Boolean} [config.skipStroke] should we apply stroke to the node for calculating bound box?\r\n     * @param {Object} [config.relativeTo] calculate client rect relative to one of the parents\r\n     * @returns {Object} rect with {x, y, width, height} properties\r\n     * @example\r\n     * var rect = new Konva.Rect({\r\n     *      width : 100,\r\n     *      height : 100,\r\n     *      x : 50,\r\n     *      y : 50,\r\n     *      strokeWidth : 4,\r\n     *      stroke : 'black',\r\n     *      offsetX : 50,\r\n     *      scaleY : 2\r\n     * });\r\n     *\r\n     * // get client rect without think off transformations (position, rotation, scale, offset, etc)\r\n     * rect.getClientRect({ skipTransform: true});\r\n     * // returns {\r\n     * //     x : -2,   // two pixels for stroke / 2\r\n     * //     y : -2,\r\n     * //     width : 104, // increased by 4 for stroke\r\n     * //     height : 104\r\n     * //}\r\n     *\r\n     * // get client rect with transformation applied\r\n     * rect.getClientRect();\r\n     * // returns Object {x: -2, y: 46, width: 104, height: 208}\r\n     */\r\n    Node.prototype.getClientRect = function (config) {\r\n        // abstract method\r\n        // redefine in Container and Shape\r\n        throw new Error('abstract \"getClientRect\" method call');\r\n    };\r\n    Node.prototype._transformedRect = function (rect, top) {\r\n        var points = [\r\n            { x: rect.x, y: rect.y },\r\n            { x: rect.x + rect.width, y: rect.y },\r\n            { x: rect.x + rect.width, y: rect.y + rect.height },\r\n            { x: rect.x, y: rect.y + rect.height }\r\n        ];\r\n        var minX, minY, maxX, maxY;\r\n        var trans = this.getAbsoluteTransform(top);\r\n        points.forEach(function (point) {\r\n            var transformed = trans.point(point);\r\n            if (minX === undefined) {\r\n                minX = maxX = transformed.x;\r\n                minY = maxY = transformed.y;\r\n            }\r\n            minX = Math.min(minX, transformed.x);\r\n            minY = Math.min(minY, transformed.y);\r\n            maxX = Math.max(maxX, transformed.x);\r\n            maxY = Math.max(maxY, transformed.y);\r\n        });\r\n        return {\r\n            x: minX,\r\n            y: minY,\r\n            width: maxX - minX,\r\n            height: maxY - minY\r\n        };\r\n    };\r\n    Node.prototype._drawCachedSceneCanvas = function (context) {\r\n        context.save();\r\n        context._applyOpacity(this);\r\n        context._applyGlobalCompositeOperation(this);\r\n        var canvasCache = this._getCanvasCache();\r\n        context.translate(canvasCache.x, canvasCache.y);\r\n        var cacheCanvas = this._getCachedSceneCanvas();\r\n        var ratio = cacheCanvas.pixelRatio;\r\n        context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio);\r\n        context.restore();\r\n    };\r\n    Node.prototype._drawCachedHitCanvas = function (context) {\r\n        var canvasCache = this._getCanvasCache(), hitCanvas = canvasCache.hit;\r\n        context.save();\r\n        context._applyGlobalCompositeOperation(this);\r\n        context.translate(canvasCache.x, canvasCache.y);\r\n        context.drawImage(hitCanvas._canvas, 0, 0);\r\n        context.restore();\r\n    };\r\n    Node.prototype._getCachedSceneCanvas = function () {\r\n        var filters = this.filters(), cachedCanvas = this._getCanvasCache(), sceneCanvas = cachedCanvas.scene, filterCanvas = cachedCanvas.filter, filterContext = filterCanvas.getContext(), len, imageData, n, filter;\r\n        if (filters) {\r\n            if (!this._filterUpToDate) {\r\n                var ratio = sceneCanvas.pixelRatio;\r\n                try {\r\n                    len = filters.length;\r\n                    filterContext.clear();\r\n                    // copy cached canvas onto filter context\r\n                    filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);\r\n                    imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());\r\n                    // apply filters to filter context\r\n                    for (n = 0; n < len; n++) {\r\n                        filter = filters[n];\r\n                        if (typeof filter !== 'function') {\r\n                            Util.error('Filter should be type of function, but got ' +\r\n                                typeof filter +\r\n                                ' insted. Please check correct filters');\r\n                            continue;\r\n                        }\r\n                        filter.call(this, imageData);\r\n                        filterContext.putImageData(imageData, 0, 0);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    Util.error('Unable to apply filter. ' + e.message);\r\n                }\r\n                this._filterUpToDate = true;\r\n            }\r\n            return filterCanvas;\r\n        }\r\n        return sceneCanvas;\r\n    };\r\n    /**\r\n     * bind events to the node. KonvaJS supports mouseover, mousemove,\r\n     *  mouseout, mouseenter, mouseleave, mousedown, mouseup, wheel, contextmenu, click, dblclick, touchstart, touchmove,\r\n     *  touchend, tap, dbltap, dragstart, dragmove, and dragend events.\r\n     *  Pass in a string of events delimited by a space to bind multiple events at once\r\n     *  such as 'mousedown mouseup mousemove'. Include a namespace to bind an\r\n     *  event by name such as 'click.foobar'.\r\n     * @method\r\n     * @name Konva.Node#on\r\n     * @param {String} evtStr e.g. 'click', 'mousedown touchstart', 'mousedown.foo touchstart.foo'\r\n     * @param {Function} handler The handler function is passed an event object\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * // add click listener\r\n     * node.on('click', function() {\r\n     *   console.log('you clicked me!');\r\n     * });\r\n     *\r\n     * // get the target node\r\n     * node.on('click', function(evt) {\r\n     *   console.log(evt.target);\r\n     * });\r\n     *\r\n     * // stop event propagation\r\n     * node.on('click', function(evt) {\r\n     *   evt.cancelBubble = true;\r\n     * });\r\n     *\r\n     * // bind multiple listeners\r\n     * node.on('click touchstart', function() {\r\n     *   console.log('you clicked/touched me!');\r\n     * });\r\n     *\r\n     * // namespace listener\r\n     * node.on('click.foo', function() {\r\n     *   console.log('you clicked/touched me!');\r\n     * });\r\n     *\r\n     * // get the event type\r\n     * node.on('click tap', function(evt) {\r\n     *   var eventType = evt.type;\r\n     * });\r\n     *\r\n     * // get native event object\r\n     * node.on('click tap', function(evt) {\r\n     *   var nativeEvent = evt.evt;\r\n     * });\r\n     *\r\n     * // for change events, get the old and new val\r\n     * node.on('xChange', function(evt) {\r\n     *   var oldVal = evt.oldVal;\r\n     *   var newVal = evt.newVal;\r\n     * });\r\n     *\r\n     * // get event targets\r\n     * // with event delegations\r\n     * layer.on('click', 'Group', function(evt) {\r\n     *   var shape = evt.target;\r\n     *   var group = evt.currentTarget;\r\n     * });\r\n     */\r\n    Node.prototype.on = function (evtStr, handler) {\r\n        if (arguments.length === 3) {\r\n            return this._delegate.apply(this, arguments);\r\n        }\r\n        var events = evtStr.split(SPACE), len = events.length, n, event, parts, baseEvent, name;\r\n        /*\r\n         * loop through types and attach event listeners to\r\n         * each one.  eg. 'click mouseover.namespace mouseout'\r\n         * will create three event bindings\r\n         */\r\n        for (n = 0; n < len; n++) {\r\n            event = events[n];\r\n            parts = event.split('.');\r\n            baseEvent = parts[0];\r\n            name = parts[1] || '';\r\n            // create events array if it doesn't exist\r\n            if (!this.eventListeners[baseEvent]) {\r\n                this.eventListeners[baseEvent] = [];\r\n            }\r\n            this.eventListeners[baseEvent].push({\r\n                name: name,\r\n                handler: handler\r\n            });\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * remove event bindings from the node. Pass in a string of\r\n     *  event types delimmited by a space to remove multiple event\r\n     *  bindings at once such as 'mousedown mouseup mousemove'.\r\n     *  include a namespace to remove an event binding by name\r\n     *  such as 'click.foobar'. If you only give a name like '.foobar',\r\n     *  all events in that namespace will be removed.\r\n     * @method\r\n     * @name Konva.Node#off\r\n     * @param {String} evtStr e.g. 'click', 'mousedown touchstart', '.foobar'\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * // remove listener\r\n     * node.off('click');\r\n     *\r\n     * // remove multiple listeners\r\n     * node.off('click touchstart');\r\n     *\r\n     * // remove listener by name\r\n     * node.off('click.foo');\r\n     */\r\n    Node.prototype.off = function (evtStr, callback) {\r\n        var events = (evtStr || '').split(SPACE), len = events.length, n, t, event, parts, baseEvent, name;\r\n        if (!evtStr) {\r\n            // remove all events\r\n            for (t in this.eventListeners) {\r\n                this._off(t);\r\n            }\r\n        }\r\n        for (n = 0; n < len; n++) {\r\n            event = events[n];\r\n            parts = event.split('.');\r\n            baseEvent = parts[0];\r\n            name = parts[1];\r\n            if (baseEvent) {\r\n                if (this.eventListeners[baseEvent]) {\r\n                    this._off(baseEvent, name, callback);\r\n                }\r\n            }\r\n            else {\r\n                for (t in this.eventListeners) {\r\n                    this._off(t, name, callback);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    // some event aliases for third party integration like HammerJS\r\n    Node.prototype.dispatchEvent = function (evt) {\r\n        var e = {\r\n            target: this,\r\n            type: evt.type,\r\n            evt: evt\r\n        };\r\n        this.fire(evt.type, e);\r\n        return this;\r\n    };\r\n    Node.prototype.addEventListener = function (type, handler) {\r\n        // we have to pass native event to handler\r\n        this.on(type, function (evt) {\r\n            handler.call(this, evt.evt);\r\n        });\r\n        return this;\r\n    };\r\n    Node.prototype.removeEventListener = function (type) {\r\n        this.off(type);\r\n        return this;\r\n    };\r\n    // like node.on\r\n    Node.prototype._delegate = function (event, selector, handler) {\r\n        var stopNode = this;\r\n        this.on(event, function (evt) {\r\n            var targets = evt.target.findAncestors(selector, true, stopNode);\r\n            for (var i = 0; i < targets.length; i++) {\r\n                evt = Util.cloneObject(evt);\r\n                evt.currentTarget = targets[i];\r\n                handler.call(targets[i], evt);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * remove a node from parent, but don't destroy. You can reuse the node later.\r\n     * @method\r\n     * @name Konva.Node#remove\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * node.remove();\r\n     */\r\n    Node.prototype.remove = function () {\r\n        if (DD.node && DD.node === this) {\r\n            this.stopDrag();\r\n        }\r\n        this._remove();\r\n        return this;\r\n    };\r\n    Node.prototype._remove = function () {\r\n        // every cached attr that is calculated via node tree\r\n        // traversal must be cleared when removing a node\r\n        this._clearSelfAndDescendantCache(STAGE);\r\n        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);\r\n        this._clearSelfAndDescendantCache(VISIBLE);\r\n        this._clearSelfAndDescendantCache(LISTENING);\r\n        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);\r\n        var parent = this.getParent();\r\n        if (parent && parent.children) {\r\n            parent.children.splice(this.index, 1);\r\n            parent._setChildrenIndices();\r\n            this.parent = null;\r\n        }\r\n    };\r\n    /**\r\n     * remove and destroy a node. Kill it and delete forever! You should not reuse node after destroy().\r\n     * If the node is a container (Group, Stage or Layer) it will destroy all children too.\r\n     * @method\r\n     * @name Konva.Node#destroy\r\n     * @example\r\n     * node.destroy();\r\n     */\r\n    Node.prototype.destroy = function () {\r\n        // remove from ids and names hashes\r\n        _removeId(this.id(), this);\r\n        // remove all names\r\n        var names = (this.name() || '').split(/\\s/g);\r\n        for (var i = 0; i < names.length; i++) {\r\n            var subname = names[i];\r\n            _removeName(subname, this._id);\r\n        }\r\n        this.remove();\r\n        return this;\r\n    };\r\n    /**\r\n     * get attr\r\n     * @method\r\n     * @name Konva.Node#getAttr\r\n     * @param {String} attr\r\n     * @returns {Integer|String|Object|Array}\r\n     * @example\r\n     * var x = node.getAttr('x');\r\n     */\r\n    Node.prototype.getAttr = function (attr) {\r\n        var method = 'get' + Util._capitalize(attr);\r\n        if (Util._isFunction(this[method])) {\r\n            return this[method]();\r\n        }\r\n        // otherwise get directly\r\n        return this.attrs[attr];\r\n    };\r\n    /**\r\n     * get ancestors\r\n     * @method\r\n     * @name Konva.Node#getAncestors\r\n     * @returns {Konva.Collection}\r\n     * @example\r\n     * shape.getAncestors().each(function(node) {\r\n     *   console.log(node.getId());\r\n     * })\r\n     */\r\n    Node.prototype.getAncestors = function () {\r\n        var parent = this.getParent(), ancestors = new Collection();\r\n        while (parent) {\r\n            ancestors.push(parent);\r\n            parent = parent.getParent();\r\n        }\r\n        return ancestors;\r\n    };\r\n    /**\r\n     * get attrs object literal\r\n     * @method\r\n     * @name Konva.Node#getAttrs\r\n     * @returns {Object}\r\n     */\r\n    Node.prototype.getAttrs = function () {\r\n        return this.attrs || {};\r\n    };\r\n    /**\r\n     * set multiple attrs at once using an object literal\r\n     * @method\r\n     * @name Konva.Node#setAttrs\r\n     * @param {Object} config object containing key value pairs\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * node.setAttrs({\r\n     *   x: 5,\r\n     *   fill: 'red'\r\n     * });\r\n     */\r\n    Node.prototype.setAttrs = function (config) {\r\n        var key, method;\r\n        if (!config) {\r\n            return this;\r\n        }\r\n        for (key in config) {\r\n            if (key === CHILDREN) {\r\n                continue;\r\n            }\r\n            method = SET + Util._capitalize(key);\r\n            // use setter if available\r\n            if (Util._isFunction(this[method])) {\r\n                this[method](config[key]);\r\n            }\r\n            else {\r\n                // otherwise set directly\r\n                this._setAttr(key, config[key]);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * determine if node is listening for events by taking into account ancestors.\r\n     *\r\n     * Parent    | Self      | isListening\r\n     * listening | listening |\r\n     * ----------+-----------+------------\r\n     * T         | T         | T\r\n     * T         | F         | F\r\n     * F         | T         | T\r\n     * F         | F         | F\r\n     * ----------+-----------+------------\r\n     * T         | I         | T\r\n     * F         | I         | F\r\n     * I         | I         | T\r\n     *\r\n     * @method\r\n     * @name Konva.Node#isListening\r\n     * @returns {Boolean}\r\n     */\r\n    Node.prototype.isListening = function () {\r\n        return this._getCache(LISTENING, this._isListening);\r\n    };\r\n    Node.prototype._isListening = function () {\r\n        var listening = this.listening(), parent = this.getParent();\r\n        // the following conditions are a simplification of the truth table above.\r\n        // please modify carefully\r\n        if (listening === 'inherit') {\r\n            if (parent) {\r\n                return parent.isListening();\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            return listening;\r\n        }\r\n    };\r\n    /**\r\n       * determine if node is visible by taking into account ancestors.\r\n       *\r\n       * Parent    | Self      | isVisible\r\n       * visible   | visible   |\r\n       * ----------+-----------+------------\r\n       * T         | T         | T\r\n       * T         | F         | F\r\n       * F         | T         | T\r\n       * F         | F         | F\r\n       * ----------+-----------+------------\r\n       * T         | I         | T\r\n       * F         | I         | F\r\n       * I         | I         | T\r\n  \n        * @method\r\n        * @name Konva.Node#isVisible\r\n        * @returns {Boolean}\r\n        */\r\n    Node.prototype.isVisible = function () {\r\n        return this._getCache(VISIBLE, this._isVisible);\r\n    };\r\n    Node.prototype._isVisible = function (relativeTo) {\r\n        var visible = this.visible(), parent = this.getParent();\r\n        // the following conditions are a simplification of the truth table above.\r\n        // please modify carefully\r\n        if (visible === 'inherit') {\r\n            if (parent && parent !== relativeTo) {\r\n                return parent._isVisible(relativeTo);\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            return visible;\r\n        }\r\n    };\r\n    /**\r\n     * determine if listening is enabled by taking into account descendants.  If self or any children\r\n     * have _isListeningEnabled set to true, then self also has listening enabled.\r\n     * @method\r\n     * @name Konva.Node#shouldDrawHit\r\n     * @returns {Boolean}\r\n     */\r\n    Node.prototype.shouldDrawHit = function () {\r\n        var layer = this.getLayer();\r\n        return ((!layer && this.isListening() && this.isVisible()) ||\r\n            (layer &&\r\n                layer.hitGraphEnabled() &&\r\n                this.isListening() &&\r\n                this.isVisible()));\r\n    };\r\n    /**\r\n     * show node. set visible = true\r\n     * @method\r\n     * @name Konva.Node#show\r\n     * @returns {Konva.Node}\r\n     */\r\n    Node.prototype.show = function () {\r\n        this.visible(true);\r\n        return this;\r\n    };\r\n    /**\r\n     * hide node.  Hidden nodes are no longer detectable\r\n     * @method\r\n     * @name Konva.Node#hide\r\n     * @returns {Konva.Node}\r\n     */\r\n    Node.prototype.hide = function () {\r\n        this.visible(false);\r\n        return this;\r\n    };\r\n    Node.prototype.getZIndex = function () {\r\n        return this.index || 0;\r\n    };\r\n    /**\r\n     * get absolute z-index which takes into account sibling\r\n     *  and ancestor indices\r\n     * @method\r\n     * @name Konva.Node#getAbsoluteZIndex\r\n     * @returns {Integer}\r\n     */\r\n    Node.prototype.getAbsoluteZIndex = function () {\r\n        var depth = this.getDepth(), that = this, index = 0, nodes, len, n, child;\r\n        function addChildren(children) {\r\n            nodes = [];\r\n            len = children.length;\r\n            for (n = 0; n < len; n++) {\r\n                child = children[n];\r\n                index++;\r\n                if (child.nodeType !== SHAPE) {\r\n                    nodes = nodes.concat(child.getChildren().toArray());\r\n                }\r\n                if (child._id === that._id) {\r\n                    n = len;\r\n                }\r\n            }\r\n            if (nodes.length > 0 && nodes[0].getDepth() <= depth) {\r\n                addChildren(nodes);\r\n            }\r\n        }\r\n        if (that.nodeType !== UPPER_STAGE) {\r\n            addChildren(that.getStage().getChildren());\r\n        }\r\n        return index;\r\n    };\r\n    /**\r\n     * get node depth in node tree.  Returns an integer.\r\n     *  e.g. Stage depth will always be 0.  Layers will always be 1.  Groups and Shapes will always\r\n     *  be >= 2\r\n     * @method\r\n     * @name Konva.Node#getDepth\r\n     * @returns {Integer}\r\n     */\r\n    Node.prototype.getDepth = function () {\r\n        var depth = 0, parent = this.parent;\r\n        while (parent) {\r\n            depth++;\r\n            parent = parent.parent;\r\n        }\r\n        return depth;\r\n    };\r\n    Node.prototype.setPosition = function (pos) {\r\n        this.x(pos.x);\r\n        this.y(pos.y);\r\n        return this;\r\n    };\r\n    Node.prototype.getPosition = function () {\r\n        return {\r\n            x: this.x(),\r\n            y: this.y()\r\n        };\r\n    };\r\n    Node.prototype.getAbsolutePosition = function (top) {\r\n        var absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(), absoluteTransform = new Transform(), offset = this.offset();\r\n        // clone the matrix array\r\n        absoluteTransform.m = absoluteMatrix.slice();\r\n        absoluteTransform.translate(offset.x, offset.y);\r\n        return absoluteTransform.getTranslation();\r\n    };\r\n    Node.prototype.setAbsolutePosition = function (pos) {\r\n        var origTrans = this._clearTransform(), it;\r\n        // don't clear translation\r\n        this.attrs.x = origTrans.x;\r\n        this.attrs.y = origTrans.y;\r\n        delete origTrans.x;\r\n        delete origTrans.y;\r\n        // unravel transform\r\n        it = this.getAbsoluteTransform();\r\n        it.invert();\r\n        it.translate(pos.x, pos.y);\r\n        pos = {\r\n            x: this.attrs.x + it.getTranslation().x,\r\n            y: this.attrs.y + it.getTranslation().y\r\n        };\r\n        this.setPosition({ x: pos.x, y: pos.y });\r\n        this._setTransform(origTrans);\r\n        return this;\r\n    };\r\n    Node.prototype._setTransform = function (trans) {\r\n        var key;\r\n        for (key in trans) {\r\n            this.attrs[key] = trans[key];\r\n        }\r\n        this._clearCache(TRANSFORM);\r\n        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);\r\n    };\r\n    Node.prototype._clearTransform = function () {\r\n        var trans = {\r\n            x: this.x(),\r\n            y: this.y(),\r\n            rotation: this.rotation(),\r\n            scaleX: this.scaleX(),\r\n            scaleY: this.scaleY(),\r\n            offsetX: this.offsetX(),\r\n            offsetY: this.offsetY(),\r\n            skewX: this.skewX(),\r\n            skewY: this.skewY()\r\n        };\r\n        this.attrs.x = 0;\r\n        this.attrs.y = 0;\r\n        this.attrs.rotation = 0;\r\n        this.attrs.scaleX = 1;\r\n        this.attrs.scaleY = 1;\r\n        this.attrs.offsetX = 0;\r\n        this.attrs.offsetY = 0;\r\n        this.attrs.skewX = 0;\r\n        this.attrs.skewY = 0;\r\n        this._clearCache(TRANSFORM);\r\n        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);\r\n        // return original transform\r\n        return trans;\r\n    };\r\n    /**\r\n     * move node by an amount relative to its current position\r\n     * @method\r\n     * @name Konva.Node#move\r\n     * @param {Object} change\r\n     * @param {Number} change.x\r\n     * @param {Number} change.y\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * // move node in x direction by 1px and y direction by 2px\r\n     * node.move({\r\n     *   x: 1,\r\n     *   y: 2\r\n     * });\r\n     */\r\n    Node.prototype.move = function (change) {\r\n        var changeX = change.x, changeY = change.y, x = this.x(), y = this.y();\r\n        if (changeX !== undefined) {\r\n            x += changeX;\r\n        }\r\n        if (changeY !== undefined) {\r\n            y += changeY;\r\n        }\r\n        this.setPosition({ x: x, y: y });\r\n        return this;\r\n    };\r\n    Node.prototype._eachAncestorReverse = function (func, top) {\r\n        var family = [], parent = this.getParent(), len, n;\r\n        // if top node is defined, and this node is top node,\r\n        // there's no need to build a family tree.  just execute\r\n        // func with this because it will be the only node\r\n        if (top && top._id === this._id) {\r\n            func(this);\r\n            return;\r\n        }\r\n        family.unshift(this);\r\n        while (parent && (!top || parent._id !== top._id)) {\r\n            family.unshift(parent);\r\n            parent = parent.parent;\r\n        }\r\n        len = family.length;\r\n        for (n = 0; n < len; n++) {\r\n            func(family[n]);\r\n        }\r\n    };\r\n    /**\r\n     * rotate node by an amount in degrees relative to its current rotation\r\n     * @method\r\n     * @name Konva.Node#rotate\r\n     * @param {Number} theta\r\n     * @returns {Konva.Node}\r\n     */\r\n    Node.prototype.rotate = function (theta) {\r\n        this.rotation(this.rotation() + theta);\r\n        return this;\r\n    };\r\n    /**\r\n     * move node to the top of its siblings\r\n     * @method\r\n     * @name Konva.Node#moveToTop\r\n     * @returns {Boolean}\r\n     */\r\n    Node.prototype.moveToTop = function () {\r\n        if (!this.parent) {\r\n            Util.warn('Node has no parent. moveToTop function is ignored.');\r\n            return false;\r\n        }\r\n        var index = this.index;\r\n        this.parent.children.splice(index, 1);\r\n        this.parent.children.push(this);\r\n        this.parent._setChildrenIndices();\r\n        return true;\r\n    };\r\n    /**\r\n     * move node up\r\n     * @method\r\n     * @name Konva.Node#moveUp\r\n     * @returns {Boolean} flag is moved or not\r\n     */\r\n    Node.prototype.moveUp = function () {\r\n        if (!this.parent) {\r\n            Util.warn('Node has no parent. moveUp function is ignored.');\r\n            return false;\r\n        }\r\n        var index = this.index, len = this.parent.getChildren().length;\r\n        if (index < len - 1) {\r\n            this.parent.children.splice(index, 1);\r\n            this.parent.children.splice(index + 1, 0, this);\r\n            this.parent._setChildrenIndices();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * move node down\r\n     * @method\r\n     * @name Konva.Node#moveDown\r\n     * @returns {Boolean}\r\n     */\r\n    Node.prototype.moveDown = function () {\r\n        if (!this.parent) {\r\n            Util.warn('Node has no parent. moveDown function is ignored.');\r\n            return false;\r\n        }\r\n        var index = this.index;\r\n        if (index > 0) {\r\n            this.parent.children.splice(index, 1);\r\n            this.parent.children.splice(index - 1, 0, this);\r\n            this.parent._setChildrenIndices();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * move node to the bottom of its siblings\r\n     * @method\r\n     * @name Konva.Node#moveToBottom\r\n     * @returns {Boolean}\r\n     */\r\n    Node.prototype.moveToBottom = function () {\r\n        if (!this.parent) {\r\n            Util.warn('Node has no parent. moveToBottom function is ignored.');\r\n            return false;\r\n        }\r\n        var index = this.index;\r\n        if (index > 0) {\r\n            this.parent.children.splice(index, 1);\r\n            this.parent.children.unshift(this);\r\n            this.parent._setChildrenIndices();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    Node.prototype.setZIndex = function (zIndex) {\r\n        if (!this.parent) {\r\n            Util.warn('Node has no parent. zIndex parameter is ignored.');\r\n            return this;\r\n        }\r\n        if (zIndex < 0 || zIndex >= this.parent.children.length) {\r\n            Util.warn('Unexpected value ' +\r\n                zIndex +\r\n                ' for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to ' +\r\n                (this.parent.children.length - 1) +\r\n                '.');\r\n        }\r\n        var index = this.index;\r\n        this.parent.children.splice(index, 1);\r\n        this.parent.children.splice(zIndex, 0, this);\r\n        this.parent._setChildrenIndices();\r\n        return this;\r\n    };\r\n    /**\r\n     * get absolute opacity\r\n     * @method\r\n     * @name Konva.Node#getAbsoluteOpacity\r\n     * @returns {Number}\r\n     */\r\n    Node.prototype.getAbsoluteOpacity = function () {\r\n        return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);\r\n    };\r\n    Node.prototype._getAbsoluteOpacity = function () {\r\n        var absOpacity = this.opacity();\r\n        var parent = this.getParent();\r\n        if (parent && !parent._isUnderCache) {\r\n            absOpacity *= parent.getAbsoluteOpacity();\r\n        }\r\n        return absOpacity;\r\n    };\r\n    /**\r\n     * move node to another container\r\n     * @method\r\n     * @name Konva.Node#moveTo\r\n     * @param {Container} newContainer\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * // move node from current layer into layer2\r\n     * node.moveTo(layer2);\r\n     */\r\n    Node.prototype.moveTo = function (newContainer) {\r\n        // do nothing if new container is already parent\r\n        if (this.getParent() !== newContainer) {\r\n            this._remove();\r\n            newContainer.add(this);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * convert Node into an object for serialization.  Returns an object.\r\n     * @method\r\n     * @name Konva.Node#toObject\r\n     * @returns {Object}\r\n     */\r\n    Node.prototype.toObject = function () {\r\n        var obj = {}, attrs = this.getAttrs(), key, val, getter, defaultValue, nonPlainObject;\r\n        obj.attrs = {};\r\n        for (key in attrs) {\r\n            val = attrs[key];\r\n            // if value is object and object is not plain\r\n            // like class instance, we should skip it and to not include\r\n            nonPlainObject =\r\n                Util.isObject(val) && !Util._isPlainObject(val) && !Util._isArray(val);\r\n            if (nonPlainObject) {\r\n                continue;\r\n            }\r\n            getter = typeof this[key] === 'function' && this[key];\r\n            // remove attr value so that we can extract the default value from the getter\r\n            delete attrs[key];\r\n            defaultValue = getter ? getter.call(this) : null;\r\n            // restore attr value\r\n            attrs[key] = val;\r\n            if (defaultValue !== val) {\r\n                obj.attrs[key] = val;\r\n            }\r\n        }\r\n        obj.className = this.getClassName();\r\n        return Util._prepareToStringify(obj);\r\n    };\r\n    /**\r\n     * convert Node into a JSON string.  Returns a JSON string.\r\n     * @method\r\n     * @name Konva.Node#toJSON\r\n     * @returns {String}\r\n     */\r\n    Node.prototype.toJSON = function () {\r\n        return JSON.stringify(this.toObject());\r\n    };\r\n    /**\r\n     * get parent container\r\n     * @method\r\n     * @name Konva.Node#getParent\r\n     * @returns {Konva.Node}\r\n     */\r\n    Node.prototype.getParent = function () {\r\n        return this.parent;\r\n    };\r\n    /**\r\n     * get all ancestros (parent then parent of the parent, etc) of the node\r\n     * @method\r\n     * @name Konva.Node#findAncestors\r\n     * @param {String} [selector] selector for search\r\n     * @param {Boolean} [includeSelf] show we think that node is ancestro itself?\r\n     * @param {Konva.Node} [stopNode] optional node where we need to stop searching (one of ancestors)\r\n     * @returns {Array} [ancestors]\r\n     * @example\r\n     * // get one of the parent group\r\n     * var parentGroups = node.findAncestors('Group');\r\n     */\r\n    Node.prototype.findAncestors = function (selector, includeSelf, stopNode) {\r\n        var res = [];\r\n        if (includeSelf && this._isMatch(selector)) {\r\n            res.push(this);\r\n        }\r\n        var ancestor = this.parent;\r\n        while (ancestor) {\r\n            if (ancestor === stopNode) {\r\n                return res;\r\n            }\r\n            if (ancestor._isMatch(selector)) {\r\n                res.push(ancestor);\r\n            }\r\n            ancestor = ancestor.parent;\r\n        }\r\n        return res;\r\n    };\r\n    Node.prototype.isAncestorOf = function (node) {\r\n        return false;\r\n    };\r\n    /**\r\n     * get ancestor (parent or parent of the parent, etc) of the node that match passed selector\r\n     * @method\r\n     * @name Konva.Node#findAncestor\r\n     * @param {String} [selector] selector for search\r\n     * @param {Boolean} [includeSelf] show we think that node is ancestro itself?\r\n     * @param {Konva.Node} [stopNode] optional node where we need to stop searching (one of ancestors)\r\n     * @returns {Konva.Node} ancestor\r\n     * @example\r\n     * // get one of the parent group\r\n     * var group = node.findAncestors('.mygroup');\r\n     */\r\n    Node.prototype.findAncestor = function (selector, includeSelf, stopNode) {\r\n        return this.findAncestors(selector, includeSelf, stopNode)[0];\r\n    };\r\n    // is current node match passed selector?\r\n    Node.prototype._isMatch = function (selector) {\r\n        if (!selector) {\r\n            return false;\r\n        }\r\n        if (typeof selector === 'function') {\r\n            return selector(this);\r\n        }\r\n        var selectorArr = selector.replace(/ /g, '').split(','), len = selectorArr.length, n, sel;\r\n        for (n = 0; n < len; n++) {\r\n            sel = selectorArr[n];\r\n            if (!Util.isValidSelector(sel)) {\r\n                Util.warn('Selector \"' +\r\n                    sel +\r\n                    '\" is invalid. Allowed selectors examples are \"#foo\", \".bar\" or \"Group\".');\r\n                Util.warn('If you have a custom shape with such className, please change it to start with upper letter like \"Triangle\".');\r\n                Util.warn('Konva is awesome, right?');\r\n            }\r\n            // id selector\r\n            if (sel.charAt(0) === '#') {\r\n                if (this.id() === sel.slice(1)) {\r\n                    return true;\r\n                }\r\n            }\r\n            else if (sel.charAt(0) === '.') {\r\n                // name selector\r\n                if (this.hasName(sel.slice(1))) {\r\n                    return true;\r\n                }\r\n            }\r\n            else if (this.className === selector || this.nodeType === selector) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * get layer ancestor\r\n     * @method\r\n     * @name Konva.Node#getLayer\r\n     * @returns {Konva.Layer}\r\n     */\r\n    Node.prototype.getLayer = function () {\r\n        var parent = this.getParent();\r\n        return parent ? parent.getLayer() : null;\r\n    };\r\n    /**\r\n     * get stage ancestor\r\n     * @method\r\n     * @name Konva.Node#getStage\r\n     * @returns {Konva.Stage}\r\n     */\r\n    Node.prototype.getStage = function () {\r\n        return this._getCache(STAGE, this._getStage);\r\n    };\r\n    Node.prototype._getStage = function () {\r\n        var parent = this.getParent();\r\n        if (parent) {\r\n            return parent.getStage();\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    };\r\n    /**\r\n     * fire event\r\n     * @method\r\n     * @name Konva.Node#fire\r\n     * @param {String} eventType event type.  can be a regular event, like click, mouseover, or mouseout, or it can be a custom event, like myCustomEvent\r\n     * @param {Event} [evt] event object\r\n     * @param {Boolean} [bubble] setting the value to false, or leaving it undefined, will result in the event\r\n     *  not bubbling.  Setting the value to true will result in the event bubbling.\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * // manually fire click event\r\n     * node.fire('click');\r\n     *\r\n     * // fire custom event\r\n     * node.fire('foo');\r\n     *\r\n     * // fire custom event with custom event object\r\n     * node.fire('foo', {\r\n     *   bar: 10\r\n     * });\r\n     *\r\n     * // fire click event that bubbles\r\n     * node.fire('click', null, true);\r\n     */\r\n    Node.prototype.fire = function (eventType, evt, bubble) {\r\n        evt = evt || {};\r\n        evt.target = evt.target || this;\r\n        // bubble\r\n        if (bubble) {\r\n            this._fireAndBubble(eventType, evt);\r\n        }\r\n        else {\r\n            // no bubble\r\n            this._fire(eventType, evt);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * get absolute transform of the node which takes into\r\n     *  account its ancestor transforms\r\n     * @method\r\n     * @name Konva.Node#getAbsoluteTransform\r\n     * @returns {Konva.Transform}\r\n     */\r\n    Node.prototype.getAbsoluteTransform = function (top) {\r\n        // if using an argument, we can't cache the result.\r\n        if (top) {\r\n            return this._getAbsoluteTransform(top);\r\n        }\r\n        else {\r\n            // if no argument, we can cache the result\r\n            return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);\r\n        }\r\n    };\r\n    Node.prototype._getAbsoluteTransform = function (top) {\r\n        var at = new Transform();\r\n        // start with stage and traverse downwards to self\r\n        this._eachAncestorReverse(function (node) {\r\n            var transformsEnabled = node.getTransformsEnabled();\r\n            if (transformsEnabled === 'all') {\r\n                at.multiply(node.getTransform());\r\n            }\r\n            else if (transformsEnabled === 'position') {\r\n                at.translate(node.getX() - node.getOffsetX(), node.getY() - node.getOffsetY());\r\n            }\r\n        }, top);\r\n        return at;\r\n    };\r\n    /**\r\n     * get absolute scale of the node which takes into\r\n     *  account its ancestor scales\r\n     * @method\r\n     * @name Konva.Node#getAbsoluteScale\r\n     * @returns {Konva.Transform}\r\n     */\r\n    Node.prototype.getAbsoluteScale = function (top) {\r\n        // if using an argument, we can't cache the result.\r\n        if (top) {\r\n            return this._getAbsoluteScale(top);\r\n        }\r\n        else {\r\n            // if no argument, we can cache the result\r\n            return this._getCache(ABSOLUTE_SCALE, this._getAbsoluteScale);\r\n        }\r\n    };\r\n    Node.prototype._getAbsoluteScale = function (top) {\r\n        // this is special logic for caching with some shapes with shadow\r\n        var parent = this;\r\n        while (parent) {\r\n            if (parent._isUnderCache) {\r\n                top = parent;\r\n            }\r\n            parent = parent.getParent();\r\n        }\r\n        var scaleX = 1, scaleY = 1;\r\n        // start with stage and traverse downwards to self\r\n        this._eachAncestorReverse(function (node) {\r\n            scaleX *= node.scaleX();\r\n            scaleY *= node.scaleY();\r\n        }, top);\r\n        return {\r\n            x: scaleX,\r\n            y: scaleY\r\n        };\r\n    };\r\n    /**\r\n     * get transform of the node\r\n     * @method\r\n     * @name Konva.Node#getTransform\r\n     * @returns {Konva.Transform}\r\n     */\r\n    Node.prototype.getTransform = function () {\r\n        return this._getCache(TRANSFORM, this._getTransform);\r\n    };\r\n    Node.prototype._getTransform = function () {\r\n        var m = new Transform(), x = this.x(), y = this.y(), rotation = Konva.getAngle(this.rotation()), scaleX = this.scaleX(), scaleY = this.scaleY(), skewX = this.skewX(), skewY = this.skewY(), offsetX = this.offsetX(), offsetY = this.offsetY();\r\n        if (x !== 0 || y !== 0) {\r\n            m.translate(x, y);\r\n        }\r\n        if (rotation !== 0) {\r\n            m.rotate(rotation);\r\n        }\r\n        if (skewX !== 0 || skewY !== 0) {\r\n            m.skew(skewX, skewY);\r\n        }\r\n        if (scaleX !== 1 || scaleY !== 1) {\r\n            m.scale(scaleX, scaleY);\r\n        }\r\n        if (offsetX !== 0 || offsetY !== 0) {\r\n            m.translate(-1 * offsetX, -1 * offsetY);\r\n        }\r\n        return m;\r\n    };\r\n    /**\r\n     * clone node.  Returns a new Node instance with identical attributes.  You can also override\r\n     *  the node properties with an object literal, enabling you to use an existing node as a template\r\n     *  for another node\r\n     * @method\r\n     * @name Konva.Node#clone\r\n     * @param {Object} obj override attrs\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * // simple clone\r\n     * var clone = node.clone();\r\n     *\r\n     * // clone a node and override the x position\r\n     * var clone = rect.clone({\r\n     *   x: 5\r\n     * });\r\n     */\r\n    Node.prototype.clone = function (obj) {\r\n        // instantiate new node\r\n        var attrs = Util.cloneObject(this.attrs), key, allListeners, len, n, listener;\r\n        // filter black attrs\r\n        for (var i in CLONE_BLACK_LIST) {\r\n            var blockAttr = CLONE_BLACK_LIST[i];\r\n            delete attrs[blockAttr];\r\n        }\r\n        // apply attr overrides\r\n        for (key in obj) {\r\n            attrs[key] = obj[key];\r\n        }\r\n        var node = new this.constructor(attrs);\r\n        // copy over listeners\r\n        for (key in this.eventListeners) {\r\n            allListeners = this.eventListeners[key];\r\n            len = allListeners.length;\r\n            for (n = 0; n < len; n++) {\r\n                listener = allListeners[n];\r\n                /*\r\n                 * don't include konva namespaced listeners because\r\n                 *  these are generated by the constructors\r\n                 */\r\n                if (listener.name.indexOf(KONVA) < 0) {\r\n                    // if listeners array doesn't exist, then create it\r\n                    if (!node.eventListeners[key]) {\r\n                        node.eventListeners[key] = [];\r\n                    }\r\n                    node.eventListeners[key].push(listener);\r\n                }\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    Node.prototype._toKonvaCanvas = function (config) {\r\n        config = config || {};\r\n        var box = this.getClientRect();\r\n        var stage = this.getStage(), x = config.x !== undefined ? config.x : box.x, y = config.y !== undefined ? config.y : box.y, pixelRatio = config.pixelRatio || 1, canvas = new SceneCanvas({\r\n            width: config.width || box.width || (stage ? stage.getWidth() : 0),\r\n            height: config.height || box.height || (stage ? stage.getHeight() : 0),\r\n            pixelRatio: pixelRatio\r\n        }), context = canvas.getContext();\r\n        context.save();\r\n        if (x || y) {\r\n            context.translate(-1 * x, -1 * y);\r\n        }\r\n        this.drawScene(canvas);\r\n        context.restore();\r\n        return canvas;\r\n    };\r\n    /**\r\n     * converts node into an canvas element.\r\n     * @method\r\n     * @name Konva.Node#toCanvas\r\n     * @param {Object} config\r\n     * @param {Function} config.callback function executed when the composite has completed\r\n     * @param {Number} [config.x] x position of canvas section\r\n     * @param {Number} [config.y] y position of canvas section\r\n     * @param {Number} [config.width] width of canvas section\r\n     * @param {Number} [config.height] height of canvas section\r\n     * @param {Number} [config.pixelRatio] pixelRatio of output canvas. Default is 1.\r\n     * You can use that property to increase quality of the image, for example for super hight quality exports\r\n     * or usage on retina (or similar) displays. pixelRatio will be used to multiply the size of exported image.\r\n     * If you export to 500x500 size with pixelRatio = 2, then produced image will have size 1000x1000.\r\n     * @example\r\n     * var canvas = node.toCanvas();\r\n     */\r\n    Node.prototype.toCanvas = function (config) {\r\n        return this._toKonvaCanvas(config)._canvas;\r\n    };\r\n    /**\r\n     * Creates a composite data URL (base64 string). If MIME type is not\r\n     * specified, then \"image/png\" will result. For \"image/jpeg\", specify a quality\r\n     * level as quality (range 0.0 - 1.0)\r\n     * @method\r\n     * @name Konva.Node#toDataURL\r\n     * @param {Object} config\r\n     * @param {String} [config.mimeType] can be \"image/png\" or \"image/jpeg\".\r\n     *  \"image/png\" is the default\r\n     * @param {Number} [config.x] x position of canvas section\r\n     * @param {Number} [config.y] y position of canvas section\r\n     * @param {Number} [config.width] width of canvas section\r\n     * @param {Number} [config.height] height of canvas section\r\n     * @param {Number} [config.quality] jpeg quality.  If using an \"image/jpeg\" mimeType,\r\n     *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1\r\n     *  is very high quality\r\n     * @param {Number} [config.pixelRatio] pixelRatio of output image url. Default is 1.\r\n     * You can use that property to increase quality of the image, for example for super hight quality exports\r\n     * or usage on retina (or similar) displays. pixelRatio will be used to multiply the size of exported image.\r\n     * If you export to 500x500 size with pixelRatio = 2, then produced image will have size 1000x1000.\r\n     * @returns {String}\r\n     */\r\n    Node.prototype.toDataURL = function (config) {\r\n        config = config || {};\r\n        var mimeType = config.mimeType || null, quality = config.quality || null;\r\n        var url = this._toKonvaCanvas(config).toDataURL(mimeType, quality);\r\n        if (config.callback) {\r\n            config.callback(url);\r\n        }\r\n        return url;\r\n    };\r\n    /**\r\n     * converts node into an image.  Since the toImage\r\n     *  method is asynchronous, a callback is required.  toImage is most commonly used\r\n     *  to cache complex drawings as an image so that they don't have to constantly be redrawn\r\n     * @method\r\n     * @name Konva.Node#toImage\r\n     * @param {Object} config\r\n     * @param {Function} config.callback function executed when the composite has completed\r\n     * @param {String} [config.mimeType] can be \"image/png\" or \"image/jpeg\".\r\n     *  \"image/png\" is the default\r\n     * @param {Number} [config.x] x position of canvas section\r\n     * @param {Number} [config.y] y position of canvas section\r\n     * @param {Number} [config.width] width of canvas section\r\n     * @param {Number} [config.height] height of canvas section\r\n     * @param {Number} [config.quality] jpeg quality.  If using an \"image/jpeg\" mimeType,\r\n     *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1\r\n     *  is very high quality\r\n     * @param {Number} [config.pixelRatio] pixelRatio of output image. Default is 1.\r\n     * You can use that property to increase quality of the image, for example for super hight quality exports\r\n     * or usage on retina (or similar) displays. pixelRatio will be used to multiply the size of exported image.\r\n     * If you export to 500x500 size with pixelRatio = 2, then produced image will have size 1000x1000.\r\n     * @example\r\n     * var image = node.toImage({\r\n     *   callback(img) {\r\n     *     // do stuff with img\r\n     *   }\r\n     * });\r\n     */\r\n    Node.prototype.toImage = function (config) {\r\n        if (!config || !config.callback) {\r\n            throw 'callback required for toImage method config argument';\r\n        }\r\n        var callback = config.callback;\r\n        delete config.callback;\r\n        Util._urlToImage(this.toDataURL(config), function (img) {\r\n            callback(img);\r\n        });\r\n    };\r\n    Node.prototype.setSize = function (size) {\r\n        this.width(size.width);\r\n        this.height(size.height);\r\n        return this;\r\n    };\r\n    Node.prototype.getSize = function () {\r\n        return {\r\n            width: this.width(),\r\n            height: this.height()\r\n        };\r\n    };\r\n    /**\r\n     * get class name, which may return Stage, Layer, Group, or shape class names like Rect, Circle, Text, etc.\r\n     * @method\r\n     * @name Konva.Node#getClassName\r\n     * @returns {String}\r\n     */\r\n    Node.prototype.getClassName = function () {\r\n        return this.className || this.nodeType;\r\n    };\r\n    /**\r\n     * get the node type, which may return Stage, Layer, Group, or Shape\r\n     * @method\r\n     * @name Konva.Node#getType\r\n     * @returns {String}\r\n     */\r\n    Node.prototype.getType = function () {\r\n        return this.nodeType;\r\n    };\r\n    Node.prototype.getDragDistance = function () {\r\n        // compare with undefined because we need to track 0 value\r\n        if (this.attrs.dragDistance !== undefined) {\r\n            return this.attrs.dragDistance;\r\n        }\r\n        else if (this.parent) {\r\n            return this.parent.getDragDistance();\r\n        }\r\n        else {\r\n            return Konva.dragDistance;\r\n        }\r\n    };\r\n    Node.prototype._off = function (type, name, callback) {\r\n        var evtListeners = this.eventListeners[type], i, evtName, handler;\r\n        for (i = 0; i < evtListeners.length; i++) {\r\n            evtName = evtListeners[i].name;\r\n            handler = evtListeners[i].handler;\r\n            // the following two conditions must be true in order to remove a handler:\r\n            // 1) the current event name cannot be konva unless the event name is konva\r\n            //    this enables developers to force remove a konva specific listener for whatever reason\r\n            // 2) an event name is not specified, or if one is specified, it matches the current event name\r\n            if ((evtName !== 'konva' || name === 'konva') &&\r\n                (!name || evtName === name) &&\r\n                (!callback || callback === handler)) {\r\n                evtListeners.splice(i, 1);\r\n                if (evtListeners.length === 0) {\r\n                    delete this.eventListeners[type];\r\n                    break;\r\n                }\r\n                i--;\r\n            }\r\n        }\r\n    };\r\n    Node.prototype._fireChangeEvent = function (attr, oldVal, newVal) {\r\n        this._fire(attr + CHANGE, {\r\n            oldVal: oldVal,\r\n            newVal: newVal\r\n        });\r\n    };\r\n    Node.prototype.setId = function (id) {\r\n        var oldId = this.id();\r\n        _removeId(oldId, this);\r\n        _addId(this, id);\r\n        this._setAttr('id', id);\r\n        return this;\r\n    };\r\n    Node.prototype.setName = function (name) {\r\n        var oldNames = (this.name() || '').split(/\\s/g);\r\n        var newNames = (name || '').split(/\\s/g);\r\n        var subname, i;\r\n        // remove all subnames\r\n        for (i = 0; i < oldNames.length; i++) {\r\n            subname = oldNames[i];\r\n            if (newNames.indexOf(subname) === -1 && subname) {\r\n                _removeName(subname, this._id);\r\n            }\r\n        }\r\n        // add new names\r\n        for (i = 0; i < newNames.length; i++) {\r\n            subname = newNames[i];\r\n            if (oldNames.indexOf(subname) === -1 && subname) {\r\n                _addName(this, subname);\r\n            }\r\n        }\r\n        this._setAttr(NAME, name);\r\n        return this;\r\n    };\r\n    /**\r\n     * add name to node\r\n     * @method\r\n     * @name Konva.Node#addName\r\n     * @param {String} name\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * node.name('red');\r\n     * node.addName('selected');\r\n     * node.name(); // return 'red selected'\r\n     */\r\n    Node.prototype.addName = function (name) {\r\n        if (!this.hasName(name)) {\r\n            var oldName = this.name();\r\n            var newName = oldName ? oldName + ' ' + name : name;\r\n            this.setName(newName);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * check is node has name\r\n     * @method\r\n     * @name Konva.Node#hasName\r\n     * @param {String} name\r\n     * @returns {Boolean}\r\n     * @example\r\n     * node.name('red');\r\n     * node.hasName('red');   // return true\r\n     * node.hasName('selected'); // return false\r\n     * node.hasName(''); // return false\r\n     */\r\n    Node.prototype.hasName = function (name) {\r\n        if (!name) {\r\n            return false;\r\n        }\r\n        var fullName = this.name();\r\n        if (!fullName) {\r\n            return false;\r\n        }\r\n        // if name is '' the \"names\" will be [''], so I added extra check above\r\n        var names = (fullName || '').split(/\\s/g);\r\n        return names.indexOf(name) !== -1;\r\n    };\r\n    /**\r\n     * remove name from node\r\n     * @method\r\n     * @name Konva.Node#removeName\r\n     * @param {String} name\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * node.name('red selected');\r\n     * node.removeName('selected');\r\n     * node.hasName('selected'); // return false\r\n     * node.name(); // return 'red'\r\n     */\r\n    Node.prototype.removeName = function (name) {\r\n        var names = (this.name() || '').split(/\\s/g);\r\n        var index = names.indexOf(name);\r\n        if (index !== -1) {\r\n            names.splice(index, 1);\r\n            this.setName(names.join(' '));\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * set attr\r\n     * @method\r\n     * @name Konva.Node#setAttr\r\n     * @param {String} attr\r\n     * @param {*} val\r\n     * @returns {Konva.Node}\r\n     * @example\r\n     * node.setAttr('x', 5);\r\n     */\r\n    Node.prototype.setAttr = function (attr, val) {\r\n        var func = this[SET + Util._capitalize(attr)];\r\n        if (Util._isFunction(func)) {\r\n            func.call(this, val);\r\n        }\r\n        else {\r\n            // otherwise set directly\r\n            this._setAttr(attr, val);\r\n        }\r\n        return this;\r\n    };\r\n    Node.prototype._setAttr = function (key, val) {\r\n        var oldVal = this.attrs[key];\r\n        if (oldVal === val && !Util.isObject(val)) {\r\n            return;\r\n        }\r\n        if (val === undefined || val === null) {\r\n            delete this.attrs[key];\r\n        }\r\n        else {\r\n            this.attrs[key] = val;\r\n        }\r\n        this._fireChangeEvent(key, oldVal, val);\r\n    };\r\n    Node.prototype._setComponentAttr = function (key, component, val) {\r\n        var oldVal;\r\n        if (val !== undefined) {\r\n            oldVal = this.attrs[key];\r\n            if (!oldVal) {\r\n                // set value to default value using getAttr\r\n                this.attrs[key] = this.getAttr(key);\r\n            }\r\n            this.attrs[key][component] = val;\r\n            this._fireChangeEvent(key, oldVal, val);\r\n        }\r\n    };\r\n    Node.prototype._fireAndBubble = function (eventType, evt, compareShape) {\r\n        if (evt && this.nodeType === SHAPE) {\r\n            evt.target = this;\r\n        }\r\n        var shouldStop = (eventType === MOUSEENTER || eventType === MOUSELEAVE) &&\r\n            ((compareShape &&\r\n                (this === compareShape ||\r\n                    (this.isAncestorOf && this.isAncestorOf(compareShape)))) ||\r\n                (this.nodeType === 'Stage' && !compareShape));\r\n        if (!shouldStop) {\r\n            this._fire(eventType, evt);\r\n            // simulate event bubbling\r\n            var stopBubble = (eventType === MOUSEENTER || eventType === MOUSELEAVE) &&\r\n                (compareShape &&\r\n                    compareShape.isAncestorOf &&\r\n                    compareShape.isAncestorOf(this) &&\r\n                    !compareShape.isAncestorOf(this.parent));\r\n            if (((evt && !evt.cancelBubble) || !evt) &&\r\n                this.parent &&\r\n                this.parent.isListening() &&\r\n                !stopBubble) {\r\n                if (compareShape && compareShape.parent) {\r\n                    this._fireAndBubble.call(this.parent, eventType, evt, compareShape.parent);\r\n                }\r\n                else {\r\n                    this._fireAndBubble.call(this.parent, eventType, evt);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Node.prototype._fire = function (eventType, evt) {\r\n        var events = this.eventListeners[eventType], i;\r\n        if (events) {\r\n            evt = evt || {};\r\n            evt.currentTarget = this;\r\n            evt.type = eventType;\r\n            for (i = 0; i < events.length; i++) {\r\n                events[i].handler.call(this, evt);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * draw both scene and hit graphs.  If the node being drawn is the stage, all of the layers will be cleared and redrawn\r\n     * @method\r\n     * @name Konva.Node#draw\r\n     * @returns {Konva.Node}\r\n     */\r\n    Node.prototype.draw = function () {\r\n        this.drawScene();\r\n        this.drawHit();\r\n        return this;\r\n    };\r\n    // drag & drop\r\n    /**\r\n     * initiate drag and drop\r\n     * @method\r\n     * @name Konva.Node#startDrag\r\n     */\r\n    Node.prototype.startDrag = function () {\r\n        var stage = this.getStage(), layer = this.getLayer(), pos = stage.getPointerPosition(), ap = this.getAbsolutePosition();\r\n        if (pos) {\r\n            if (DD.node) {\r\n                DD.node.stopDrag();\r\n            }\r\n            DD.node = this;\r\n            DD.startPointerPos = pos;\r\n            DD.offset.x = pos.x - ap.x;\r\n            DD.offset.y = pos.y - ap.y;\r\n            DD.anim.setLayers(layer || this['getLayers']());\r\n            DD.anim.start();\r\n            this._setDragPosition();\r\n        }\r\n    };\r\n    Node.prototype._setDragPosition = function (evt) {\r\n        var pos = this.getStage().getPointerPosition(), dbf = this.dragBoundFunc();\r\n        if (!pos) {\r\n            return;\r\n        }\r\n        var newNodePos = {\r\n            x: pos.x - DD.offset.x,\r\n            y: pos.y - DD.offset.y\r\n        };\r\n        if (dbf !== undefined) {\r\n            newNodePos = dbf.call(this, newNodePos, evt);\r\n        }\r\n        this.setAbsolutePosition(newNodePos);\r\n        if (!this._lastPos ||\r\n            this._lastPos.x !== newNodePos.x ||\r\n            this._lastPos.y !== newNodePos.y) {\r\n            DD.anim['dirty'] = true;\r\n        }\r\n        this._lastPos = newNodePos;\r\n    };\r\n    /**\r\n     * stop drag and drop\r\n     * @method\r\n     * @name Konva.Node#stopDrag\r\n     */\r\n    Node.prototype.stopDrag = function () {\r\n        var evt = {};\r\n        DD._endDragBefore(evt);\r\n        DD._endDragAfter(evt);\r\n    };\r\n    Node.prototype.setDraggable = function (draggable) {\r\n        this._setAttr('draggable', draggable);\r\n        this._dragChange();\r\n    };\r\n    /**\r\n     * determine if node is currently in drag and drop mode\r\n     * @method\r\n     * @name Konva.Node#isDragging\r\n     */\r\n    Node.prototype.isDragging = function () {\r\n        return !!(DD.node && DD.node === this && DD.isDragging);\r\n    };\r\n    Node.prototype._listenDrag = function () {\r\n        this._dragCleanup();\r\n        this.on('mousedown.konva touchstart.konva', function (evt) {\r\n            var shouldCheckButton = evt.evt['button'] !== undefined;\r\n            var canDrag = !shouldCheckButton || Konva.dragButtons.indexOf(evt.evt['button']) >= 0;\r\n            if (!canDrag) {\r\n                return;\r\n            }\r\n            if (!DD.node) {\r\n                this.startDrag();\r\n            }\r\n        });\r\n    };\r\n    Node.prototype._dragChange = function () {\r\n        if (this.attrs.draggable) {\r\n            this._listenDrag();\r\n        }\r\n        else {\r\n            // remove event listeners\r\n            this._dragCleanup();\r\n            /*\r\n             * force drag and drop to end\r\n             * if this node is currently in\r\n             * drag and drop mode\r\n             */\r\n            var stage = this.getStage();\r\n            var dd = DD;\r\n            if (stage && dd.node && dd.node._id === this._id) {\r\n                dd.node.stopDrag();\r\n            }\r\n        }\r\n    };\r\n    Node.prototype._dragCleanup = function () {\r\n        this.off('mousedown.konva');\r\n        this.off('touchstart.konva');\r\n    };\r\n    /**\r\n     * create node with JSON string or an Object.  De-serializtion does not generate custom\r\n     *  shape drawing functions, images, or event handlers (this would make the\r\n     *  serialized object huge).  If your app uses custom shapes, images, and\r\n     *  event handlers (it probably does), then you need to select the appropriate\r\n     *  shapes after loading the stage and set these properties via on(), setSceneFunc(),\r\n     *  and setImage() methods\r\n     * @method\r\n     * @memberof Konva.Node\r\n     * @param {String|Object} json string or object\r\n     * @param {Element} [container] optional container dom element used only if you're\r\n     *  creating a stage node\r\n     */\r\n    Node.create = function (data, container) {\r\n        if (Util._isString(data)) {\r\n            data = JSON.parse(data);\r\n        }\r\n        return this._createNode(data, container);\r\n    };\r\n    Node._createNode = function (obj, container) {\r\n        var className = Node.prototype.getClassName.call(obj), children = obj.children, no, len, n;\r\n        // if container was passed in, add it to attrs\r\n        if (container) {\r\n            obj.attrs.container = container;\r\n        }\r\n        if (!_NODES_REGISTRY[className]) {\r\n            Util.warn('Can not find a node with class name \"' +\r\n                className +\r\n                '\". Fallback to \"Shape\".');\r\n            className = 'Shape';\r\n        }\r\n        var Class = _NODES_REGISTRY[className];\r\n        no = new Class(obj.attrs);\r\n        if (children) {\r\n            len = children.length;\r\n            for (n = 0; n < len; n++) {\r\n                no.add(Node._createNode(children[n]));\r\n            }\r\n        }\r\n        return no;\r\n    };\r\n    return Node;\r\n}());\r\nexport { Node };\r\nNode.prototype.nodeType = 'Node';\r\nNode.prototype._attrsAffectingSize = [];\r\n/**\r\n * get/set zIndex relative to the node's siblings who share the same parent.\r\n * Please remember that zIndex is not absolute (like in CSS). It is relative to parent element only.\r\n * @name Konva.Node#zIndex\r\n * @method\r\n * @param {Number} index\r\n * @returns {Number}\r\n * @example\r\n * // get index\r\n * var index = node.zIndex();\r\n *\r\n * // set index\r\n * node.zIndex(2);\r\n */\r\nFactory.addGetterSetter(Node, 'zIndex');\r\n/**\r\n * get/set node absolute position\r\n * @name Konva.Node#absolutePosition\r\n * @method\r\n * @param {Object} pos\r\n * @param {Number} pos.x\r\n * @param {Number} pos.y\r\n * @returns {Object}\r\n * @example\r\n * // get position\r\n * var position = node.absolutePosition();\r\n *\r\n * // set position\r\n * node.absolutePosition({\r\n *   x: 5,\r\n *   y: 10\r\n * });\r\n */\r\nFactory.addGetterSetter(Node, 'absolutePosition');\r\nFactory.addGetterSetter(Node, 'position');\r\n/**\r\n * get/set node position relative to parent\r\n * @name Konva.Node#position\r\n * @method\r\n * @param {Object} pos\r\n * @param {Number} pos.x\r\n * @param {Number} pos.y\r\n * @returns {Object}\r\n * @example\r\n * // get position\r\n * var position = node.position();\r\n *\r\n * // set position\r\n * node.position({\r\n *   x: 5,\r\n *   y: 10\r\n * });\r\n */\r\nFactory.addGetterSetter(Node, 'x', 0, getNumberValidator());\r\n/**\r\n * get/set x position\r\n * @name Konva.Node#x\r\n * @method\r\n * @param {Number} x\r\n * @returns {Object}\r\n * @example\r\n * // get x\r\n * var x = node.x();\r\n *\r\n * // set x\r\n * node.x(5);\r\n */\r\nFactory.addGetterSetter(Node, 'y', 0, getNumberValidator());\r\n/**\r\n * get/set y position\r\n * @name Konva.Node#y\r\n * @method\r\n * @param {Number} y\r\n * @returns {Integer}\r\n * @example\r\n * // get y\r\n * var y = node.y();\r\n *\r\n * // set y\r\n * node.y(5);\r\n */\r\nFactory.addGetterSetter(Node, 'globalCompositeOperation', 'source-over', getStringValidator());\r\n/**\r\n * get/set globalCompositeOperation of a shape\r\n * @name Konva.Node#globalCompositeOperation\r\n * @method\r\n * @param {String} type\r\n * @returns {String}\r\n * @example\r\n * // get globalCompositeOperation\r\n * var globalCompositeOperation = shape.globalCompositeOperation();\r\n *\r\n * // set globalCompositeOperation\r\n * shape.globalCompositeOperation('source-in');\r\n */\r\nFactory.addGetterSetter(Node, 'opacity', 1, getNumberValidator());\r\n/**\r\n * get/set opacity.  Opacity values range from 0 to 1.\r\n *  A node with an opacity of 0 is fully transparent, and a node\r\n *  with an opacity of 1 is fully opaque\r\n * @name Konva.Node#opacity\r\n * @method\r\n * @param {Object} opacity\r\n * @returns {Number}\r\n * @example\r\n * // get opacity\r\n * var opacity = node.opacity();\r\n *\r\n * // set opacity\r\n * node.opacity(0.5);\r\n */\r\nFactory.addGetterSetter(Node, 'name', '', getStringValidator());\r\n/**\r\n * get/set name\r\n * @name Konva.Node#name\r\n * @method\r\n * @param {String} name\r\n * @returns {String}\r\n * @example\r\n * // get name\r\n * var name = node.name();\r\n *\r\n * // set name\r\n * node.name('foo');\r\n *\r\n * // also node may have multiple names (as css classes)\r\n * node.name('foo bar');\r\n */\r\nFactory.addGetterSetter(Node, 'id', '', getStringValidator());\r\n/**\r\n * get/set id. Id is global for whole page.\r\n * @name Konva.Node#id\r\n * @method\r\n * @param {String} id\r\n * @returns {String}\r\n * @example\r\n * // get id\r\n * var name = node.id();\r\n *\r\n * // set id\r\n * node.id('foo');\r\n */\r\nFactory.addGetterSetter(Node, 'rotation', 0, getNumberValidator());\r\n/**\r\n * get/set rotation in degrees\r\n * @name Konva.Node#rotation\r\n * @method\r\n * @param {Number} rotation\r\n * @returns {Number}\r\n * @example\r\n * // get rotation in degrees\r\n * var rotation = node.rotation();\r\n *\r\n * // set rotation in degrees\r\n * node.rotation(45);\r\n */\r\nFactory.addComponentsGetterSetter(Node, 'scale', ['x', 'y']);\r\n/**\r\n * get/set scale\r\n * @name Konva.Node#scale\r\n * @param {Object} scale\r\n * @param {Number} scale.x\r\n * @param {Number} scale.y\r\n * @method\r\n * @returns {Object}\r\n * @example\r\n * // get scale\r\n * var scale = node.scale();\r\n *\r\n * // set scale\r\n * shape.scale({\r\n *   x: 2,\r\n *   y: 3\r\n * });\r\n */\r\nFactory.addGetterSetter(Node, 'scaleX', 1, getNumberValidator());\r\n/**\r\n * get/set scale x\r\n * @name Konva.Node#scaleX\r\n * @param {Number} x\r\n * @method\r\n * @returns {Number}\r\n * @example\r\n * // get scale x\r\n * var scaleX = node.scaleX();\r\n *\r\n * // set scale x\r\n * node.scaleX(2);\r\n */\r\nFactory.addGetterSetter(Node, 'scaleY', 1, getNumberValidator());\r\n/**\r\n * get/set scale y\r\n * @name Konva.Node#scaleY\r\n * @param {Number} y\r\n * @method\r\n * @returns {Number}\r\n * @example\r\n * // get scale y\r\n * var scaleY = node.scaleY();\r\n *\r\n * // set scale y\r\n * node.scaleY(2);\r\n */\r\nFactory.addComponentsGetterSetter(Node, 'skew', ['x', 'y']);\r\n/**\r\n * get/set skew\r\n * @name Konva.Node#skew\r\n * @param {Object} skew\r\n * @param {Number} skew.x\r\n * @param {Number} skew.y\r\n * @method\r\n * @returns {Object}\r\n * @example\r\n * // get skew\r\n * var skew = node.skew();\r\n *\r\n * // set skew\r\n * node.skew({\r\n *   x: 20,\r\n *   y: 10\r\n * });\r\n */\r\nFactory.addGetterSetter(Node, 'skewX', 0, getNumberValidator());\r\n/**\r\n * get/set skew x\r\n * @name Konva.Node#skewX\r\n * @param {Number} x\r\n * @method\r\n * @returns {Number}\r\n * @example\r\n * // get skew x\r\n * var skewX = node.skewX();\r\n *\r\n * // set skew x\r\n * node.skewX(3);\r\n */\r\nFactory.addGetterSetter(Node, 'skewY', 0, getNumberValidator());\r\n/**\r\n * get/set skew y\r\n * @name Konva.Node#skewY\r\n * @param {Number} y\r\n * @method\r\n * @returns {Number}\r\n * @example\r\n * // get skew y\r\n * var skewY = node.skewY();\r\n *\r\n * // set skew y\r\n * node.skewY(3);\r\n */\r\nFactory.addComponentsGetterSetter(Node, 'offset', ['x', 'y']);\r\n/**\r\n * get/set offset.  Offsets the default position and rotation point\r\n * @method\r\n * @param {Object} offset\r\n * @param {Number} offset.x\r\n * @param {Number} offset.y\r\n * @returns {Object}\r\n * @example\r\n * // get offset\r\n * var offset = node.offset();\r\n *\r\n * // set offset\r\n * node.offset({\r\n *   x: 20,\r\n *   y: 10\r\n * });\r\n */\r\nFactory.addGetterSetter(Node, 'offsetX', 0, getNumberValidator());\r\n/**\r\n * get/set offset x\r\n * @name Konva.Node#offsetX\r\n * @method\r\n * @param {Number} x\r\n * @returns {Number}\r\n * @example\r\n * // get offset x\r\n * var offsetX = node.offsetX();\r\n *\r\n * // set offset x\r\n * node.offsetX(3);\r\n */\r\nFactory.addGetterSetter(Node, 'offsetY', 0, getNumberValidator());\r\n/**\r\n * get/set offset y\r\n * @name Konva.Node#offsetY\r\n * @method\r\n * @param {Number} y\r\n * @returns {Number}\r\n * @example\r\n * // get offset y\r\n * var offsetY = node.offsetY();\r\n *\r\n * // set offset y\r\n * node.offsetY(3);\r\n */\r\nFactory.addGetterSetter(Node, 'dragDistance', null, getNumberValidator());\r\n/**\r\n * get/set drag distance\r\n * @name Konva.Node#dragDistance\r\n * @method\r\n * @param {Number} distance\r\n * @returns {Number}\r\n * @example\r\n * // get drag distance\r\n * var dragDistance = node.dragDistance();\r\n *\r\n * // set distance\r\n * // node starts dragging only if pointer moved more then 3 pixels\r\n * node.dragDistance(3);\r\n * // or set globally\r\n * Konva.dragDistance = 3;\r\n */\r\nFactory.addGetterSetter(Node, 'width', 0, getNumberValidator());\r\n/**\r\n * get/set width\r\n * @name Konva.Node#width\r\n * @method\r\n * @param {Number} width\r\n * @returns {Number}\r\n * @example\r\n * // get width\r\n * var width = node.width();\r\n *\r\n * // set width\r\n * node.width(100);\r\n */\r\nFactory.addGetterSetter(Node, 'height', 0, getNumberValidator());\r\n/**\r\n * get/set height\r\n * @name Konva.Node#height\r\n * @method\r\n * @param {Number} height\r\n * @returns {Number}\r\n * @example\r\n * // get height\r\n * var height = node.height();\r\n *\r\n * // set height\r\n * node.height(100);\r\n */\r\nFactory.addGetterSetter(Node, 'listening', 'inherit', function (val) {\r\n    var isValid = val === true || val === false || val === 'inherit';\r\n    if (!isValid) {\r\n        Util.warn(val +\r\n            ' is a not valid value for \"listening\" attribute. The value may be true, false or \"inherit\".');\r\n    }\r\n    return val;\r\n});\r\n/**\r\n * get/set listenig attr.  If you need to determine if a node is listening or not\r\n *   by taking into account its parents, use the isListening() method\r\n * @name Konva.Node#listening\r\n * @method\r\n * @param {Boolean|String} listening Can be \"inherit\", true, or false.  The default is \"inherit\".\r\n * @returns {Boolean|String}\r\n * @example\r\n * // get listening attr\r\n * var listening = node.listening();\r\n *\r\n * // stop listening for events\r\n * node.listening(false);\r\n *\r\n * // listen for events\r\n * node.listening(true);\r\n *\r\n * // listen to events according to the parent\r\n * node.listening('inherit');\r\n */\r\n/**\r\n * get/set preventDefault\r\n * By default all shapes will prevent default behaviour\r\n * of a browser on a pointer move or tap.\r\n * that will prevent native scrolling when you are trying to drag&drop a node\r\n * but sometimes you may need to enable default actions\r\n * in that case you can set the property to false\r\n * @name Konva.Node#preventDefault\r\n * @method\r\n * @param {Number} preventDefault\r\n * @returns {Number}\r\n * @example\r\n * // get preventDefault\r\n * var shouldPrevent = shape.preventDefault();\r\n *\r\n * // set preventDefault\r\n * shape.preventDefault(false);\r\n */\r\nFactory.addGetterSetter(Node, 'preventDefault', true, getBooleanValidator());\r\nFactory.addGetterSetter(Node, 'filters', null, function (val) {\r\n    this._filterUpToDate = false;\r\n    return val;\r\n});\r\n/**\r\n * get/set filters.  Filters are applied to cached canvases\r\n * @name Konva.Node#filters\r\n * @method\r\n * @param {Array} filters array of filters\r\n * @returns {Array}\r\n * @example\r\n * // get filters\r\n * var filters = node.filters();\r\n *\r\n * // set a single filter\r\n * node.cache();\r\n * node.filters([Konva.Filters.Blur]);\r\n *\r\n * // set multiple filters\r\n * node.cache();\r\n * node.filters([\r\n *   Konva.Filters.Blur,\r\n *   Konva.Filters.Sepia,\r\n *   Konva.Filters.Invert\r\n * ]);\r\n */\r\nFactory.addGetterSetter(Node, 'visible', 'inherit', function (val) {\r\n    var isValid = val === true || val === false || val === 'inherit';\r\n    if (!isValid) {\r\n        Util.warn(val +\r\n            ' is a not valid value for \"visible\" attribute. The value may be true, false or \"inherit\".');\r\n    }\r\n    return val;\r\n});\r\n/**\r\n * get/set visible attr.  Can be \"inherit\", true, or false.  The default is \"inherit\".\r\n *   If you need to determine if a node is visible or not\r\n *   by taking into account its parents, use the isVisible() method\r\n * @name Konva.Node#visible\r\n * @method\r\n * @param {Boolean|String} visible\r\n * @returns {Boolean|String}\r\n * @example\r\n * // get visible attr\r\n * var visible = node.visible();\r\n *\r\n * // make invisible\r\n * node.visible(false);\r\n *\r\n * // make visible\r\n * node.visible(true);\r\n *\r\n * // make visible according to the parent\r\n * node.visible('inherit');\r\n */\r\nFactory.addGetterSetter(Node, 'transformsEnabled', 'all', getStringValidator());\r\n/**\r\n * get/set transforms that are enabled.  Can be \"all\", \"none\", or \"position\".  The default\r\n *  is \"all\"\r\n * @name Konva.Node#transformsEnabled\r\n * @method\r\n * @param {String} enabled\r\n * @returns {String}\r\n * @example\r\n * // enable position transform only to improve draw performance\r\n * node.transformsEnabled('position');\r\n *\r\n * // enable all transforms\r\n * node.transformsEnabled('all');\r\n */\r\n/**\r\n * get/set node size\r\n * @name Konva.Node#size\r\n * @method\r\n * @param {Object} size\r\n * @param {Number} size.width\r\n * @param {Number} size.height\r\n * @returns {Object}\r\n * @example\r\n * // get node size\r\n * var size = node.size();\r\n * var x = size.x;\r\n * var y = size.y;\r\n *\r\n * // set size\r\n * node.size({\r\n *   width: 100,\r\n *   height: 200\r\n * });\r\n */\r\nFactory.addGetterSetter(Node, 'size');\r\n/**\r\n * get/set drag bound function.  This is used to override the default\r\n *  drag and drop position.\r\n * @name Konva.Node#dragBoundFunc\r\n * @method\r\n * @param {Function} dragBoundFunc\r\n * @returns {Function}\r\n * @example\r\n * // get drag bound function\r\n * var dragBoundFunc = node.dragBoundFunc();\r\n *\r\n * // create vertical drag and drop\r\n * node.dragBoundFunc(function(pos){\r\n *   // important pos - is absolute position of the node\r\n *   // you should return absolute position too\r\n *   return {\r\n *     x: this.absolutePosition().x,\r\n *     y: pos.y\r\n *   };\r\n * });\r\n */\r\nFactory.addGetterSetter(Node, 'dragBoundFunc');\r\n/**\r\n * get/set draggable flag\r\n * @name Konva.Node#draggable\r\n * @method\r\n * @param {Boolean} draggable\r\n * @returns {Boolean}\r\n * @example\r\n * // get draggable flag\r\n * var draggable = node.draggable();\r\n *\r\n * // enable drag and drop\r\n * node.draggable(true);\r\n *\r\n * // disable drag and drop\r\n * node.draggable(false);\r\n */\r\nFactory.addGetterSetter(Node, 'draggable', false, getBooleanValidator());\r\nFactory.backCompat(Node, {\r\n    rotateDeg: 'rotate',\r\n    setRotationDeg: 'setRotation',\r\n    getRotationDeg: 'getRotation'\r\n});\r\nCollection.mapMethods(Node);\r\n"}
